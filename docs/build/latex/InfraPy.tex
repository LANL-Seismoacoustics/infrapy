%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}


\title{InfraPy Documentation}
\date{Jun 08, 2020}
\release{1.0}
\author{F.Dannemann Dugick, P.Blom, J.Webster }
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Contents}
\label{\detokenize{index:module-infrapy}}\label{\detokenize{index:contents}}\index{infrapy (module)@\spxentry{infrapy}\spxextra{module}}
Welcome to Infrapy’s documentation.  Get started with {\hyperref[\detokenize{installation:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{Installation}}}} and then get an overview with the {\hyperref[\detokenize{quickstart:quickstart}]{\sphinxcrossref{\DUrole{std,std-ref}{Quickstart}}}}.  There is also a more detailed {\hyperref[\detokenize{tutorial:tutorial}]{\sphinxcrossref{\DUrole{std,std-ref}{Tutorial}}}} that demonstrates the various processing capabilities of infrapy.  The rest of the docs describe each component in detail, with a full reference in the {\hyperref[\detokenize{infrapy:api}]{\sphinxcrossref{\DUrole{std,std-ref}{API}}}} section.

This document is a work in progress and may be updated as development of Infrapy continues.

\noindent\sphinxincludegraphics{{infrapy}.png}

This part of the documentation, which is mostly prose, begins with some background information about Infrapy, then focuses on step\sphinxhyphen{}by\sphinxhyphen{}step instructions for data processing using Infrapy.


\section{Overview}
\label{\detokenize{userguide:overview}}\label{\detokenize{userguide::doc}}
Infrapy is a tool for processing infrasound and seismic array data. Infrapy implements a database\sphinxhyphen{}centric
approach for pipeline continuous near real\sphinxhyphen{}time analysis. The pipeline includes analysis at station and network levels (using beam\sphinxhyphen{}forming and clustering techniques, respectively) for the
detection, association and location of events.  The pipeline relies on the interaction of the algorithms with a relational database structure to organize and store waveform data, the
parameters for the analysis, and results of both levels of analysis. Our implementation can interact seamlessly with traditional (e.g.: Oracle) and serverless (e.g.: SQLite) relational databases.


\section{Authorship}
\label{\detokenize{authorship:authorship}}\label{\detokenize{authorship::doc}}
Infrapy was built upon previous similar (InfraMonitor) tools and developed by the LANL SeismoAcoustic Team.

Philip Blom
pblom at lanl.gov

Jeremy Webster
jwebster at lanl.gov

Fransiska Dannemann Dugick
fransiska at lanl.gov


\section{Installation}
\label{\detokenize{installation:installation}}\label{\detokenize{installation:id1}}\label{\detokenize{installation::doc}}

\subsection{Operating Systems}
\label{\detokenize{installation:operating-systems}}
Infrapy can currently be installed on machines running newer versions of Linux or Apple OSX.  A Windows\sphinxhyphen{}compatible version is in development.


\subsection{Anaconda}
\label{\detokenize{installation:anaconda}}
The installation of infrapy currently depends on Anaconda to resolve and download the correct python libraries. So if you don’t currently have anaconda installed
on your system, please do that first.

Anaconda can be downloaded from \sphinxurl{https://www.anaconda.com/distribution/}. Either 3.x or 2.x will work since the numbers refer to the Python version of the default
environment.  Infrapy’s installation will create a new environment and will install the version of Python that it needs into that environment.


\subsection{Infrapy Installation}
\label{\detokenize{installation:infrapy-installation}}
Once Anaconda is installed, you can install infrapy by navigating to the base directory of the infrapy package (there will be a file there
named infrapy\_env.yml), and run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYGZgt{} conda env create \PYGZhy{}f infrapy\PYGZus{}env.yml
\end{sphinxVerbatim}

If this command executes correctly and finishes without errors, it should print out instructions on how to activate and deactivate the new environment:

To activate the environment, use:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYGZgt{} conda activate infrapy\PYGZus{}env
\end{sphinxVerbatim}

To deactivate an active environment, use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYGZgt{} conda deactivate
\end{sphinxVerbatim}


\subsection{Testing}
\label{\detokenize{installation:testing}}
Once the installation is complete, you can test some things by first activating the environment with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYGZgt{} conda activate infrapy\PYGZus{}env
\end{sphinxVerbatim}

Then navigate to the /example directory located in the infrapy base directory, and run the test scripts via something like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYGZgt{} python test\PYGZus{}beamforming.py
\end{sphinxVerbatim}

If infrapy was successfully installed, all of the test scripts should run and finish without any errors.


\subsection{Running the InfraView GUI Application}
\label{\detokenize{installation:running-the-infraview-gui-application}}
Once installation is complete, and the new environment is activated, you can run the GUI with the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYGZgt{} infraview
\end{sphinxVerbatim}


\section{Quickstart}
\label{\detokenize{quickstart:quickstart}}\label{\detokenize{quickstart:id1}}\label{\detokenize{quickstart::doc}}
A series of scripts illustrating how to use infrapy subroutines as stand\sphinxhyphen{}alone modules are found in the /examples folder.
The jupyter notebook documenting these steps is found in /tutorials/Quick Start.ipynb.  The notebook can be run by installing jupyter notebook via conda.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{conda} \PYG{n}{install} \PYG{n}{jupyter} \PYG{n}{notebook}
\end{sphinxVerbatim}

Beamforming:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Run Bartlett, Capon or Generalized Least Squares beamforming processes on an hour\sphinxhyphen{}long dataset from the BRP array in Utah

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{python} \PYG{n}{test\PYGZus{}beamforming}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Visualize beamforming results in the sx/sy space

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{python} \PYG{n}{test\PYGZus{}slowness}\PYG{o}{\PYGZhy{}}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

Detection:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Run detection on the series of beamforming results produced in the above step

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{python} \PYG{n}{test\PYGZus{}detection}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

Association
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Associate a number of detections contained in a .dat file (/data/detection\_set1.dat or /data/detection\_set2.dat)

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{python} \PYG{n}{test\PYGZus{}assoc}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

Location
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Test the Bayesian Infrasonic Source Localization (BISL) methodology using a set of provided detections (/data/detection\_set1.dat or /data/detection\_set2.dat).  Location will be run twice, once assuming uniform atmospheric propagation and a second time applying provided atmospheric propagation priors for the Western US (see Blom et al., 2015 for further explanation)

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{python} \PYG{n}{test\PYGZus{}bisl}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}


\section{Interfacing with Pisces}
\label{\detokenize{pisces:interfacing-with-pisces}}\label{\detokenize{pisces:pisces}}\label{\detokenize{pisces::doc}}
Infrapy leverages pisces to connect with and process data in either local sqlite databases or oracle databases. More information about pisces can be found at \sphinxurl{https://jkmacc-lanl.github.io/pisces/}.


\subsection{Converting Data into Sqlite Databases}
\label{\detokenize{pisces:converting-data-into-sqlite-databases}}
Data in miniseed or sac formats can be loaded into a sqlite database for pipeline processing using commands from pisces.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
mseed to database (ms2db.py)

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{ms2db}\PYG{o}{.}\PYG{n}{py} \PYG{n}{sqlite}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{sqlite} \PYG{n}{mslist}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
sac to database (sac2db)

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{pisces} \PYG{n}{sac2db} \PYG{n}{sqlite}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{sqlite} \PYG{o}{*}\PYG{o}{.}\PYG{n}{sac}
\end{sphinxVerbatim}

As infrapy is an array processing tool, after your sqlite database is created, you will need to update the REFSTA for each array using update\_refsta.py

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{update\PYGZus{}refsta}\PYG{o}{.}\PYG{n}{py} \PYG{n}{sqlite}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{sqlite} \PYG{o}{\PYGZlt{}}\PYG{n}{array} \PYG{n}{name}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

You can update the calibration for each array using update\_calib.py

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{update\PYGZus{}calib}\PYG{o}{.}\PYG{n}{py} \PYG{n}{sqlite}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{sqlite} \PYG{o}{\PYGZlt{}}\PYG{n}{array} \PYG{n}{name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{calibration}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Connecting to a SQL Database}
\label{\detokenize{pisces:connecting-to-a-sql-database}}
Infrapy employs two main methods for connecting to either Oracle or sqlite databases.  Example files to facilitate these connections are found in tutorials/.


\subsubsection{Defining Schema Specific Tables}
\label{\detokenize{pisces:defining-schema-specific-tables}}
Pipeline processing in infrapy utilizes information from CSS3.0 Site and Wfdisc tables.  If your database schema differs from the CSS3.0 schema in any way, you can define the differences using a \_global.py file.  An example \_global.py file is found in tutorial/ .


\subsubsection{Connection within pipeline processing configuration file}
\label{\detokenize{pisces:connection-within-pipeline-processing-configuration-file}}
The first three lines of your configuration file define the database you will connect to:

\sphinxstylestrong{Example Configuration File for Sqlite Processing (Sqlite\_Config.txt)}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[database] \PYGZsh{} required
\PYGZsh{} url to database where you have the pointers to data and metadata
url = sqlite:///example.sqlite
\PYGZsh{} schema specific tables for your site and wfdisc files.  If you are processing in a sqlite database, these variables will refer to schema specified in pisces. If you are processing in an oracle database, these variables will refer to schema specified in your global\PYGZus{}.py file
site = pisces.tables.css3:Site
wfdisc = pisces.tables.css3:Wfdisc
\end{sphinxVerbatim}

\sphinxstylestrong{Example Configuration File for Oracle DB Processing (Oracle\_Config.txt)}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[database] \PYGZsh{} required
url = oracle://\PYGZlt{}database name\PYGZgt{}:\PYGZlt{}port\PYGZgt{}
site = global\PYGZus{}:Site
wfdisc = global\PYGZus{}:Wfdisc\PYGZus{}raw
\end{sphinxVerbatim}


\subsubsection{Connection with a db.cfg file}
\label{\detokenize{pisces:connection-with-a-db-cfg-file}}
Some modules in infrapy (db2sac) require a .cfg file to establish connection with a database.  Examples are found in tutorial/ . More information can be found in the pisces documentation.

\sphinxstylestrong{Example Configuration File for Oracle DB Processing (oracle\_connection.cfg)}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[database] \PYGZsh{} required
url = oracle://\PYGZlt{}db name\PYGZgt{}:\PYGZlt{}db port\PYGZgt{}
site = global\PYGZus{}:Site
wfdisc = global\PYGZus{}:Wfdisc\PYGZus{}raw
origin = global\PYGZus{}:Origin
\end{sphinxVerbatim}

\sphinxstylestrong{Example Configuration File for Sqlite Processing (sqlite\_connection.cfg)}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[database] \PYGZsh{} required
url = sqlite:///example.sqlite
site = pisces.tables.css3:Site
wfdisc = pisces.tables.css3:Wfdisc
origin = pisces.tables.css3:Origin
\end{sphinxVerbatim}


\section{Algorithms}
\label{\detokenize{algorithms:algorithms}}\label{\detokenize{algorithms:id1}}\label{\detokenize{algorithms::doc}}\begin{itemize}
\item {} 
Analyst methods are modular so that results from other processing tools can be used in later analysis steps.

\item {} 
Algorithms are written to be data agnostic so analysis can be performed regardless of data source once IO method is established

\end{itemize}


\subsection{Station Level Processing}
\label{\detokenize{algorithms:station-level-processing}}

\subsubsection{Array Processing}
\label{\detokenize{algorithms:beamforming}}\begin{itemize}
\item {} 
Beamforming estimates parameters of coherent signals

\item {} 
Capabilities include methods to characterize transients as well as persistent signals

\item {} 
Transient signals are identified using standard Bartlett beaming

\item {} 
Persistent signals can be investigated using Minimum Variance Distortionless Response (MVDR) or MUltiple Signal Classification (MUSIC) algorithms

\end{itemize}


\subsubsection{The Adaptive F\sphinxhyphen{}Detector}
\label{\detokenize{algorithms:afd}}\begin{itemize}
\item {} 
Adaptive Fisher statistics determine when to declare a detection

\end{itemize}


\subsection{Network Level Processing}
\label{\detokenize{algorithms:network-level-processing}}

\subsubsection{Association}
\label{\detokenize{algorithms:association}}\begin{itemize}
\item {} 
Events are identified using a pair\sphinxhyphen{}based Bayesian algorithm that defines the association between detection pairs from their joint\sphinxhyphen{}likelihood and identifies events via hierarchical clustering analysis

\item {} 
Current implementation utilizes only spatial and temporal coincidence, but additional detection information can further improve event identification

\item {} 
Evaluation using a synthetic data set shows some mixing of spatially similar events poorly resolved by network geometry and occasional inclusion of “noise” detections in event clustering

\end{itemize}


\subsubsection{Bayesian Infrasonic Source Localization}
\label{\detokenize{algorithms:localization}}\begin{itemize}
\item {} 
Event analysis using the Bayesian Infrasonic Source Localization (BISL) methodology to estimate both the spatial location of the event as well as the origin time with quantified uncertainty

\item {} 
Preliminary analysis of the back projections can be used to define the spatial region of interest or it can be specified by the analysis

\item {} 
Analysis identifies the maximum posteriori solution

\item {} 
The marginalized spatial distribution is approximated as 2d\sphinxhyphen{}normal to define 95 and 99\% confidence ellipse bounds

\item {} 
The marginalized temporal distribution is analyzed to identify the exact 95 and 99\% confidence bounds

\item {} 
Likelihood definitions relating detection parameters to spatial and temporal source characteristics are shared between association and localization analysis for consistency
\begin{quote}


\paragraph{Array Processing}
\label{\detokenize{beamforming:array-processing}}\label{\detokenize{beamforming:beamforming}}\label{\detokenize{beamforming::doc}}
The use of infrasonic arrays, specifically for CTBT applications, is preferable due to the inherent reduction in signal\sphinxhyphen{}to\sphinxhyphen{}noise ratios (SNR) originating from the summation of four or more recordings at each array. The nature of a decision\sphinxhyphen{}rule based detector requires data that has been pre\sphinxhyphen{}processed using beamforming methods. Beamforming, a form of array processing, is the first step in the analysis of data from infrasonic arrays.    Conventional beamforming methods (Bartlett, Capon) separate coherent and incoherent parts of a signal through the assumption of planar waves arriving at the array.  A signal backazimuth and slowness can be estimated as signals are shifted to account for travel time differentials across array elements, bringing the signal into phase across as the noise deconstructively cancels out.  In the classical, or Bartlett methodology , data records on each array element are time\sphinxhyphen{}shifted versions of the other with local noise,

See the following for more references on beamforming:
\sphinxhref{https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2000RG000100}{Rost and Thomas 2002}
\sphinxhref{https://link.springer.com/chapter/10.1007/978-0-387-30441-0\_81}{Olson and Szuberla 2010}
\sphinxhref{https://asa.scitation.org/doi/full/10.1121/1.4818940}{Costley 2013}


\paragraph{The Adaptive F\sphinxhyphen{}Detector}
\label{\detokenize{detection:the-adaptive-f-detector}}\label{\detokenize{detection:afd}}\label{\detokenize{detection::doc}}
The standard F\sphinxhyphen{}detector is based on decision rules for the F\sphinxhyphen{}statistic, which provides an estimate of the signal’s beam power and is calculated as the power in the beam divided by the average over all channels of the power difference between the beam and the individual channels cite\{Blandford:1982\}.  The AFD accounts for both correlated and uncorrelated noise through an increase in the value of the F\sphinxhyphen{}statistic required to declare a detection based upon background F\sphinxhyphen{}values being elevated from coherent or persistent noise sources. The figure below illustrates how the AFD remaps the F\sphinxhyphen{}statistic through the application of a C\sphinxhyphen{}value, which effective reduces the detection threshold (p\sphinxhyphen{}value) and decreases the number of noise\sphinxhyphen{}related detections.

\noindent\sphinxincludegraphics{{AFD}.png}

See the following for more references on the Adaptive F\sphinxhyphen{}Detector:

\sphinxhref{https://doi.org/10.1111/j.1365-246X.2008.03912.x}{Arrowmsith et al., 2008}
\sphinxhref{https://pubs.geoscienceworld.org/ssa/bssa/article/99/1/449/342096}{Arrowsmith et al., 2009}


\paragraph{Association}
\label{\detokenize{association:association}}\label{\detokenize{association:id1}}\label{\detokenize{association::doc}}\begin{itemize}
\item {} 
Events are identified using a pair\sphinxhyphen{}based Bayesian algorithm that defines the association between detection pairs from their joint\sphinxhyphen{}likelihood and identifies events via hierarchical clustering analysis

\item {} 
Current implementation utilizes only spatial and temporal coincidence, but additional detection information can further improve event identification

\item {} 
Evaluation using a synthetic data set shows some mixing of spatially similar events poorly resolved by network geometry and occasional inclusion of “noise” detections in event clustering

\end{itemize}

See the following for more references on Association:
\sphinxhref{https://academic.oup.com/gji/advance-article-abstract/doi/10.1093/gji/ggaa105/5800992}{Blom et al., 2020}


\paragraph{Bayesian Infrasonic Source Localization}
\label{\detokenize{localization:bayesian-infrasonic-source-localization}}\label{\detokenize{localization:localization}}\label{\detokenize{localization::doc}}\begin{itemize}
\item {} 
Event analysis uses the Bayesian Infrasonic Source Localization (BISL) methodology to estimate both the spatial location of the event as well as the origin time with quantified uncertainty

\item {} 
Preliminary analysis of the back projections can be used to define the spatial region of interest or it can be specified by the analysis

\item {} 
Analysis identifies the maximum posteriori solution

\item {} 
The marginalized spatial distribution is approximated as 2d\sphinxhyphen{}normal to define 95 and 99\% confidence ellipse bounds

\item {} 
The marginalized temporal distribution is analyzed to identify the exact 95 and 99\% confidence bounds

\item {} 
Likelihood definitions relating detection parameters to spatial and temporal source characteristics are shared between association and localization analysis for consistency

\end{itemize}

See the following for more references on BISL:
\sphinxhref{https://academic.oup.com/gji/article/181/1/399/718964}{Modrak et al., 2010}
\sphinxhref{https://academic.oup.com/gji/article/196/1/375/586767}{Marcillo et al., 2013}
\sphinxhref{https://academic.oup.com/gji/article/203/3/1682/2594791}{Blom et al., 2015}
\end{quote}

\end{itemize}


\section{Data Processing Flow}
\label{\detokenize{processing_model:data-processing-flow}}\label{\detokenize{processing_model:dataprocess}}\label{\detokenize{processing_model::doc}}
Data can be processed using InfraPy in a variety of ways.  See the images below for examples of data processing workflows.


\subsection{The Adaptive F\sphinxhyphen{}Detector}
\label{\detokenize{processing_model:afd}}
\noindent\sphinxincludegraphics{{detection_data_flow}.png}


\subsection{Association}
\label{\detokenize{processing_model:association}}
\noindent\sphinxincludegraphics{{association_data_flow}.png}


\subsection{Bayesian Infrasonic Source Localization}
\label{\detokenize{processing_model:localization}}
\noindent\sphinxincludegraphics{{localization_data_flow}.png}


\subsubsection{Stand\sphinxhyphen{}Alone Processing}
\label{\detokenize{standalone:stand-alone-processing}}\label{\detokenize{standalone:standalone}}\label{\detokenize{standalone::doc}}
Modules within Infrapy can be run ‘stand\sphinxhyphen{}alone’ as package imports following the scripts found in the /examples folder


\subsubsection{Running Pipeline Processing in Infrapy}
\label{\detokenize{pipeline:running-pipeline-processing-in-infrapy}}\label{\detokenize{pipeline:pipeline}}\label{\detokenize{pipeline::doc}}
The folder tutorials/cli contains all necessary data and configuration files to begin utilizing the pipeline processing methodologies in Infrapy.

Once installed, the steps to run pipeline processing in Infrapy are:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Either load local waveform data into a sqlite database or connect to a Oracle database following instructions in {\hyperref[\detokenize{pisces:pisces}]{\sphinxcrossref{\DUrole{std,std-ref}{Interfacing with Pisces}}}}.

\item {} 
Create a configuration file. See {\hyperref[\detokenize{config:config}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration Files}}}} for a detailed description of the parameters that need to be included. Two example configuration files, one for connecting to the provided sqlite file and one for connecting to an oracle database are provided.

\item {} 
Run the FK analysis for a specific array:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{infrapy} \PYG{n}{run\PYGZus{}fk} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{config\PYGZus{}file} \PYG{n}{BRPConfig}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Run the FD analysis for a specific array that has already FK results, remember to locate the parameter id from your FK analysis (you can use the script read\_pfk.py to find the correct id).

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{infrapy} \PYG{n}{run\PYGZus{}fd} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{config\PYGZus{}file} \PYG{n}{BRPConfig}\PYG{o}{.}\PYG{n}{txt}

\PYG{l+m+mf}{4.} \PYG{n}{Once} \PYG{n}{you} \PYG{n}{have} \PYG{n}{run} \PYG{n}{detection} \PYG{n}{on} \PYG{l+m+mi}{2}\PYG{o}{+} \PYG{n}{array}\PYG{p}{,} \PYG{n}{run} \PYG{n}{association} \PYG{n}{processing}\PYG{p}{:}

\PYG{o}{.}\PYG{o}{.} \PYG{n}{code}\PYG{o}{\PYGZhy{}}\PYG{n}{block}\PYG{p}{:}\PYG{p}{:} \PYG{n}{python}

    \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{infrapy} \PYG{n}{run\PYGZus{}assoc} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{config\PYGZus{}file} \PYG{n}{BRPConfig}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}


\paragraph{Configuration Files}
\label{\detokenize{config:configuration-files}}\label{\detokenize{config:config}}\label{\detokenize{config::doc}}
We run the different steps of the processing by running a script along with a configuration file. This applies to both station and network analysis levels. Configuration files set the parameters that are required to perform a specific analysis. The configuration file for the array processing (station level analysis) has the following structure:

An example configuration file is provided in tutorials/.  Parameters for each field within the configuration file are outlined below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{} configuration file to run array (FK) processing and (FD) detection

[database] \PYGZsh{} required
url = sqlite:///example.sqlite
\PYGZsh{} database for processing
site = pisces.tables.css3:Site
wfdisc = pisces.tables.css3:Wfdisc
affiliation = pisces.tables.css3:Affiliation
\PYGZsh{} schemas for tables utilized in processing
\PYGZsh{} if processing in sqlite database, tables remain the same
\PYGZsh{} if processing in Oracle database, tables should point to your custom global\PYGZus{}.py file

[GeneralParams]
year=2012
\PYGZsh{} year for processing
dayofyearini=100
\PYGZsh{} Julian Day to begin processing
dayofyearend=102
\PYGZsh{} Julian Day to stop processing
station=BRP
\PYGZsh{} REFSTA of station for processing
channel=EDF
\PYGZsh{} channel
name=example
\PYGZsh{} name of processing parameters
cpucnt=30
\PYGZsh{} number of cpu cores to use for processing
domain=time
\PYGZsh{} domain (time or frequency) to run FK and FD processing


[FKParams]
name=mid band fk test
\PYGZsh{} name for fk processing
freqmin=0.5
\PYGZsh{} minimum frequency
freqmax=5.0
\PYGZsh{} maximum frequency
beamwinlen=60
\PYGZsh{} beam window length
beamwinstep=30
\PYGZsh{} beam window step
backazmin=\PYGZhy{}180.0
\PYGZsh{} minimum bz for processing
backazmax=180.0
\PYGZsh{} maximum bz for processing
backazstep=1.5
\PYGZsh{} bz step
trvelmin=300.0
\PYGZsh{} minimum trace velocity
trvelmax=600.0
\PYGZsh{} maximum trace velocity
trvelstep=2.5
\PYGZsh{} trace velocity step
beammethod=bartlett
\PYGZsh{} beam method
fkresults=fk\PYGZus{}res\PYGZus{}brp
\PYGZsh{} where fk processing results are stored
numsources = 1
func\PYGZus{}fk = None

[FDetectParams]
back\PYGZus{}az\PYGZus{}lim=10
\PYGZsh{} limit of bz deviation between consecutive fk results
detwinlen=300.0
\PYGZsh{} window length for adaptive f detection
detthresh=0.99
\PYGZsh{} detection threshold
dsegmin=5
detmethod=fstat
tb\PYGZus{}prod=4000
adaptivewlen=1200
\PYGZsh{}length of window for AFD
pthreshold=.01
\PYGZsh{}p\PYGZhy{}value for time domain detection
pfkid=0
\PYGZsh{} pkfid for FK results
corrthreshold=0.5
\PYGZsh{} threshold for correlation values
mineventlength
\PYGZsh{} minimum event length in seconds
fkresults=fk\PYGZus{}res\PYGZus{}brp
\PYGZsh{} fk results to run detection on
fdresults=fd\PYGZus{}res\PYGZus{}example\PYGZus{}brp
\PYGZsh{} where detection results are saved



[AssocLocParams]
network=YJ
\PYGZsh{} network for association
pfdetectid=0
\PYGZsh{} detection ID from detection processing (all arrays for assoc must have same detect ID)
pfkid=2
\PYGZsh{} beamforming ID (all arrays must have same FK ID)
beamwidth=10.0
rangemax=1000.0
clusterthresh=4.0
trimthresh=None
eventdetmin=3
\PYGZsh{} minimum \PYGZsh{} of detections to form event
eventarrmin=2
\PYGZsh{} minimum number of arrays for event
duration = 60
\PYGZsh{} duration (minutes) for association windows

fdtable\PYGZus{}1=fd\PYGZus{}res\PYGZus{}example\PYGZus{}brp
\PYGZsh{}fdtable\PYGZus{}2=fd\PYGZus{}res\PYGZus{}fsu
\PYGZsh{}fdtable\PYGZus{}3=fd\PYGZus{}res\PYGZus{}wmu
\PYGZsh{} tables where detection results are stored
resultstable = test\PYGZus{}assoc
\PYGZsh{} table where association results will be stored
\end{sphinxVerbatim}


\paragraph{Infrapy FK Processing}
\label{\detokenize{fk:infrapy-fk-processing}}\label{\detokenize{fk:fk}}\label{\detokenize{fk::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{infrapy} \PYG{n}{run\PYGZus{}fk} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{config\PYGZus{}file} \PYG{n}{BRPConfig}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}


\paragraph{Infrapy Detection (FD) Processing}
\label{\detokenize{fd:infrapy-detection-fd-processing}}\label{\detokenize{fd:fd}}\label{\detokenize{fd::doc}}
Infrapy detects signals using an Adaptive F\sphinxhyphen{}Detector (AFD). The adaptive F\sphinxhyphen{}detector was developed by Arrowsmith et al., (2009) to account for both correlated and uncorrelated noise through modification of the conventional F\sphinxhyphen{}statistic. The detector accounts for temporal changes in noise by applying an adaptive window to update the detection distribution, which allows for the distinction between signal and correlated noise.

\noindent\sphinxincludegraphics{{AFD}.png}


\subparagraph{Configuration file}
\label{\detokenize{fd:configuration-file}}
Detection is run using the same configuration file as FK processing.  Detection requires input from FK processing results

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{infrapy} \PYG{n}{run\PYGZus{}fd} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{config\PYGZus{}file} \PYG{n}{BRPConfig}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}


\paragraph{Infrapy Assoc Processing}
\label{\detokenize{assoc:infrapy-assoc-processing}}\label{\detokenize{assoc:assoc}}\label{\detokenize{assoc::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{infrapy} \PYG{n}{run\PYGZus{}assoc} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{config\PYGZus{}file} \PYG{n}{BRPConfig}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}


\paragraph{Scripts}
\label{\detokenize{scripts:scripts}}\label{\detokenize{scripts:id1}}\label{\detokenize{scripts::doc}}

\subparagraph{Scripts to manipulate Infrapy FK results}
\label{\detokenize{scripts:scripts-to-manipulate-infrapy-fk-results}}
Use “any\_command”.py \sphinxhyphen{}h to get specific information to run the script
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
read\_pfk.py to see the different set of configuration parameters used previously for FK analysis

\end{enumerate}

\begin{DUlineblock}{0em}
\item[] \sphinxhyphen{}h    \textendash{}help     show this help message and exit
\item[] \sphinxhyphen{}d    SQ      name of the database connection, e.g.: \sphinxhyphen{}d sqlite:///UT\_tutorial.sqlite
\end{DUlineblock}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{read\PYGZus{}pfk}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{SQ}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
print\_rfk.py to see fk results for a specific array and FK parameter ID

\end{enumerate}

\begin{DUlineblock}{0em}
\item[] \sphinxhyphen{}h \textendash{}help     show this help message and exit
\item[] \sphinxhyphen{}d SQ         name of the database connection, e.g.: \sphinxhyphen{}d sqlite:///UT\_tutorial.sqlite
\item[] \sphinxhyphen{}a ARRAY      array name, e.g.: \sphinxhyphen{}HWU4
\item[] \sphinxhyphen{}t FKRESULTS  specific table with results, e.g.: \sphinxhyphen{}t fk\_HWU
\item[] \sphinxhyphen{}s TS        starttime plot, e.g.: \sphinxhyphen{}s /’2014\sphinxhyphen{}03\sphinxhyphen{}02T00:00:00/’
\item[] \sphinxhyphen{}e TE        endtime plot, e.g.: \sphinxhyphen{}s /’2014\sphinxhyphen{}03\sphinxhyphen{}03T00:00:00/’
\item[] \sphinxhyphen{}F FVAL      limit Fvalue, e.g.: \sphinxhyphen{}F 0
\item[] \sphinxhyphen{}o OUTTEXT    print fk data, e.g.: \sphinxhyphen{}o res\_FILE
\end{DUlineblock}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{print\PYGZus{}rfk}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{SQ} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{ARRAY} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{PFK\PYGZus{}ID} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{n}{FKRESULTS} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{TS}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{TE}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{F} \PYG{n}{FVAL}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{res\PYGZus{}FILE}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
plot1\_rfk.py to plot FK results

\end{enumerate}

\begin{DUlineblock}{0em}
\item[] \sphinxhyphen{}h \textendash{}help    show this help message and exit
\item[] \sphinxhyphen{}d SQ        name of the database connection, e.g.: \sphinxhyphen{}d sqlite:///UT\_tutorial.sqlite
\item[] \sphinxhyphen{}a ARRAY     array name, e.g.: \sphinxhyphen{}a HWU4
\item[] \sphinxhyphen{}f PFK\_ID    FK parameter ID to be plot, e.g.: \sphinxhyphen{}f 3
\item[] \sphinxhyphen{}t FKRESULTS specific table with results, e.g.: \sphinxhyphen{}t fk\_res\_HWU
\item[] \sphinxhyphen{}w WAVEPLOT  plot waveforms, e.g.: \sphinxhyphen{}w 0
\item[] \sphinxhyphen{}s TS        starttime plot, e.g.: \sphinxhyphen{}s /’2014\sphinxhyphen{}03\sphinxhyphen{}02T00:00:00/’
\item[] \sphinxhyphen{}e TE        endtime plot, e.g.: \sphinxhyphen{}s /’2014\sphinxhyphen{}03\sphinxhyphen{}03T00:00:00/’
\item[] \sphinxhyphen{}F FVAL      limit Fvalue, e.g.: \sphinxhyphen{}F 0
\item[] \sphinxhyphen{}slo SLOFK   limit slofk, e.g.: \sphinxhyphen{}slo 0
\item[] \sphinxhyphen{}bzmin BZMIN limit min bz, e.g.: \sphinxhyphen{}bzmin 0
\item[] \sphinxhyphen{}bzmax BZMAX limit max bz, e.g.: \sphinxhyphen{}bzmax 360
\end{DUlineblock}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{n}{plot1\PYGZus{}rfk}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{SQ} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{ARRAY} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{PFK\PYGZus{}ID} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{n}{FKRESULTS}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{w} \PYG{n}{WAVEPLOT}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{TS}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{n}{TE}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{F} \PYG{n}{FVAL}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{slo} \PYG{n}{SLOFK}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{bzmin} \PYG{n}{BZMIN}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{bzmax} \PYG{n}{BZMAX}\PYG{p}{]}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{FKres_Fval}.png}

\noindent\sphinxincludegraphics{{FKres_trcvel}.png}

\noindent\sphinxincludegraphics{{FKres_bz}.png}


\subparagraph{Scripts to manipulate Infrapy FD results}
\label{\detokenize{scripts:scripts-to-manipulate-infrapy-fd-results}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
read\_pfd.py to see the different set of configuration parameters used previously for detection analysis

\end{enumerate}

\begin{DUlineblock}{0em}
\item[] \sphinxhyphen{}h, \textendash{}help  show this help message and exit
\item[] \sphinxhyphen{}d SQ       name of the database connection, e.g.: \sphinxhyphen{}d sqlite:///mydb.sqlite
\end{DUlineblock}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{read\PYGZus{}pfd}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{SQ}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
read\_rfd.py to see the available detection results

\end{enumerate}

\begin{DUlineblock}{0em}
\item[] \sphinxhyphen{}h, \textendash{}help            show this help message and exit
\item[] \sphinxhyphen{}d SQ                 name of the database connection, e.g.: \sphinxhyphen{}db sqlite:///UT\_tutorial.sqlite
\item[] \sphinxhyphen{}a ARRAY              array name, e.g.: \sphinxhyphen{}a HWU4
\item[] \sphinxhyphen{}f PFK\_ID, \textendash{}pfkid PFK\_ID FK parameter ID to be plot, e.g.: \sphinxhyphen{}f 0
\item[] \sphinxhyphen{}j PFDID, \textendash{}pfdid PFDID fd parameter id, e.g.: \sphinxhyphen{}j 0
\item[] \sphinxhyphen{}t FDRESULTS          specific table with results, e.g.: \sphinxhyphen{}t fd\_res\_HWU
\end{DUlineblock}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{read\PYGZus{}rfd}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{SQ} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{ARRAY} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{PFK\PYGZus{}ID} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{n}{PFDID} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{n}{FDRESULTS}\PYG{p}{]}
\PYG{n}{fdid}\PYG{p}{:} \PYG{l+m+mi}{1}  \PYG{n}{pfdid}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{n}{pfkid}\PYG{p}{:} \PYG{l+m+mi}{0}   \PYG{n}{timeini}\PYG{p}{:} \PYG{l+m+mi}{12}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{14} \PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mi}{24}\PYG{p}{:}\PYG{l+m+mi}{30}   \PYG{n}{timeend}\PYG{p}{:} \PYG{l+m+mi}{12}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{14} \PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mi}{26}\PYG{p}{:}\PYG{l+m+mi}{00}   \PYG{n}{maxf0}\PYG{p}{:} \PYG{l+m+mf}{5.54282460217} \PYG{l+m+mf}{0.60800443287}
\PYG{n}{fdid}\PYG{p}{:} \PYG{l+m+mi}{2}  \PYG{n}{pfdid}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{n}{pfkid}\PYG{p}{:} \PYG{l+m+mi}{0}   \PYG{n}{timeini}\PYG{p}{:} \PYG{l+m+mi}{12}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{14} \PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mi}{47}\PYG{p}{:}\PYG{l+m+mi}{00}   \PYG{n}{timeend}\PYG{p}{:} \PYG{l+m+mi}{12}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{14} \PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mi}{53}\PYG{p}{:}\PYG{l+m+mi}{30}   \PYG{n}{maxf0}\PYG{p}{:} \PYG{l+m+mf}{3.67253815208} \PYG{l+m+mf}{0.46716764663}
\PYG{n}{fdid}\PYG{p}{:} \PYG{l+m+mi}{3}  \PYG{n}{pfdid}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{n}{pfkid}\PYG{p}{:} \PYG{l+m+mi}{0}   \PYG{n}{timeini}\PYG{p}{:} \PYG{l+m+mi}{12}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{14} \PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mi}{54}\PYG{p}{:}\PYG{l+m+mi}{30}   \PYG{n}{timeend}\PYG{p}{:} \PYG{l+m+mi}{12}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{14} \PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mi}{56}\PYG{p}{:}\PYG{l+m+mi}{30}   \PYG{n}{maxf0}\PYG{p}{:} \PYG{l+m+mf}{2.61098286001} \PYG{l+m+mf}{0.372113714177}
\PYG{n}{fdid}\PYG{p}{:} \PYG{l+m+mi}{4}  \PYG{n}{pfdid}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{n}{pfkid}\PYG{p}{:} \PYG{l+m+mi}{0}   \PYG{n}{timeini}\PYG{p}{:} \PYG{l+m+mi}{12}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{14} \PYG{l+m+mi}{01}\PYG{p}{:}\PYG{l+m+mi}{47}\PYG{p}{:}\PYG{l+m+mi}{30}   \PYG{n}{timeend}\PYG{p}{:} \PYG{l+m+mi}{12}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{14} \PYG{l+m+mi}{01}\PYG{p}{:}\PYG{l+m+mi}{49}\PYG{p}{:}\PYG{l+m+mi}{00}   \PYG{n}{maxf0}\PYG{p}{:} \PYG{l+m+mf}{9.91099311406} \PYG{l+m+mf}{0.749628285504}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
read\_rfd\_fast.py to write the available detection results in text file

\end{enumerate}

\begin{DUlineblock}{0em}
\item[] \sphinxhyphen{}h, \textendash{}help            show this help message and exit
\item[] \sphinxhyphen{}d SQ                 name of the database connection, e.g.: \sphinxhyphen{}d sqlite:///UT\_tutorial.sqlite
\item[] \sphinxhyphen{}a ARRAY              array name, e.g.: \sphinxhyphen{}a I37NO
\item[] \sphinxhyphen{}f PFKID, \textendash{}pfkid PFKID fk parameter id, e.g.: \sphinxhyphen{}f 0
\item[] \sphinxhyphen{}j PFDID, \textendash{}pfdid PFDID fd parameter id, e.g.: \sphinxhyphen{}j 0
\item[] \sphinxhyphen{}t FDRESULTS          specific table with results, e.g.: \sphinxhyphen{}t fd\_I37
\item[] \sphinxhyphen{}o OUTTEXT            fd parameter id, e.g.: \sphinxhyphen{}o res\_FILE
\end{DUlineblock}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{read\PYGZus{}rfd\PYGZus{}fast}\PYG{o}{.}\PYG{n}{py} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{SQ} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{n}{ARRAY} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{n}{PFKID} \PYG{o}{\PYGZhy{}}\PYG{n}{j} \PYG{n}{PFDID} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{n}{FDRESULTS}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{OUTTEXT}\PYG{p}{]}
\end{sphinxVerbatim}


\section{Tutorial}
\label{\detokenize{tutorial:tutorial}}\label{\detokenize{tutorial:id1}}\label{\detokenize{tutorial::doc}}
A series of jupyter notebooks illustrating how to use infrapy subroutines are found in the /tutorial folder.
You can run these by navigating to that folder and running:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYGZgt{} jupyter notebook
\end{sphinxVerbatim}

A browser will launch with a webpage showing a directory listing, click on the InfraPyTutorial.ipynb link to open the main window, which will provide links to the various tutorials.


\section{Schema}
\label{\detokenize{schema:schema}}\label{\detokenize{schema:id1}}\label{\detokenize{schema::doc}}
The purpose of this document is to define the schema used for the
operation of the infrasound analysis tool, infrapy. The tables described
by this document extend the CSS3.0 or KB core schema to include
information required for the operation of infrapy. This document is
divided into three sections, the first being this introduction. Section
two defines eight new, infrasonic data processing\sphinxhyphen{}specific database
tables. Both internal (ORACLE) and external formats for the attributes
are defined, along with a short description of each attribute. Section
three of the document shows the relationships between the different
tables by using entity\sphinxhyphen{}relationship diagrams.

This schema is a work in progress and may be updated as development of
infrapy continues.


\subsection{Table Descriptions}
\label{\detokenize{schema:table-descriptions}}
This section describes the logical structure of each table used in the
Infrapy software package. The name of the table is first, followed by a
description of the purpose and use of the table. Below the description
is a listing of the columns, in the order which they are defined in the
tables. The storage column gives the actual ORACLE datatype for the
column in question. The external format and character positions columns
are provided for the convenience of database users who wish to transfer
data between the ORACLE database tables and flat files.


\subsubsection{Conventions}
\label{\detokenize{schema:conventions}}
The following conventions are used, following Carr et al (2002):


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxstylestrong{Element}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Appearance}
&\sphinxstyletheadfamily 
\sphinxstylestrong{Example}
\\
\hline
Database table
&
Bold
&
\sphinxstylestrong{arrival}
\\
\hline
Database columns
&
Italic
&
\sphinxstyleemphasis{sta}
\\
\hline
Database table and
column when written
in the dot notation
&
Bold.italic
&
\sphinxstylestrong{arrival}\sphinxstyleemphasis{.sta}
\\
\hline
Value of a key or
component of a key
&
Courier font
&
arid
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Table Definitions: Infrapy\sphinxhyphen{}Specific Tables}
\label{\detokenize{schema:table-definitions-infrapy-specific-tables}}
Table descriptions can be found in the API section of the documentation.


\section{API}
\label{\detokenize{infrapy:api}}\label{\detokenize{infrapy:id1}}\label{\detokenize{infrapy::doc}}

\subsection{Association}
\label{\detokenize{infrapy.association:module-infrapy.association}}\label{\detokenize{infrapy.association:association}}\label{\detokenize{infrapy.association::doc}}\index{infrapy.association (module)@\spxentry{infrapy.association}\spxextra{module}}

\subsubsection{HJL}
\label{\detokenize{infrapy.association:module-infrapy.association.hjl}}\label{\detokenize{infrapy.association:hjl}}\index{infrapy.association.hjl (module)@\spxentry{infrapy.association.hjl}\spxextra{module}}\index{build\_distance\_matrix() (in module infrapy.association.hjl)@\spxentry{build\_distance\_matrix()}\spxextra{in module infrapy.association.hjl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.association:infrapy.association.hjl.build_distance_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.association.hjl.}}\sphinxbfcode{\sphinxupquote{build\_distance\_matrix}}}{\emph{det\_list}, \emph{bm\_width=10.0}, \emph{rng\_max=10005.97260168349}, \emph{rad\_min=100.0}, \emph{rad\_max=1000.0}, \emph{resol=180}, \emph{pool=None}, \emph{progress=False}}{}
Computes the joint\sphinxhyphen{}likelihood for all pairs of detections to define the distance matrix

Computes the joint\sphinxhyphen{}likelihood value for each unique pair of detections in a provided list and
uses a negative\sphinxhyphen{}log\sphinxhyphen{}joint\sphinxhyphen{}likelihood to convert to non\sphinxhyphen{}Euclidean distance for clustering analysis
\begin{description}
\item[{det\_list}] \leavevmode{[}\sphinxcode{\sphinxupquote{list}} of \sphinxcode{\sphinxupquote{InfrasoundDetection}}{]}
List of detections (see infrapy.propagation.likelihoods)

\item[{bm\_width}] \leavevmode{[}float{]}
Width of the projected beam {[}degrees{]}

\item[{rng\_max}] \leavevmode{[}float{]}
Maximmum range for beam projection {[}km{]}

\item[{rad\_min}] \leavevmode{[}float{]}
Minimum radius of the integration region {[}km{]}

\item[{rad\_max}] \leavevmode{[}float{]}
Maximum radius of the integration region {[}km{]}

\item[{resol}] \leavevmode{[}int{]}
Number of radial and azimuthal points used in the polar projection of the likelihood PDFs

\item[{pool}] \leavevmode{[}pathos.multiprocessing.ProcessingPool{]}
Multiprocessing pool for accelerating calculations

\end{description}

Returns:
dist\_matrix : 2darray
\begin{quote}

Distance matrix describing joint\sphinxhyphen{}likelihood separations for all pairs
\end{quote}

\end{fulllineitems}

\index{cluster() (in module infrapy.association.hjl)@\spxentry{cluster()}\spxextra{in module infrapy.association.hjl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.association:infrapy.association.hjl.cluster}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.association.hjl.}}\sphinxbfcode{\sphinxupquote{cluster}}}{\emph{distance\_matrix}, \emph{threshold}, \emph{linkage\_method=\textquotesingle{}weighted\textquotesingle{}}, \emph{show\_result=False}, \emph{file\_id=None}, \emph{den\_label\_size=9}, \emph{mat\_label\_size=7}, \emph{trim\_indices={[}{]}}}{}
Computes the clustering solution for a distance matrix and threshold

Computes the linkages for a distance matrix using SciPy’s hierarchical (agglomerative) clustering
methods and returns the event labels for the original detection list
\begin{description}
\item[{distance\_matrix}] \leavevmode{[}2darray{]}
Two dimensional numpy array representing distance matrix

\item[{threshold}] \leavevmode{[}float{]}
Threshold value defining linkage cutoff

\item[{linkage\_method}] \leavevmode{[}str{]}
Linkage method used by scipy.cluster.hierarchy.linkage

\item[{show\_results}] \leavevmode{[}boolean{]}
Boolean to plot dendrogram and sorted distance matrix to screeen

\item[{file\_id}] \leavevmode{[}str{]}
Prefix for output file is dendrogram and sorted distance matrix figure is saved

\item[{den\_label\_size}] \leavevmode{[}float{]}
Font size off the dendrogram labels in the figure

\item[{mat\_label\_size}] \leavevmode{[}float{]}
Font size of the distance matrix label in the figure

\item[{trim\_indices}] \leavevmode{[}\sphinxcode{\sphinxupquote{list}} of \sphinxcode{\sphinxupquote{int}} pairs{]}
Locations of linkages cut by trimming algorithm (only used in figure)

\end{description}

Returns:
links : scipy.cluster.hierarchy.linkage
\begin{quote}

Output links from SciPy clustering analysis
\end{quote}
\begin{description}
\item[{labels}] \leavevmode{[}\sphinxcode{\sphinxupquote{list}} of \sphinxcode{\sphinxupquote{int}}{]}
Labels of cluster memberships for each detection

\item[{distance\_matrix\_sorted}] \leavevmode{[}2darray{]}
The distance matrix sorted to put clusters together

\end{description}

\end{fulllineitems}

\index{compute\_assoc\_pair() (in module infrapy.association.hjl)@\spxentry{compute\_assoc\_pair()}\spxextra{in module infrapy.association.hjl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.association:infrapy.association.hjl.compute_assoc_pair}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.association.hjl.}}\sphinxbfcode{\sphinxupquote{compute\_assoc\_pair}}}{\emph{det1}, \emph{det2}, \emph{bm\_width=10.0}, \emph{rng\_max=10005.97260168349}, \emph{rad\_min=100.0}, \emph{rad\_max=1000.0}, \emph{resol=180}, \emph{prog\_step=0}}{}
Computes the joint\sphinxhyphen{}likelihiood for a pair of detections

Projects finite width beams from each of the detecting arrays and looks for intersections
of the primary (center) and secondary (edge) lines to define the integration region
for computation of the joint\sphinxhyphen{}likelihiood between the detection pair
\begin{description}
\item[{det1}] \leavevmode{[}InfrasoundDetection{]}
First detection (see infrapy.propagation.likelihoods)

\item[{det2}] \leavevmode{[}InfrasoundDetection{]}
Second detection (see infrapy.propagation.likelihoods)

\item[{bm\_width}] \leavevmode{[}float{]}
Width of the projected beam {[}degrees{]}

\item[{rng\_max}] \leavevmode{[}float{]}
Maximmum range for beam projection {[}km{]}

\item[{rad\_min}] \leavevmode{[}float{]}
Minimum radius of the integration region {[}km{]}

\item[{rad\_max}] \leavevmode{[}float{]}
Maximum radius of the integration region {[}km{]}

\item[{resol}] \leavevmode{[}int{]}
Number of radial and azimuthal points used in the polar projection of the likelihood PDFs

\item[{prog\_step}] \leavevmode{[}int{]}
Used to increment progress bar

\end{description}

Returns:
jntlklhd : float
\begin{quote}

The joint\sphinxhyphen{}likelihood value for the pair of detections
\end{quote}

\end{fulllineitems}

\index{compute\_assoc\_pair\_wrapper() (in module infrapy.association.hjl)@\spxentry{compute\_assoc\_pair\_wrapper()}\spxextra{in module infrapy.association.hjl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.association:infrapy.association.hjl.compute_assoc_pair_wrapper}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.association.hjl.}}\sphinxbfcode{\sphinxupquote{compute\_assoc\_pair\_wrapper}}}{\emph{args}}{}
\end{fulllineitems}

\index{run() (in module infrapy.association.hjl)@\spxentry{run()}\spxextra{in module infrapy.association.hjl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.association:infrapy.association.hjl.run}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.association.hjl.}}\sphinxbfcode{\sphinxupquote{run}}}{\emph{det\_list}, \emph{threshold}, \emph{dist\_max=10.0}, \emph{bm\_width=10.0}, \emph{rng\_max=10005.97260168349}, \emph{rad\_min=100.0}, \emph{rad\_max=1000.0}, \emph{resol=180}, \emph{show\_result=None}, \emph{file\_id=None}, \emph{linkage\_method=\textquotesingle{}weighted\textquotesingle{}}, \emph{trimming\_thresh=None}, \emph{trim\_thresh\_scalar=1.0}, \emph{pool=None}}{}
Run the Hierarchical Joint\sphinxhyphen{}Likelihood (HJL) association analysis

Runs the clustering analysis on a list of detecctions and returns the
membership labels and sorted distance matrix for event identification
\begin{description}
\item[{det\_list}] \leavevmode{[}\sphinxcode{\sphinxupquote{list}} of \sphinxcode{\sphinxupquote{InfrasoundDetection}}{]}
List of detections (see infrapy.propagation.likelihoods)

\item[{threshold}] \leavevmode{[}float{]}
Threshold value defining linkage cutoff

\item[{bm\_width}] \leavevmode{[}float{]}
Width of the projected beam {[}degrees{]}

\item[{rng\_max}] \leavevmode{[}float{]}
Maximmum range for beam projection {[}km{]}

\item[{rad\_min}] \leavevmode{[}float{]}
Minimum radius of the integration region {[}km{]}

\item[{rad\_max}] \leavevmode{[}float{]}
Maximum radius of the integration region {[}km{]}

\item[{resol}] \leavevmode{[}int{]}
Number of radial and azimuthal points used in the polar projection of the likelihood PDFs

\item[{show\_results}] \leavevmode{[}boolean{]}
Boolean to plot dendrogram and sorted distance matrix to screeen

\item[{file\_id}] \leavevmode{[}str{]}
Prefix for output file is dendrogram and sorted distance matrix figure is saved

\item[{linkage\_method}] \leavevmode{[}str{]}
Linkage method used by scipy.cluster.hierarchy.linkage

\item[{trim\_thresh\_scalar}] \leavevmode{[}float{]}
Scalar modifying the threshold value for linkage cutoff in the trimmed result

\item[{pool}] \leavevmode{[}pathos.multiprocessing.ProcessingPool{]}
Multiprocessing pool for accelerating calculations

\end{description}

Returns:
labels : \sphinxcode{\sphinxupquote{list}} of \sphinxcode{\sphinxupquote{int}}
\begin{quote}

Labels of cluster memberships for each detection
\end{quote}
\begin{description}
\item[{distance\_matrix\_sorted}] \leavevmode{[}2darray{]}
The distance matrix sorted to put clusters together

\end{description}

\end{fulllineitems}

\index{set\_region() (in module infrapy.association.hjl)@\spxentry{set\_region()}\spxextra{in module infrapy.association.hjl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.association:infrapy.association.hjl.set_region}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.association.hjl.}}\sphinxbfcode{\sphinxupquote{set\_region}}}{\emph{det1}, \emph{det2}, \emph{bm\_width=10.0}, \emph{rng\_max=10005.97260168349}, \emph{rad\_min=100.0}, \emph{rad\_max=1000.0}}{}
Defines the integration region for computation of the joint\sphinxhyphen{}likelihood for a pair of detections

Projects finite width beams from each of the detecting arrays and looks for intersections
of the primary (center) and secondary (edge) lines to define the integration region
for computation of the joint\sphinxhyphen{}likelihiood between the detection pair
\begin{description}
\item[{det1}] \leavevmode{[}InfrasoundDetection{]}
First detection (see infrapy.propagation.likelihoods)

\item[{det2}] \leavevmode{[}InfrasoundDetection{]}
Second detection (see infrapy.propagation.likelihoods)

\item[{bm\_width}] \leavevmode{[}float{]}
Width of the projected beam {[}degrees{]}

\item[{rng\_max}] \leavevmode{[}float{]}
Maximmum range for beam projection {[}km{]}

\item[{rad\_min}] \leavevmode{[}float{]}
Minimum radius of the integration region {[}km{]}

\item[{rad\_max}] \leavevmode{[}float{]}
Maximum radius of the integration region {[}km{]}

\end{description}

Returns:
Successs : boolean
\begin{quote}

True if region was defined, False if not
\end{quote}
\begin{description}
\item[{Center}] \leavevmode{[}float{]}
Center of the integration region as latitude, longitude pair {[}degrees{]}

\item[{Radius}] \leavevmode{[}float{]}
Radius of the integration region {[}km{]}

\end{description}

\end{fulllineitems}

\index{summarize\_clusters() (in module infrapy.association.hjl)@\spxentry{summarize\_clusters()}\spxextra{in module infrapy.association.hjl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.association:infrapy.association.hjl.summarize_clusters}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.association.hjl.}}\sphinxbfcode{\sphinxupquote{summarize\_clusters}}}{\emph{labels}, \emph{distance\_matrix}, \emph{population\_min=3}, \emph{show\_result=False}}{}
Prints summary of cluster association solution to screen

Searches through labels to identify clusters with sufficient
membership to declare events and summarizes cluster quality
\begin{description}
\item[{labels}] \leavevmode{[}\sphinxcode{\sphinxupquote{list}} of \sphinxcode{\sphinxupquote{int}}{]}
Labels of cluster memberships for each detection

\item[{distance\_matrix}] \leavevmode{[}2darray{]}
Two dimensional numpy array representing distance matrix

\item[{population\_min}] \leavevmode{[}int{]}
Minimum number of detections in a cluster to declare an event

\end{description}

\end{fulllineitems}

\index{trim\_clusters() (in module infrapy.association.hjl)@\spxentry{trim\_clusters()}\spxextra{in module infrapy.association.hjl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.association:infrapy.association.hjl.trim_clusters}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.association.hjl.}}\sphinxbfcode{\sphinxupquote{trim\_clusters}}}{\emph{labels}, \emph{distance\_matrix}, \emph{population\_min=3}, \emph{ratio\_thresh=3.0}}{}
Trims linkages in poorly shaped clusters

Identifies poorly shaped clusters by the ratio of their mean inter\sphinxhyphen{}element
distances and radius (maximum inter\sphinxhyphen{}element distance) and returns indices
of the linkages that should be cut to improve clustering
\begin{description}
\item[{labels}] \leavevmode{[}\sphinxcode{\sphinxupquote{list}} of \sphinxcode{\sphinxupquote{int}}{]}
Labels of cluster memberships for each detection

\item[{distance\_matrix}] \leavevmode{[}2darray{]}
Two dimensional numpy array representing distance matrix

\item[{population\_min}] \leavevmode{[}int{]}
Minimum number of detections in a cluster to declare an event

\item[{ratio\_thresh}] \leavevmode{[}float{]}
Threshold for radius / mean inter\sphinxhyphen{}element distance to require trimming

\end{description}

Returns:
trim\_indices : \sphinxcode{\sphinxupquote{list}} of \sphinxcode{\sphinxupquote{int}}
\begin{quote}

Indices of linkages causing poor cluster shape
\end{quote}

\end{fulllineitems}

\index{view\_distance\_matrix() (in module infrapy.association.hjl)@\spxentry{view\_distance\_matrix()}\spxextra{in module infrapy.association.hjl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.association:infrapy.association.hjl.view_distance_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.association.hjl.}}\sphinxbfcode{\sphinxupquote{view\_distance\_matrix}}}{\emph{distance\_matrix}, \emph{file\_id=None}, \emph{ordering=None}}{}
View distance matrix used for clustering analysis
\begin{description}
\item[{dist\_matrix}] \leavevmode{[}2darray{]}
Distance matrix describing joint\sphinxhyphen{}likelihood separations for all pairs

\end{description}

\end{fulllineitems}



\subsection{Characterization}
\label{\detokenize{infrapy.characterization:characterization}}\label{\detokenize{infrapy.characterization::doc}}

\subsubsection{SPYE}
\label{\detokenize{infrapy.characterization:module-infrapy.characterization.spye}}\label{\detokenize{infrapy.characterization:spye}}\index{infrapy.characterization.spye (module)@\spxentry{infrapy.characterization.spye}\spxextra{module}}\index{blastwave() (in module infrapy.characterization.spye)@\spxentry{blastwave()}\spxextra{in module infrapy.characterization.spye}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.characterization:infrapy.characterization.spye.blastwave}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.characterization.spye.}}\sphinxbfcode{\sphinxupquote{blastwave}}}{\emph{t}, \emph{p0}, \emph{t0}, \emph{alpha=0.0}}{}~\begin{description}
\item[{Acoustic blastwave that can be used as a source}] \leavevmode
for surface explosions out to several scale
kilometers.

\item[{Note: alpha = 0 produces the Friedlander}] \leavevmode
blastwave model.

\end{description}
\begin{description}
\item[{t}] \leavevmode{[}float{]}
Time {[}s{]}

\item[{p0}] \leavevmode{[}float{]}
Peak overpressure

\item[{t0}] \leavevmode{[}float{]}
Time scale {[}s{]}

\item[{alpha}] \leavevmode{[}float{]}
Shaping parameter (positive)

\end{description}
\begin{description}
\item[{p}] \leavevmode{[}float{]}
Overpressure at time t

\end{description}

\end{fulllineitems}

\index{blastwave\_spectrum() (in module infrapy.characterization.spye)@\spxentry{blastwave\_spectrum()}\spxextra{in module infrapy.characterization.spye}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.characterization:infrapy.characterization.spye.blastwave_spectrum}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.characterization.spye.}}\sphinxbfcode{\sphinxupquote{blastwave\_spectrum}}}{\emph{f}, \emph{p0}, \emph{t0}, \emph{alpha=0.0}}{}~\begin{quote}
\begin{description}
\item[{Fourier transform amplitude for the acoustic}] \leavevmode
blastwave in sasm.acoustic.blastwave().

\end{description}

Note: alpha = 0 produces the Friedlander
blastwave model.

Note: the peak of the spectrum occurs at
f\_0 =
\end{quote}

rac\{1\}\{2 pi t\_0\} 
rac\{1\}\{sqrt\{lpha + 1\}
\begin{quote}

and t0 corresponding to a given peak frequency is
t\_0 =
\end{quote}

rac\{1\}\{2 pi f\_0\} 
rac\{1\}\{sqrt\{lpha + 1\}
\begin{quote}
\begin{description}
\item[{f}] \leavevmode{[}float{]}
Frequency {[}Hz{]}

\item[{p0}] \leavevmode{[}float{]}
Peak overpressure

\item[{t0}] \leavevmode{[}float{]}
Time scale {[}s{]}

\item[{alpha}] \leavevmode{[}float{]}
Shaping parameter (positive)

\end{description}
\begin{description}
\item[{P}] \leavevmode{[}float{]}
Spectral value at frequency f

\end{description}
\end{quote}

\end{fulllineitems}

\index{extract\_spectra() (in module infrapy.characterization.spye)@\spxentry{extract\_spectra()}\spxextra{in module infrapy.characterization.spye}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.characterization:infrapy.characterization.spye.extract_spectra}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.characterization.spye.}}\sphinxbfcode{\sphinxupquote{extract\_spectra}}}{\emph{det\_list}, \emph{st\_list}, \emph{win\_buffer=0.25}, \emph{ns\_opt=\textquotesingle{}pre\textquotesingle{}}}{}~\begin{description}
\item[{Extract spectra for a list of detections using a list of}] \leavevmode
obspy streams with a defined window buffer and noise
window option

\end{description}
\begin{description}
\item[{det\_list}] \leavevmode{[}\sphinxcode{\sphinxupquote{list}} of \sphinxcode{\sphinxupquote{InfrasoundDetection}}{]}
Iterable of detections with defined start and end times

\item[{st\_list}] \leavevmode{[}\sphinxcode{\sphinxupquote{list}} of \sphinxcode{\sphinxupquote{obspy.Stream}}{]}
Iterable of Obspy streams containing the array channels for each detection

\item[{win\_buffer}] \leavevmode{[}float{]}\begin{description}
\item[{Scaling factor defining the window buffer (a 20 second detection with a }] \leavevmode
buffer of 0.25 adds 5 seconds to the start and end of the window)

\end{description}

\item[{ns\_opt}] \leavevmode{[}string{]}\begin{description}
\item[{Option defining how the noise window is defined.  Options include “pre”,}] \leavevmode
“post”, and “beam” to use the preceding, following, or beam residual

\end{description}

\end{description}
\begin{description}
\item[{smn\_spec}] \leavevmode{[}ndarray{]}
Spectral amplitude of the signal\sphinxhyphen{}minus\sphinxhyphen{}noise

\end{description}

\end{fulllineitems}

\index{kg\_op() (in module infrapy.characterization.spye)@\spxentry{kg\_op()}\spxextra{in module infrapy.characterization.spye}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.characterization:infrapy.characterization.spye.kg_op}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.characterization.spye.}}\sphinxbfcode{\sphinxupquote{kg\_op}}}{\emph{W}, \emph{r}, \emph{p\_amb=101.325}, \emph{T\_amb=288.15}, \emph{type=\textquotesingle{}chemical\textquotesingle{}}}{}
Kinney \& Graham scaling law peak overpressure model
\begin{description}
\item[{W}] \leavevmode{[}float{]}
Explosive yield of the source {[}kg eq. TNT{]}

\item[{r}] \leavevmode{[}float{]}
Propagation distance {[}km{]}

\item[{p\_amb}] \leavevmode{[}float{]}
Ambient atmospheric pressure {[}kPa{]}

\item[{T\_amb}] \leavevmode{[}float{]}
Ambient atmospheric temperature {[}deg K{]}

\item[{type}] \leavevmode{[}string{]}
Type of explosion modeled, options are “chemical” or “nuclear”

\end{description}
\begin{description}
\item[{p0}] \leavevmode{[}float{]}
Peak overpressure {[}Pa{]}

\end{description}

\end{fulllineitems}

\index{kg\_ppd() (in module infrapy.characterization.spye)@\spxentry{kg\_ppd()}\spxextra{in module infrapy.characterization.spye}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.characterization:infrapy.characterization.spye.kg_ppd}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.characterization.spye.}}\sphinxbfcode{\sphinxupquote{kg\_ppd}}}{\emph{W}, \emph{r}, \emph{p\_amb=101.325}, \emph{T\_amb=288.15}, \emph{type=\textquotesingle{}chemical\textquotesingle{}}}{}
Kinney \& Graham scaling law positive phase duration model
\begin{description}
\item[{W}] \leavevmode{[}float{]}
Explosive yield of the source {[}kg eq. TNT{]}

\item[{r}] \leavevmode{[}float{]}
Propagation distance {[}km{]}

\item[{p\_amb}] \leavevmode{[}float{]}
Ambient atmospheric pressure {[}kPa{]}

\item[{T\_amb}] \leavevmode{[}float{]}
Ambient atmospheric temperature {[}deg K{]}

\item[{type}] \leavevmode{[}string{]}
Type of explosion modeled, options are “chemical” or “nuclear”

\end{description}
\begin{description}
\item[{t0}] \leavevmode{[}float{]}
Positive phase duration {[}s{]}

\end{description}

\end{fulllineitems}

\index{run() (in module infrapy.characterization.spye)@\spxentry{run()}\spxextra{in module infrapy.characterization.spye}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.characterization:infrapy.characterization.spye.run}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.characterization.spye.}}\sphinxbfcode{\sphinxupquote{run}}}{\emph{det\_list}, \emph{smn\_spec}, \emph{src\_loc}, \emph{freq\_band}, \emph{tloss\_models}, \emph{resol=150}, \emph{yld\_rng=array({[}    10.}, \emph{10000.{]})}, \emph{ref\_src\_rng=1.0}, \emph{grnd\_brst=True}}{}
Run Spectral Yield Estimation (SpYE) methods to estimate explosive yield
\begin{description}
\item[{det\_list}] \leavevmode{[}\sphinxcode{\sphinxupquote{list}} of \sphinxcode{\sphinxupquote{InfrasoundDetection}}{]}
Iterable of detections with defined start and end times

\item[{smn\_spec}] \leavevmode{[}ndarray{]}
Spectral amplitude of the signal\sphinxhyphen{}minus\sphinxhyphen{}noise

\item[{freq\_band}] \leavevmode{[}iterable{]}
List or tuple with minimum and maximum frequency (e.g.,  {[}f\_min, f\_max{]})

\item[{tloss\_models}] \leavevmode{[}list of frequencies and infrapy.propagation.TLossModel instances{]}\begin{description}
\item[{Propagation transmission loss model list with reference frequencies (see}] \leavevmode
test/test\_yield.py for construction example)

\end{description}

\item[{resol}] \leavevmode{[}int{]}
Resolution used in analysis

\item[{yld\_rng}] \leavevmode{[}iterable{]}
List or tuple with minimum and maximum yields (e.g., {[}yld\_min, yld\_max{]})

\item[{ref\_src\_rng}] \leavevmode{[}float{]}
Standoff distance used to define source model distance

\item[{grnd\_brst}] \leavevmode{[}boolean{]}\begin{description}
\item[{Boolean declaring whether the source is a ground burst (interaction with source}] \leavevmode
doubles the effective yield for a ground burst vs. air burst)

\end{description}

\end{description}
\begin{description}
\item[{yld\_vals: }] \leavevmode
Values of explosive yield for the PDF

\item[{yld\_pdf}] \leavevmode{[}{]}
Probability of the observed source having a given yield

\item[{conf\_bnds}] \leavevmode{[}ndarray{]}
Limits for the 68\% and 95\% confidence bounds on yield

\end{description}

\end{fulllineitems}



\subsection{Database Processing}
\label{\detokenize{infrapy.database:module-infrapy.database}}\label{\detokenize{infrapy.database:database-processing}}\label{\detokenize{infrapy.database::doc}}\index{infrapy.database (module)@\spxentry{infrapy.database}\spxextra{module}}

\subsubsection{Database Processing Taskbase}
\label{\detokenize{infrapy.database.taskbase:database-processing-taskbase}}\label{\detokenize{infrapy.database.taskbase::doc}}\phantomsection\label{\detokenize{infrapy.database.taskbase:module-infrapy.database.taskbase.fdet}}\index{infrapy.database.taskbase.fdet (module)@\spxentry{infrapy.database.taskbase.fdet}\spxextra{module}}
Updated Fall 2019
@fkdd @omarcillo
\index{FDet (class in infrapy.database.taskbase.fdet)@\spxentry{FDet}\spxextra{class in infrapy.database.taskbase.fdet}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.fdet.FDet}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{infrapy.database.taskbase.fdet.}}\sphinxbfcode{\sphinxupquote{FDet}}}{\emph{conf\_file={[}{]}}, \emph{ARRAY\_NAME=None}}{}
Bases: \sphinxcode{\sphinxupquote{infrapy.database.taskbase.base.Base}}

classdocs
\index{data\_processing() (infrapy.database.taskbase.fdet.FDet method)@\spxentry{data\_processing()}\spxextra{infrapy.database.taskbase.fdet.FDet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.fdet.FDet.data_processing}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{data\_processing}}}{}{}
Constructor

\end{fulllineitems}

\index{data\_retrieving() (infrapy.database.taskbase.fdet.FDet method)@\spxentry{data\_retrieving()}\spxextra{infrapy.database.taskbase.fdet.FDet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.fdet.FDet.data_retrieving}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{data\_retrieving}}}{\emph{dayofyear}}{}
\end{fulllineitems}

\index{database\_connecting() (infrapy.database.taskbase.fdet.FDet method)@\spxentry{database\_connecting()}\spxextra{infrapy.database.taskbase.fdet.FDet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.fdet.FDet.database_connecting}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{database\_connecting}}}{}{}
Constructor

\end{fulllineitems}

\index{distfit() (infrapy.database.taskbase.fdet.FDet method)@\spxentry{distfit()}\spxextra{infrapy.database.taskbase.fdet.FDet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.fdet.FDet.distfit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{distfit}}}{\emph{x}, \emph{F}, \emph{dofnum}, \emph{dofden}, \emph{c}}{}
Returns the correlation coefficient between the theoretical F\sphinxhyphen{}distribution and the
distribution of the input F\sphinxhyphen{}statistics, scaled by a c\sphinxhyphen{}value

Inputs:
\sphinxhyphen{} x is the set of F\sphinxhyphen{}statistics for binning
\sphinxhyphen{} F are the measured F\sphinxhyphen{}statistics
\sphinxhyphen{} dofnum is the number of degrees of freedom on the numerator
\sphinxhyphen{} dofden is the number of degrees of freedom on the denominator
\sphinxhyphen{} c is the c value

Outputs:
\sphinxhyphen{} corr is the correlation coefficient

\end{fulllineitems}

\index{event\_detection() (infrapy.database.taskbase.fdet.FDet method)@\spxentry{event\_detection()}\spxextra{infrapy.database.taskbase.fdet.FDet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.fdet.FDet.event_detection}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{event\_detection}}}{}{}
\end{fulllineitems}

\index{event\_detection2() (infrapy.database.taskbase.fdet.FDet method)@\spxentry{event\_detection2()}\spxextra{infrapy.database.taskbase.fdet.FDet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.fdet.FDet.event_detection2}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{event\_detection2}}}{}{}
\end{fulllineitems}

\index{getdet() (infrapy.database.taskbase.fdet.FDet method)@\spxentry{getdet()}\spxextra{infrapy.database.taskbase.fdet.FDet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.fdet.FDet.getdet}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getdet}}}{\emph{time}, \emph{fval\_corr}, \emph{pf}, \emph{p}, \emph{corr}, \emph{corr\_thres}, \emph{min\_no\_samples}, \emph{fval=None}, \emph{c=None}}{}
Obtains the start and end points for significant detections given a p\sphinxhyphen{}value.
Inputs:
\sphinxhyphen{} pf is the array of p\sphinxhyphen{}values as a function of time
\sphinxhyphen{} p is the threshold p\sphinxhyphen{}value
Outputs:
\sphinxhyphen{} start\_pt is the list of indices corresponding to the starts of detections
\sphinxhyphen{} stop\_pt is the list of indices corresponding to the ends of detections

\end{fulllineitems}


\end{fulllineitems}

\begin{quote}
\phantomsection\label{\detokenize{infrapy.database.taskbase:module-infrapy.database.taskbase.assoc}}\index{infrapy.database.taskbase.assoc (module)@\spxentry{infrapy.database.taskbase.assoc}\spxextra{module}}
Created on Oct 31, 2014
Updated Jan 2020

@author: omarcillo, fkdd
\index{AssocInfraPy\_LANL (class in infrapy.database.taskbase.assoc)@\spxentry{AssocInfraPy\_LANL}\spxextra{class in infrapy.database.taskbase.assoc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.assoc.AssocInfraPy_LANL}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{infrapy.database.taskbase.assoc.}}\sphinxbfcode{\sphinxupquote{AssocInfraPy\_LANL}}}{\emph{conf\_file={[}{]}}}{}
Bases: \sphinxcode{\sphinxupquote{infrapy.database.taskbase.base.Base}}

classdocs
\index{algorithm (infrapy.database.taskbase.assoc.AssocInfraPy\_LANL attribute)@\spxentry{algorithm}\spxextra{infrapy.database.taskbase.assoc.AssocInfraPy\_LANL attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.assoc.AssocInfraPy_LANL.algorithm}}\pysigline{\sphinxbfcode{\sphinxupquote{algorithm}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}Blom and Euler\textquotesingle{}}}}
\end{fulllineitems}

\index{data\_processing() (infrapy.database.taskbase.assoc.AssocInfraPy\_LANL method)@\spxentry{data\_processing()}\spxextra{infrapy.database.taskbase.assoc.AssocInfraPy\_LANL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.assoc.AssocInfraPy_LANL.data_processing}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{data\_processing}}}{}{}
Constructor

\end{fulllineitems}

\index{data\_processingASSOC() (infrapy.database.taskbase.assoc.AssocInfraPy\_LANL method)@\spxentry{data\_processingASSOC()}\spxextra{infrapy.database.taskbase.assoc.AssocInfraPy\_LANL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.assoc.AssocInfraPy_LANL.data_processingASSOC}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{data\_processingASSOC}}}{\emph{t\_start}, \emph{t\_end}, \emph{src\_win}, \emph{max\_prop\_tm}}{}
\end{fulllineitems}

\index{data\_retrievingS() (infrapy.database.taskbase.assoc.AssocInfraPy\_LANL method)@\spxentry{data\_retrievingS()}\spxextra{infrapy.database.taskbase.assoc.AssocInfraPy\_LANL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.assoc.AssocInfraPy_LANL.data_retrievingS}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{data\_retrievingS}}}{\emph{win\_start}, \emph{win\_end}}{}
\end{fulllineitems}

\index{database\_connecting() (infrapy.database.taskbase.assoc.AssocInfraPy\_LANL method)@\spxentry{database\_connecting()}\spxextra{infrapy.database.taskbase.assoc.AssocInfraPy\_LANL method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.assoc.AssocInfraPy_LANL.database_connecting}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{database\_connecting}}}{}{}
Constructor

\end{fulllineitems}


\end{fulllineitems}

\end{quote}
\phantomsection\label{\detokenize{infrapy.database.taskbase:module-infrapy.database.taskbase.loc}}\index{infrapy.database.taskbase.loc (module)@\spxentry{infrapy.database.taskbase.loc}\spxextra{module}}
Created on Oct 31, 2014

@author: omarcillo
\index{LocInfraPy (class in infrapy.database.taskbase.loc)@\spxentry{LocInfraPy}\spxextra{class in infrapy.database.taskbase.loc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.loc.LocInfraPy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{infrapy.database.taskbase.loc.}}\sphinxbfcode{\sphinxupquote{LocInfraPy}}}{\emph{conf\_file={[}{]}}}{}
Bases: \sphinxcode{\sphinxupquote{infrapy.database.taskbase.base.Base}}

classdocs
\index{algorithm (infrapy.database.taskbase.loc.LocInfraPy attribute)@\spxentry{algorithm}\spxextra{infrapy.database.taskbase.loc.LocInfraPy attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.loc.LocInfraPy.algorithm}}\pysigline{\sphinxbfcode{\sphinxupquote{algorithm}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}Blom/BISL III\textquotesingle{}}}}
\end{fulllineitems}

\index{data\_processing() (infrapy.database.taskbase.loc.LocInfraPy method)@\spxentry{data\_processing()}\spxextra{infrapy.database.taskbase.loc.LocInfraPy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.loc.LocInfraPy.data_processing}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{data\_processing}}}{}{}
Constructor

\end{fulllineitems}

\index{data\_processingLOC() (infrapy.database.taskbase.loc.LocInfraPy method)@\spxentry{data\_processingLOC()}\spxextra{infrapy.database.taskbase.loc.LocInfraPy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.loc.LocInfraPy.data_processingLOC}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{data\_processingLOC}}}{}{}
\end{fulllineitems}

\index{data\_retrieving() (infrapy.database.taskbase.loc.LocInfraPy method)@\spxentry{data\_retrieving()}\spxextra{infrapy.database.taskbase.loc.LocInfraPy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.loc.LocInfraPy.data_retrieving}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{data\_retrieving}}}{\emph{dayofyear}}{}
\end{fulllineitems}

\index{database\_connecting() (infrapy.database.taskbase.loc.LocInfraPy method)@\spxentry{database\_connecting()}\spxextra{infrapy.database.taskbase.loc.LocInfraPy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.loc.LocInfraPy.database_connecting}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{database\_connecting}}}{}{}
Constructor

\end{fulllineitems}

\index{meanlocations() (infrapy.database.taskbase.loc.LocInfraPy method)@\spxentry{meanlocations()}\spxextra{infrapy.database.taskbase.loc.LocInfraPy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.loc.LocInfraPy.meanlocations}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{meanlocations}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{run\_bislSC\_wrapper() (in module infrapy.database.taskbase.loc)@\spxentry{run\_bislSC\_wrapper()}\spxextra{in module infrapy.database.taskbase.loc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database.taskbase:infrapy.database.taskbase.loc.run_bislSC_wrapper}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.database.taskbase.loc.}}\sphinxbfcode{\sphinxupquote{run\_bislSC\_wrapper}}}{\emph{args}}{}
wrapper for multicore and quality control

\end{fulllineitems}



\subsubsection{Database Schema}
\label{\detokenize{infrapy.database:module-infrapy.database.schema}}\label{\detokenize{infrapy.database:database-schema}}\index{infrapy.database.schema (module)@\spxentry{infrapy.database.schema}\spxextra{module}}\index{ASSOC\_params (class in infrapy.database.schema)@\spxentry{ASSOC\_params}\spxextra{class in infrapy.database.schema}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_params}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{infrapy.database.schema.}}\sphinxbfcode{\sphinxupquote{ASSOC\_params}}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{\sphinxupquote{pisces.schema.util.Base}}
\index{algorithm (infrapy.database.schema.ASSOC\_params attribute)@\spxentry{algorithm}\spxextra{infrapy.database.schema.ASSOC\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_params.algorithm}}\pysigline{\sphinxbfcode{\sphinxupquote{algorithm}}\sphinxbfcode{\sphinxupquote{ = Column(None, String(length=15), table=None)}}}
\end{fulllineitems}

\index{beamwidth (infrapy.database.schema.ASSOC\_params attribute)@\spxentry{beamwidth}\spxextra{infrapy.database.schema.ASSOC\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_params.beamwidth}}\pysigline{\sphinxbfcode{\sphinxupquote{beamwidth}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{clusterthresh (infrapy.database.schema.ASSOC\_params attribute)@\spxentry{clusterthresh}\spxextra{infrapy.database.schema.ASSOC\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_params.clusterthresh}}\pysigline{\sphinxbfcode{\sphinxupquote{clusterthresh}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{duration (infrapy.database.schema.ASSOC\_params attribute)@\spxentry{duration}\spxextra{infrapy.database.schema.ASSOC\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_params.duration}}\pysigline{\sphinxbfcode{\sphinxupquote{duration}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{from\_string() (infrapy.database.schema.ASSOC\_params class method)@\spxentry{from\_string()}\spxextra{infrapy.database.schema.ASSOC\_params class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_params.from_string}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{from\_string}}}{\emph{line}, \emph{default\_on\_error=None}}{}
Construct a mapped table instance from correctly formatted flat file line.

Works with fixed\sphinxhyphen{}length fields, separated by a single whitespace.
\begin{description}
\item[{line: str}] \leavevmode
Flat file line (best to remove newline, but maybe not a problem).

\item[{default\_on\_error: list, optional}] \leavevmode
Supply a list of column names that return default values if they
produce an error during parsing (e.g. lddate).

\end{description}

ValueError:  Can’t properly parse the line.

default\_on\_error is useful for malformed fields, but it will also mask
other problems with line parsing. It’s better to pre\sphinxhyphen{}process tables 
to match the table specifications or catch exceptions and isolate 
these lines.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TA.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{ffsite}\PYG{p}{:}
\PYG{g+go}{        for line in ffsite:}
\PYG{g+go}{            isite = Site.from\PYGZus{}string(line)}
\PYG{g+go}{or}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TA.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{ffsite}\PYG{p}{:}
\PYG{g+go}{        for line in ffsite:}
\PYG{g+go}{            isite = Site.from\PYGZus{}string(line, default\PYGZus{}on\PYGZus{}error=[\PYGZsq{}lddate\PYGZsq{}])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{minarraypop (infrapy.database.schema.ASSOC\_params attribute)@\spxentry{minarraypop}\spxextra{infrapy.database.schema.ASSOC\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_params.minarraypop}}\pysigline{\sphinxbfcode{\sphinxupquote{minarraypop}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{mindetpop (infrapy.database.schema.ASSOC\_params attribute)@\spxentry{mindetpop}\spxextra{infrapy.database.schema.ASSOC\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_params.mindetpop}}\pysigline{\sphinxbfcode{\sphinxupquote{mindetpop}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{name (infrapy.database.schema.ASSOC\_params attribute)@\spxentry{name}\spxextra{infrapy.database.schema.ASSOC\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_params.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{passocid (infrapy.database.schema.ASSOC\_params attribute)@\spxentry{passocid}\spxextra{infrapy.database.schema.ASSOC\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_params.passocid}}\pysigline{\sphinxbfcode{\sphinxupquote{passocid}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{rangemax (infrapy.database.schema.ASSOC\_params attribute)@\spxentry{rangemax}\spxextra{infrapy.database.schema.ASSOC\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_params.rangemax}}\pysigline{\sphinxbfcode{\sphinxupquote{rangemax}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{trimthresh (infrapy.database.schema.ASSOC\_params attribute)@\spxentry{trimthresh}\spxextra{infrapy.database.schema.ASSOC\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_params.trimthresh}}\pysigline{\sphinxbfcode{\sphinxupquote{trimthresh}}\sphinxbfcode{\sphinxupquote{ = Column(None, String(length=15), table=None)}}}
\end{fulllineitems}

\index{trimthreshscalar (infrapy.database.schema.ASSOC\_params attribute)@\spxentry{trimthreshscalar}\spxextra{infrapy.database.schema.ASSOC\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_params.trimthreshscalar}}\pysigline{\sphinxbfcode{\sphinxupquote{trimthreshscalar}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}


\end{fulllineitems}

\index{ASSOC\_results (class in infrapy.database.schema)@\spxentry{ASSOC\_results}\spxextra{class in infrapy.database.schema}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_results}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{infrapy.database.schema.}}\sphinxbfcode{\sphinxupquote{ASSOC\_results}}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{\sphinxupquote{pisces.schema.util.Base}}
\index{associd (infrapy.database.schema.ASSOC\_results attribute)@\spxentry{associd}\spxextra{infrapy.database.schema.ASSOC\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_results.associd}}\pysigline{\sphinxbfcode{\sphinxupquote{associd}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{eventid (infrapy.database.schema.ASSOC\_results attribute)@\spxentry{eventid}\spxextra{infrapy.database.schema.ASSOC\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_results.eventid}}\pysigline{\sphinxbfcode{\sphinxupquote{eventid}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{fdid (infrapy.database.schema.ASSOC\_results attribute)@\spxentry{fdid}\spxextra{infrapy.database.schema.ASSOC\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_results.fdid}}\pysigline{\sphinxbfcode{\sphinxupquote{fdid}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{fdtable (infrapy.database.schema.ASSOC\_results attribute)@\spxentry{fdtable}\spxextra{infrapy.database.schema.ASSOC\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_results.fdtable}}\pysigline{\sphinxbfcode{\sphinxupquote{fdtable}}\sphinxbfcode{\sphinxupquote{ = Column(None, String(length=15), table=None)}}}
\end{fulllineitems}

\index{from\_string() (infrapy.database.schema.ASSOC\_results class method)@\spxentry{from\_string()}\spxextra{infrapy.database.schema.ASSOC\_results class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_results.from_string}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{from\_string}}}{\emph{line}, \emph{default\_on\_error=None}}{}
Construct a mapped table instance from correctly formatted flat file line.

Works with fixed\sphinxhyphen{}length fields, separated by a single whitespace.
\begin{description}
\item[{line: str}] \leavevmode
Flat file line (best to remove newline, but maybe not a problem).

\item[{default\_on\_error: list, optional}] \leavevmode
Supply a list of column names that return default values if they
produce an error during parsing (e.g. lddate).

\end{description}

ValueError:  Can’t properly parse the line.

default\_on\_error is useful for malformed fields, but it will also mask
other problems with line parsing. It’s better to pre\sphinxhyphen{}process tables 
to match the table specifications or catch exceptions and isolate 
these lines.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TA.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{ffsite}\PYG{p}{:}
\PYG{g+go}{        for line in ffsite:}
\PYG{g+go}{            isite = Site.from\PYGZus{}string(line)}
\PYG{g+go}{or}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TA.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{ffsite}\PYG{p}{:}
\PYG{g+go}{        for line in ffsite:}
\PYG{g+go}{            isite = Site.from\PYGZus{}string(line, default\PYGZus{}on\PYGZus{}error=[\PYGZsq{}lddate\PYGZsq{}])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{net (infrapy.database.schema.ASSOC\_results attribute)@\spxentry{net}\spxextra{infrapy.database.schema.ASSOC\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_results.net}}\pysigline{\sphinxbfcode{\sphinxupquote{net}}\sphinxbfcode{\sphinxupquote{ = Column(None, String(length=8), table=None)}}}
\end{fulllineitems}

\index{passocid (infrapy.database.schema.ASSOC\_results attribute)@\spxentry{passocid}\spxextra{infrapy.database.schema.ASSOC\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_results.passocid}}\pysigline{\sphinxbfcode{\sphinxupquote{passocid}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{qassoc (infrapy.database.schema.ASSOC\_results attribute)@\spxentry{qassoc}\spxextra{infrapy.database.schema.ASSOC\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_results.qassoc}}\pysigline{\sphinxbfcode{\sphinxupquote{qassoc}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{qdetcluster (infrapy.database.schema.ASSOC\_results attribute)@\spxentry{qdetcluster}\spxextra{infrapy.database.schema.ASSOC\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_results.qdetcluster}}\pysigline{\sphinxbfcode{\sphinxupquote{qdetcluster}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{sta (infrapy.database.schema.ASSOC\_results attribute)@\spxentry{sta}\spxextra{infrapy.database.schema.ASSOC\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_results.sta}}\pysigline{\sphinxbfcode{\sphinxupquote{sta}}\sphinxbfcode{\sphinxupquote{ = Column(None, String(length=6), table=None)}}}
\end{fulllineitems}

\index{timeend (infrapy.database.schema.ASSOC\_results attribute)@\spxentry{timeend}\spxextra{infrapy.database.schema.ASSOC\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_results.timeend}}\pysigline{\sphinxbfcode{\sphinxupquote{timeend}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{timeini (infrapy.database.schema.ASSOC\_results attribute)@\spxentry{timeini}\spxextra{infrapy.database.schema.ASSOC\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.ASSOC_results.timeini}}\pysigline{\sphinxbfcode{\sphinxupquote{timeini}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}


\end{fulllineitems}

\index{EDetectParams (class in infrapy.database.schema)@\spxentry{EDetectParams}\spxextra{class in infrapy.database.schema}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.EDetectParams}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{infrapy.database.schema.}}\sphinxbfcode{\sphinxupquote{EDetectParams}}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{\sphinxupquote{pisces.schema.util.Base}}
\index{algorithm (infrapy.database.schema.EDetectParams attribute)@\spxentry{algorithm}\spxextra{infrapy.database.schema.EDetectParams attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.EDetectParams.algorithm}}\pysigline{\sphinxbfcode{\sphinxupquote{algorithm}}\sphinxbfcode{\sphinxupquote{ = Column(None, String(length=15), table=None)}}}
\end{fulllineitems}

\index{filterh (infrapy.database.schema.EDetectParams attribute)@\spxentry{filterh}\spxextra{infrapy.database.schema.EDetectParams attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.EDetectParams.filterh}}\pysigline{\sphinxbfcode{\sphinxupquote{filterh}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(), table=None)}}}
\end{fulllineitems}

\index{filterl (infrapy.database.schema.EDetectParams attribute)@\spxentry{filterl}\spxextra{infrapy.database.schema.EDetectParams attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.EDetectParams.filterl}}\pysigline{\sphinxbfcode{\sphinxupquote{filterl}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(), table=None)}}}
\end{fulllineitems}

\index{filtertype (infrapy.database.schema.EDetectParams attribute)@\spxentry{filtertype}\spxextra{infrapy.database.schema.EDetectParams attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.EDetectParams.filtertype}}\pysigline{\sphinxbfcode{\sphinxupquote{filtertype}}\sphinxbfcode{\sphinxupquote{ = Column(None, String(length=15), table=None)}}}
\end{fulllineitems}

\index{from\_string() (infrapy.database.schema.EDetectParams class method)@\spxentry{from\_string()}\spxextra{infrapy.database.schema.EDetectParams class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.EDetectParams.from_string}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{from\_string}}}{\emph{line}, \emph{default\_on\_error=None}}{}
Construct a mapped table instance from correctly formatted flat file line.

Works with fixed\sphinxhyphen{}length fields, separated by a single whitespace.
\begin{description}
\item[{line: str}] \leavevmode
Flat file line (best to remove newline, but maybe not a problem).

\item[{default\_on\_error: list, optional}] \leavevmode
Supply a list of column names that return default values if they
produce an error during parsing (e.g. lddate).

\end{description}

ValueError:  Can’t properly parse the line.

default\_on\_error is useful for malformed fields, but it will also mask
other problems with line parsing. It’s better to pre\sphinxhyphen{}process tables 
to match the table specifications or catch exceptions and isolate 
these lines.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TA.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{ffsite}\PYG{p}{:}
\PYG{g+go}{        for line in ffsite:}
\PYG{g+go}{            isite = Site.from\PYGZus{}string(line)}
\PYG{g+go}{or}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TA.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{ffsite}\PYG{p}{:}
\PYG{g+go}{        for line in ffsite:}
\PYG{g+go}{            isite = Site.from\PYGZus{}string(line, default\PYGZus{}on\PYGZus{}error=[\PYGZsq{}lddate\PYGZsq{}])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{name (infrapy.database.schema.EDetectParams attribute)@\spxentry{name}\spxextra{infrapy.database.schema.EDetectParams attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.EDetectParams.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{overlapwlen (infrapy.database.schema.EDetectParams attribute)@\spxentry{overlapwlen}\spxextra{infrapy.database.schema.EDetectParams attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.EDetectParams.overlapwlen}}\pysigline{\sphinxbfcode{\sphinxupquote{overlapwlen}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(), table=None)}}}
\end{fulllineitems}

\index{pedetectid (infrapy.database.schema.EDetectParams attribute)@\spxentry{pedetectid}\spxextra{infrapy.database.schema.EDetectParams attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.EDetectParams.pedetectid}}\pysigline{\sphinxbfcode{\sphinxupquote{pedetectid}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{wlenlong (infrapy.database.schema.EDetectParams attribute)@\spxentry{wlenlong}\spxextra{infrapy.database.schema.EDetectParams attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.EDetectParams.wlenlong}}\pysigline{\sphinxbfcode{\sphinxupquote{wlenlong}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(), table=None)}}}
\end{fulllineitems}

\index{wlenshort (infrapy.database.schema.EDetectParams attribute)@\spxentry{wlenshort}\spxextra{infrapy.database.schema.EDetectParams attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.EDetectParams.wlenshort}}\pysigline{\sphinxbfcode{\sphinxupquote{wlenshort}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(), table=None)}}}
\end{fulllineitems}


\end{fulllineitems}

\index{fd\_params (class in infrapy.database.schema)@\spxentry{fd\_params}\spxextra{class in infrapy.database.schema}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_params}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{infrapy.database.schema.}}\sphinxbfcode{\sphinxupquote{fd\_params}}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{\sphinxupquote{pisces.schema.util.Base}}
\index{additional1 (infrapy.database.schema.fd\_params attribute)@\spxentry{additional1}\spxextra{infrapy.database.schema.fd\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_params.additional1}}\pysigline{\sphinxbfcode{\sphinxupquote{additional1}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{additional2 (infrapy.database.schema.fd\_params attribute)@\spxentry{additional2}\spxextra{infrapy.database.schema.fd\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_params.additional2}}\pysigline{\sphinxbfcode{\sphinxupquote{additional2}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{algorithm (infrapy.database.schema.fd\_params attribute)@\spxentry{algorithm}\spxextra{infrapy.database.schema.fd\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_params.algorithm}}\pysigline{\sphinxbfcode{\sphinxupquote{algorithm}}\sphinxbfcode{\sphinxupquote{ = Column(None, String(length=15), table=None)}}}
\end{fulllineitems}

\index{backazlim (infrapy.database.schema.fd\_params attribute)@\spxentry{backazlim}\spxextra{infrapy.database.schema.fd\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_params.backazlim}}\pysigline{\sphinxbfcode{\sphinxupquote{backazlim}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{cthr (infrapy.database.schema.fd\_params attribute)@\spxentry{cthr}\spxextra{infrapy.database.schema.fd\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_params.cthr}}\pysigline{\sphinxbfcode{\sphinxupquote{cthr}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{detwinlen (infrapy.database.schema.fd\_params attribute)@\spxentry{detwinlen}\spxextra{infrapy.database.schema.fd\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_params.detwinlen}}\pysigline{\sphinxbfcode{\sphinxupquote{detwinlen}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{dsegmin (infrapy.database.schema.fd\_params attribute)@\spxentry{dsegmin}\spxextra{infrapy.database.schema.fd\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_params.dsegmin}}\pysigline{\sphinxbfcode{\sphinxupquote{dsegmin}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{from\_string() (infrapy.database.schema.fd\_params class method)@\spxentry{from\_string()}\spxextra{infrapy.database.schema.fd\_params class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_params.from_string}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{from\_string}}}{\emph{line}, \emph{default\_on\_error=None}}{}
Construct a mapped table instance from correctly formatted flat file line.

Works with fixed\sphinxhyphen{}length fields, separated by a single whitespace.
\begin{description}
\item[{line: str}] \leavevmode
Flat file line (best to remove newline, but maybe not a problem).

\item[{default\_on\_error: list, optional}] \leavevmode
Supply a list of column names that return default values if they
produce an error during parsing (e.g. lddate).

\end{description}

ValueError:  Can’t properly parse the line.

default\_on\_error is useful for malformed fields, but it will also mask
other problems with line parsing. It’s better to pre\sphinxhyphen{}process tables 
to match the table specifications or catch exceptions and isolate 
these lines.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TA.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{ffsite}\PYG{p}{:}
\PYG{g+go}{        for line in ffsite:}
\PYG{g+go}{            isite = Site.from\PYGZus{}string(line)}
\PYG{g+go}{or}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TA.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{ffsite}\PYG{p}{:}
\PYG{g+go}{        for line in ffsite:}
\PYG{g+go}{            isite = Site.from\PYGZus{}string(line, default\PYGZus{}on\PYGZus{}error=[\PYGZsq{}lddate\PYGZsq{}])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{minlen (infrapy.database.schema.fd\_params attribute)@\spxentry{minlen}\spxextra{infrapy.database.schema.fd\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_params.minlen}}\pysigline{\sphinxbfcode{\sphinxupquote{minlen}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{name (infrapy.database.schema.fd\_params attribute)@\spxentry{name}\spxextra{infrapy.database.schema.fd\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_params.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{numsources (infrapy.database.schema.fd\_params attribute)@\spxentry{numsources}\spxextra{infrapy.database.schema.fd\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_params.numsources}}\pysigline{\sphinxbfcode{\sphinxupquote{numsources}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{pfdid (infrapy.database.schema.fd\_params attribute)@\spxentry{pfdid}\spxextra{infrapy.database.schema.fd\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_params.pfdid}}\pysigline{\sphinxbfcode{\sphinxupquote{pfdid}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{pthreshold (infrapy.database.schema.fd\_params attribute)@\spxentry{pthreshold}\spxextra{infrapy.database.schema.fd\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_params.pthreshold}}\pysigline{\sphinxbfcode{\sphinxupquote{pthreshold}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{tb\_prod (infrapy.database.schema.fd\_params attribute)@\spxentry{tb\_prod}\spxextra{infrapy.database.schema.fd\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_params.tb_prod}}\pysigline{\sphinxbfcode{\sphinxupquote{tb\_prod}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}


\end{fulllineitems}

\index{fd\_results (class in infrapy.database.schema)@\spxentry{fd\_results}\spxextra{class in infrapy.database.schema}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{infrapy.database.schema.}}\sphinxbfcode{\sphinxupquote{fd\_results}}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{\sphinxupquote{pisces.schema.util.Base}}
\index{c (infrapy.database.schema.fd\_results attribute)@\spxentry{c}\spxextra{infrapy.database.schema.fd\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results.c}}\pysigline{\sphinxbfcode{\sphinxupquote{c}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{ebz (infrapy.database.schema.fd\_results attribute)@\spxentry{ebz}\spxextra{infrapy.database.schema.fd\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results.ebz}}\pysigline{\sphinxbfcode{\sphinxupquote{ebz}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{ec (infrapy.database.schema.fd\_results attribute)@\spxentry{ec}\spxextra{infrapy.database.schema.fd\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results.ec}}\pysigline{\sphinxbfcode{\sphinxupquote{ec}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{etimeend (infrapy.database.schema.fd\_results attribute)@\spxentry{etimeend}\spxextra{infrapy.database.schema.fd\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results.etimeend}}\pysigline{\sphinxbfcode{\sphinxupquote{etimeend}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{etimeini (infrapy.database.schema.fd\_results attribute)@\spxentry{etimeini}\spxextra{infrapy.database.schema.fd\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results.etimeini}}\pysigline{\sphinxbfcode{\sphinxupquote{etimeini}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{etrvel (infrapy.database.schema.fd\_results attribute)@\spxentry{etrvel}\spxextra{infrapy.database.schema.fd\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results.etrvel}}\pysigline{\sphinxbfcode{\sphinxupquote{etrvel}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{fdid (infrapy.database.schema.fd\_results attribute)@\spxentry{fdid}\spxextra{infrapy.database.schema.fd\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results.fdid}}\pysigline{\sphinxbfcode{\sphinxupquote{fdid}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{fktablename (infrapy.database.schema.fd\_results attribute)@\spxentry{fktablename}\spxextra{infrapy.database.schema.fd\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results.fktablename}}\pysigline{\sphinxbfcode{\sphinxupquote{fktablename}}\sphinxbfcode{\sphinxupquote{ = Column(None, String(length=15), table=None)}}}
\end{fulllineitems}

\index{from\_string() (infrapy.database.schema.fd\_results class method)@\spxentry{from\_string()}\spxextra{infrapy.database.schema.fd\_results class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results.from_string}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{from\_string}}}{\emph{line}, \emph{default\_on\_error=None}}{}
Construct a mapped table instance from correctly formatted flat file line.

Works with fixed\sphinxhyphen{}length fields, separated by a single whitespace.
\begin{description}
\item[{line: str}] \leavevmode
Flat file line (best to remove newline, but maybe not a problem).

\item[{default\_on\_error: list, optional}] \leavevmode
Supply a list of column names that return default values if they
produce an error during parsing (e.g. lddate).

\end{description}

ValueError:  Can’t properly parse the line.

default\_on\_error is useful for malformed fields, but it will also mask
other problems with line parsing. It’s better to pre\sphinxhyphen{}process tables 
to match the table specifications or catch exceptions and isolate 
these lines.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TA.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{ffsite}\PYG{p}{:}
\PYG{g+go}{        for line in ffsite:}
\PYG{g+go}{            isite = Site.from\PYGZus{}string(line)}
\PYG{g+go}{or}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TA.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{ffsite}\PYG{p}{:}
\PYG{g+go}{        for line in ffsite:}
\PYG{g+go}{            isite = Site.from\PYGZus{}string(line, default\PYGZus{}on\PYGZus{}error=[\PYGZsq{}lddate\PYGZsq{}])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{maxfc (infrapy.database.schema.fd\_results attribute)@\spxentry{maxfc}\spxextra{infrapy.database.schema.fd\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results.maxfc}}\pysigline{\sphinxbfcode{\sphinxupquote{maxfc}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{maxfo (infrapy.database.schema.fd\_results attribute)@\spxentry{maxfo}\spxextra{infrapy.database.schema.fd\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results.maxfo}}\pysigline{\sphinxbfcode{\sphinxupquote{maxfo}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{pfdid (infrapy.database.schema.fd\_results attribute)@\spxentry{pfdid}\spxextra{infrapy.database.schema.fd\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results.pfdid}}\pysigline{\sphinxbfcode{\sphinxupquote{pfdid}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{pfkid (infrapy.database.schema.fd\_results attribute)@\spxentry{pfkid}\spxextra{infrapy.database.schema.fd\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results.pfkid}}\pysigline{\sphinxbfcode{\sphinxupquote{pfkid}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{sourcenum (infrapy.database.schema.fd\_results attribute)@\spxentry{sourcenum}\spxextra{infrapy.database.schema.fd\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results.sourcenum}}\pysigline{\sphinxbfcode{\sphinxupquote{sourcenum}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{sta (infrapy.database.schema.fd\_results attribute)@\spxentry{sta}\spxextra{infrapy.database.schema.fd\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results.sta}}\pysigline{\sphinxbfcode{\sphinxupquote{sta}}\sphinxbfcode{\sphinxupquote{ = Column(None, String(length=6), table=None)}}}
\end{fulllineitems}

\index{tend (infrapy.database.schema.fd\_results attribute)@\spxentry{tend}\spxextra{infrapy.database.schema.fd\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results.tend}}\pysigline{\sphinxbfcode{\sphinxupquote{tend}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{timeend (infrapy.database.schema.fd\_results attribute)@\spxentry{timeend}\spxextra{infrapy.database.schema.fd\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results.timeend}}\pysigline{\sphinxbfcode{\sphinxupquote{timeend}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{timeini (infrapy.database.schema.fd\_results attribute)@\spxentry{timeini}\spxextra{infrapy.database.schema.fd\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results.timeini}}\pysigline{\sphinxbfcode{\sphinxupquote{timeini}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{tonset (infrapy.database.schema.fd\_results attribute)@\spxentry{tonset}\spxextra{infrapy.database.schema.fd\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results.tonset}}\pysigline{\sphinxbfcode{\sphinxupquote{tonset}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{trvel (infrapy.database.schema.fd\_results attribute)@\spxentry{trvel}\spxextra{infrapy.database.schema.fd\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fd_results.trvel}}\pysigline{\sphinxbfcode{\sphinxupquote{trvel}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}


\end{fulllineitems}

\index{fk\_params (class in infrapy.database.schema)@\spxentry{fk\_params}\spxextra{class in infrapy.database.schema}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{infrapy.database.schema.}}\sphinxbfcode{\sphinxupquote{fk\_params}}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{\sphinxupquote{pisces.schema.util.Base}}
\index{additional1 (infrapy.database.schema.fk\_params attribute)@\spxentry{additional1}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.additional1}}\pysigline{\sphinxbfcode{\sphinxupquote{additional1}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{additional2 (infrapy.database.schema.fk\_params attribute)@\spxentry{additional2}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.additional2}}\pysigline{\sphinxbfcode{\sphinxupquote{additional2}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{algorithm (infrapy.database.schema.fk\_params attribute)@\spxentry{algorithm}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.algorithm}}\pysigline{\sphinxbfcode{\sphinxupquote{algorithm}}\sphinxbfcode{\sphinxupquote{ = Column(None, String(length=15), table=None)}}}
\end{fulllineitems}

\index{backazmax (infrapy.database.schema.fk\_params attribute)@\spxentry{backazmax}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.backazmax}}\pysigline{\sphinxbfcode{\sphinxupquote{backazmax}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{backazmin (infrapy.database.schema.fk\_params attribute)@\spxentry{backazmin}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.backazmin}}\pysigline{\sphinxbfcode{\sphinxupquote{backazmin}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{backazstep (infrapy.database.schema.fk\_params attribute)@\spxentry{backazstep}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.backazstep}}\pysigline{\sphinxbfcode{\sphinxupquote{backazstep}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{beamwinlen (infrapy.database.schema.fk\_params attribute)@\spxentry{beamwinlen}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.beamwinlen}}\pysigline{\sphinxbfcode{\sphinxupquote{beamwinlen}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{beamwinstep (infrapy.database.schema.fk\_params attribute)@\spxentry{beamwinstep}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.beamwinstep}}\pysigline{\sphinxbfcode{\sphinxupquote{beamwinstep}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{domain (infrapy.database.schema.fk\_params attribute)@\spxentry{domain}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.domain}}\pysigline{\sphinxbfcode{\sphinxupquote{domain}}\sphinxbfcode{\sphinxupquote{ = Column(None, String(length=15), table=None)}}}
\end{fulllineitems}

\index{filter (infrapy.database.schema.fk\_params attribute)@\spxentry{filter}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.filter}}\pysigline{\sphinxbfcode{\sphinxupquote{filter}}\sphinxbfcode{\sphinxupquote{ = Column(None, String(length=15), table=None)}}}
\end{fulllineitems}

\index{freqmax (infrapy.database.schema.fk\_params attribute)@\spxentry{freqmax}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.freqmax}}\pysigline{\sphinxbfcode{\sphinxupquote{freqmax}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{freqmin (infrapy.database.schema.fk\_params attribute)@\spxentry{freqmin}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.freqmin}}\pysigline{\sphinxbfcode{\sphinxupquote{freqmin}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{from\_string() (infrapy.database.schema.fk\_params class method)@\spxentry{from\_string()}\spxextra{infrapy.database.schema.fk\_params class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.from_string}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{from\_string}}}{\emph{line}, \emph{default\_on\_error=None}}{}
Construct a mapped table instance from correctly formatted flat file line.

Works with fixed\sphinxhyphen{}length fields, separated by a single whitespace.
\begin{description}
\item[{line: str}] \leavevmode
Flat file line (best to remove newline, but maybe not a problem).

\item[{default\_on\_error: list, optional}] \leavevmode
Supply a list of column names that return default values if they
produce an error during parsing (e.g. lddate).

\end{description}

ValueError:  Can’t properly parse the line.

default\_on\_error is useful for malformed fields, but it will also mask
other problems with line parsing. It’s better to pre\sphinxhyphen{}process tables 
to match the table specifications or catch exceptions and isolate 
these lines.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TA.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{ffsite}\PYG{p}{:}
\PYG{g+go}{        for line in ffsite:}
\PYG{g+go}{            isite = Site.from\PYGZus{}string(line)}
\PYG{g+go}{or}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TA.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{ffsite}\PYG{p}{:}
\PYG{g+go}{        for line in ffsite:}
\PYG{g+go}{            isite = Site.from\PYGZus{}string(line, default\PYGZus{}on\PYGZus{}error=[\PYGZsq{}lddate\PYGZsq{}])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{maxslowness (infrapy.database.schema.fk\_params attribute)@\spxentry{maxslowness}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.maxslowness}}\pysigline{\sphinxbfcode{\sphinxupquote{maxslowness}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{minslowness (infrapy.database.schema.fk\_params attribute)@\spxentry{minslowness}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.minslowness}}\pysigline{\sphinxbfcode{\sphinxupquote{minslowness}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{name (infrapy.database.schema.fk\_params attribute)@\spxentry{name}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}\sphinxbfcode{\sphinxupquote{ = Column(None, String(length=15), table=None)}}}
\end{fulllineitems}

\index{numsources (infrapy.database.schema.fk\_params attribute)@\spxentry{numsources}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.numsources}}\pysigline{\sphinxbfcode{\sphinxupquote{numsources}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{pfkid (infrapy.database.schema.fk\_params attribute)@\spxentry{pfkid}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.pfkid}}\pysigline{\sphinxbfcode{\sphinxupquote{pfkid}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{stepslowness (infrapy.database.schema.fk\_params attribute)@\spxentry{stepslowness}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.stepslowness}}\pysigline{\sphinxbfcode{\sphinxupquote{stepslowness}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{trvelmax (infrapy.database.schema.fk\_params attribute)@\spxentry{trvelmax}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.trvelmax}}\pysigline{\sphinxbfcode{\sphinxupquote{trvelmax}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{trvelmin (infrapy.database.schema.fk\_params attribute)@\spxentry{trvelmin}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.trvelmin}}\pysigline{\sphinxbfcode{\sphinxupquote{trvelmin}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{trvelstep (infrapy.database.schema.fk\_params attribute)@\spxentry{trvelstep}\spxextra{infrapy.database.schema.fk\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_params.trvelstep}}\pysigline{\sphinxbfcode{\sphinxupquote{trvelstep}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}


\end{fulllineitems}

\index{fk\_results (class in infrapy.database.schema)@\spxentry{fk\_results}\spxextra{class in infrapy.database.schema}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{infrapy.database.schema.}}\sphinxbfcode{\sphinxupquote{fk\_results}}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{\sphinxupquote{pisces.schema.util.Base}}
\index{additional1 (infrapy.database.schema.fk\_results attribute)@\spxentry{additional1}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.additional1}}\pysigline{\sphinxbfcode{\sphinxupquote{additional1}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{additional2 (infrapy.database.schema.fk\_results attribute)@\spxentry{additional2}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.additional2}}\pysigline{\sphinxbfcode{\sphinxupquote{additional2}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{bz (infrapy.database.schema.fk\_results attribute)@\spxentry{bz}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.bz}}\pysigline{\sphinxbfcode{\sphinxupquote{bz}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{chan (infrapy.database.schema.fk\_results attribute)@\spxentry{chan}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.chan}}\pysigline{\sphinxbfcode{\sphinxupquote{chan}}\sphinxbfcode{\sphinxupquote{ = Column(None, String(length=8), table=None)}}}
\end{fulllineitems}

\index{coher (infrapy.database.schema.fk\_results attribute)@\spxentry{coher}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.coher}}\pysigline{\sphinxbfcode{\sphinxupquote{coher}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{ebz (infrapy.database.schema.fk\_results attribute)@\spxentry{ebz}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.ebz}}\pysigline{\sphinxbfcode{\sphinxupquote{ebz}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{eslofk (infrapy.database.schema.fk\_results attribute)@\spxentry{eslofk}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.eslofk}}\pysigline{\sphinxbfcode{\sphinxupquote{eslofk}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{esx (infrapy.database.schema.fk\_results attribute)@\spxentry{esx}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.esx}}\pysigline{\sphinxbfcode{\sphinxupquote{esx}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{esy (infrapy.database.schema.fk\_results attribute)@\spxentry{esy}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.esy}}\pysigline{\sphinxbfcode{\sphinxupquote{esy}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{etrvel (infrapy.database.schema.fk\_results attribute)@\spxentry{etrvel}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.etrvel}}\pysigline{\sphinxbfcode{\sphinxupquote{etrvel}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{fkid (infrapy.database.schema.fk\_results attribute)@\spxentry{fkid}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.fkid}}\pysigline{\sphinxbfcode{\sphinxupquote{fkid}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{from\_string() (infrapy.database.schema.fk\_results class method)@\spxentry{from\_string()}\spxextra{infrapy.database.schema.fk\_results class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.from_string}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{from\_string}}}{\emph{line}, \emph{default\_on\_error=None}}{}
Construct a mapped table instance from correctly formatted flat file line.

Works with fixed\sphinxhyphen{}length fields, separated by a single whitespace.
\begin{description}
\item[{line: str}] \leavevmode
Flat file line (best to remove newline, but maybe not a problem).

\item[{default\_on\_error: list, optional}] \leavevmode
Supply a list of column names that return default values if they
produce an error during parsing (e.g. lddate).

\end{description}

ValueError:  Can’t properly parse the line.

default\_on\_error is useful for malformed fields, but it will also mask
other problems with line parsing. It’s better to pre\sphinxhyphen{}process tables 
to match the table specifications or catch exceptions and isolate 
these lines.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TA.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{ffsite}\PYG{p}{:}
\PYG{g+go}{        for line in ffsite:}
\PYG{g+go}{            isite = Site.from\PYGZus{}string(line)}
\PYG{g+go}{or}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TA.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{ffsite}\PYG{p}{:}
\PYG{g+go}{        for line in ffsite:}
\PYG{g+go}{            isite = Site.from\PYGZus{}string(line, default\PYGZus{}on\PYGZus{}error=[\PYGZsq{}lddate\PYGZsq{}])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{fval (infrapy.database.schema.fk\_results attribute)@\spxentry{fval}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.fval}}\pysigline{\sphinxbfcode{\sphinxupquote{fval}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{nchan (infrapy.database.schema.fk\_results attribute)@\spxentry{nchan}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.nchan}}\pysigline{\sphinxbfcode{\sphinxupquote{nchan}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{pfkid (infrapy.database.schema.fk\_results attribute)@\spxentry{pfkid}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.pfkid}}\pysigline{\sphinxbfcode{\sphinxupquote{pfkid}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{rmsval (infrapy.database.schema.fk\_results attribute)@\spxentry{rmsval}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.rmsval}}\pysigline{\sphinxbfcode{\sphinxupquote{rmsval}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{slofk (infrapy.database.schema.fk\_results attribute)@\spxentry{slofk}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.slofk}}\pysigline{\sphinxbfcode{\sphinxupquote{slofk}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{sourcenum (infrapy.database.schema.fk\_results attribute)@\spxentry{sourcenum}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.sourcenum}}\pysigline{\sphinxbfcode{\sphinxupquote{sourcenum}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{sta (infrapy.database.schema.fk\_results attribute)@\spxentry{sta}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.sta}}\pysigline{\sphinxbfcode{\sphinxupquote{sta}}\sphinxbfcode{\sphinxupquote{ = Column(None, String(length=6), table=None)}}}
\end{fulllineitems}

\index{sx (infrapy.database.schema.fk\_results attribute)@\spxentry{sx}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.sx}}\pysigline{\sphinxbfcode{\sphinxupquote{sx}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{sy (infrapy.database.schema.fk\_results attribute)@\spxentry{sy}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.sy}}\pysigline{\sphinxbfcode{\sphinxupquote{sy}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{timeend (infrapy.database.schema.fk\_results attribute)@\spxentry{timeend}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.timeend}}\pysigline{\sphinxbfcode{\sphinxupquote{timeend}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{timeini (infrapy.database.schema.fk\_results attribute)@\spxentry{timeini}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.timeini}}\pysigline{\sphinxbfcode{\sphinxupquote{timeini}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{trvel (infrapy.database.schema.fk\_results attribute)@\spxentry{trvel}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.trvel}}\pysigline{\sphinxbfcode{\sphinxupquote{trvel}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{xcorrvalmax (infrapy.database.schema.fk\_results attribute)@\spxentry{xcorrvalmax}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.xcorrvalmax}}\pysigline{\sphinxbfcode{\sphinxupquote{xcorrvalmax}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{xcorrvalmean (infrapy.database.schema.fk\_results attribute)@\spxentry{xcorrvalmean}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.xcorrvalmean}}\pysigline{\sphinxbfcode{\sphinxupquote{xcorrvalmean}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{xcorrvalmin (infrapy.database.schema.fk\_results attribute)@\spxentry{xcorrvalmin}\spxextra{infrapy.database.schema.fk\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.fk_results.xcorrvalmin}}\pysigline{\sphinxbfcode{\sphinxupquote{xcorrvalmin}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}


\end{fulllineitems}

\index{loc\_params (class in infrapy.database.schema)@\spxentry{loc\_params}\spxextra{class in infrapy.database.schema}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_params}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{infrapy.database.schema.}}\sphinxbfcode{\sphinxupquote{loc\_params}}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{\sphinxupquote{pisces.schema.util.Base}}
\index{algorithm (infrapy.database.schema.loc\_params attribute)@\spxentry{algorithm}\spxextra{infrapy.database.schema.loc\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_params.algorithm}}\pysigline{\sphinxbfcode{\sphinxupquote{algorithm}}\sphinxbfcode{\sphinxupquote{ = Column(None, String(length=15), table=None)}}}
\end{fulllineitems}

\index{from\_string() (infrapy.database.schema.loc\_params class method)@\spxentry{from\_string()}\spxextra{infrapy.database.schema.loc\_params class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_params.from_string}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{from\_string}}}{\emph{line}, \emph{default\_on\_error=None}}{}
Construct a mapped table instance from correctly formatted flat file line.

Works with fixed\sphinxhyphen{}length fields, separated by a single whitespace.
\begin{description}
\item[{line: str}] \leavevmode
Flat file line (best to remove newline, but maybe not a problem).

\item[{default\_on\_error: list, optional}] \leavevmode
Supply a list of column names that return default values if they
produce an error during parsing (e.g. lddate).

\end{description}

ValueError:  Can’t properly parse the line.

default\_on\_error is useful for malformed fields, but it will also mask
other problems with line parsing. It’s better to pre\sphinxhyphen{}process tables 
to match the table specifications or catch exceptions and isolate 
these lines.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TA.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{ffsite}\PYG{p}{:}
\PYG{g+go}{        for line in ffsite:}
\PYG{g+go}{            isite = Site.from\PYGZus{}string(line)}
\PYG{g+go}{or}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TA.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{ffsite}\PYG{p}{:}
\PYG{g+go}{        for line in ffsite:}
\PYG{g+go}{            isite = Site.from\PYGZus{}string(line, default\PYGZus{}on\PYGZus{}error=[\PYGZsq{}lddate\PYGZsq{}])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{maxlat (infrapy.database.schema.loc\_params attribute)@\spxentry{maxlat}\spxextra{infrapy.database.schema.loc\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_params.maxlat}}\pysigline{\sphinxbfcode{\sphinxupquote{maxlat}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{maxlon (infrapy.database.schema.loc\_params attribute)@\spxentry{maxlon}\spxextra{infrapy.database.schema.loc\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_params.maxlon}}\pysigline{\sphinxbfcode{\sphinxupquote{maxlon}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{minlat (infrapy.database.schema.loc\_params attribute)@\spxentry{minlat}\spxextra{infrapy.database.schema.loc\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_params.minlat}}\pysigline{\sphinxbfcode{\sphinxupquote{minlat}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{minlon (infrapy.database.schema.loc\_params attribute)@\spxentry{minlon}\spxextra{infrapy.database.schema.loc\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_params.minlon}}\pysigline{\sphinxbfcode{\sphinxupquote{minlon}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{name (infrapy.database.schema.loc\_params attribute)@\spxentry{name}\spxextra{infrapy.database.schema.loc\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_params.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{plocid (infrapy.database.schema.loc\_params attribute)@\spxentry{plocid}\spxextra{infrapy.database.schema.loc\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_params.plocid}}\pysigline{\sphinxbfcode{\sphinxupquote{plocid}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{priors (infrapy.database.schema.loc\_params attribute)@\spxentry{priors}\spxextra{infrapy.database.schema.loc\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_params.priors}}\pysigline{\sphinxbfcode{\sphinxupquote{priors}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}


\end{fulllineitems}

\index{loc\_results (class in infrapy.database.schema)@\spxentry{loc\_results}\spxextra{class in infrapy.database.schema}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{infrapy.database.schema.}}\sphinxbfcode{\sphinxupquote{loc\_results}}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{\sphinxupquote{pisces.schema.util.Base}}
\index{additional1 (infrapy.database.schema.loc\_results attribute)@\spxentry{additional1}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.additional1}}\pysigline{\sphinxbfcode{\sphinxupquote{additional1}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{additional2 (infrapy.database.schema.loc\_results attribute)@\spxentry{additional2}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.additional2}}\pysigline{\sphinxbfcode{\sphinxupquote{additional2}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{additional3 (infrapy.database.schema.loc\_results attribute)@\spxentry{additional3}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.additional3}}\pysigline{\sphinxbfcode{\sphinxupquote{additional3}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{additional4 (infrapy.database.schema.loc\_results attribute)@\spxentry{additional4}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.additional4}}\pysigline{\sphinxbfcode{\sphinxupquote{additional4}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{eventid (infrapy.database.schema.loc\_results attribute)@\spxentry{eventid}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.eventid}}\pysigline{\sphinxbfcode{\sphinxupquote{eventid}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{from\_string() (infrapy.database.schema.loc\_results class method)@\spxentry{from\_string()}\spxextra{infrapy.database.schema.loc\_results class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.from_string}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{from\_string}}}{\emph{line}, \emph{default\_on\_error=None}}{}
Construct a mapped table instance from correctly formatted flat file line.

Works with fixed\sphinxhyphen{}length fields, separated by a single whitespace.
\begin{description}
\item[{line: str}] \leavevmode
Flat file line (best to remove newline, but maybe not a problem).

\item[{default\_on\_error: list, optional}] \leavevmode
Supply a list of column names that return default values if they
produce an error during parsing (e.g. lddate).

\end{description}

ValueError:  Can’t properly parse the line.

default\_on\_error is useful for malformed fields, but it will also mask
other problems with line parsing. It’s better to pre\sphinxhyphen{}process tables 
to match the table specifications or catch exceptions and isolate 
these lines.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TA.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{ffsite}\PYG{p}{:}
\PYG{g+go}{        for line in ffsite:}
\PYG{g+go}{            isite = Site.from\PYGZus{}string(line)}
\PYG{g+go}{or}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TA.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{ffsite}\PYG{p}{:}
\PYG{g+go}{        for line in ffsite:}
\PYG{g+go}{            isite = Site.from\PYGZus{}string(line, default\PYGZus{}on\PYGZus{}error=[\PYGZsq{}lddate\PYGZsq{}])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{latlonorigcovar (infrapy.database.schema.loc\_results attribute)@\spxentry{latlonorigcovar}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.latlonorigcovar}}\pysigline{\sphinxbfcode{\sphinxupquote{latlonorigcovar}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{latorigmap (infrapy.database.schema.loc\_results attribute)@\spxentry{latorigmap}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.latorigmap}}\pysigline{\sphinxbfcode{\sphinxupquote{latorigmap}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{latorigmean (infrapy.database.schema.loc\_results attribute)@\spxentry{latorigmean}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.latorigmean}}\pysigline{\sphinxbfcode{\sphinxupquote{latorigmean}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{latorigvar (infrapy.database.schema.loc\_results attribute)@\spxentry{latorigvar}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.latorigvar}}\pysigline{\sphinxbfcode{\sphinxupquote{latorigvar}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{locid (infrapy.database.schema.loc\_results attribute)@\spxentry{locid}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.locid}}\pysigline{\sphinxbfcode{\sphinxupquote{locid}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{lonorigmap (infrapy.database.schema.loc\_results attribute)@\spxentry{lonorigmap}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.lonorigmap}}\pysigline{\sphinxbfcode{\sphinxupquote{lonorigmap}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{lonorigmean (infrapy.database.schema.loc\_results attribute)@\spxentry{lonorigmean}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.lonorigmean}}\pysigline{\sphinxbfcode{\sphinxupquote{lonorigmean}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{lonorigvar (infrapy.database.schema.loc\_results attribute)@\spxentry{lonorigvar}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.lonorigvar}}\pysigline{\sphinxbfcode{\sphinxupquote{lonorigvar}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{net (infrapy.database.schema.loc\_results attribute)@\spxentry{net}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.net}}\pysigline{\sphinxbfcode{\sphinxupquote{net}}\sphinxbfcode{\sphinxupquote{ = Column(None, String(length=8), table=None)}}}
\end{fulllineitems}

\index{numstations (infrapy.database.schema.loc\_results attribute)@\spxentry{numstations}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.numstations}}\pysigline{\sphinxbfcode{\sphinxupquote{numstations}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{par\_a (infrapy.database.schema.loc\_results attribute)@\spxentry{par\_a}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.par_a}}\pysigline{\sphinxbfcode{\sphinxupquote{par\_a}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{par\_b (infrapy.database.schema.loc\_results attribute)@\spxentry{par\_b}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.par_b}}\pysigline{\sphinxbfcode{\sphinxupquote{par\_b}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{par\_theta (infrapy.database.schema.loc\_results attribute)@\spxentry{par\_theta}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.par_theta}}\pysigline{\sphinxbfcode{\sphinxupquote{par\_theta}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{plocid (infrapy.database.schema.loc\_results attribute)@\spxentry{plocid}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.plocid}}\pysigline{\sphinxbfcode{\sphinxupquote{plocid}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{timeend (infrapy.database.schema.loc\_results attribute)@\spxentry{timeend}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.timeend}}\pysigline{\sphinxbfcode{\sphinxupquote{timeend}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{timeini (infrapy.database.schema.loc\_results attribute)@\spxentry{timeini}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.timeini}}\pysigline{\sphinxbfcode{\sphinxupquote{timeini}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{timeorigmap (infrapy.database.schema.loc\_results attribute)@\spxentry{timeorigmap}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.timeorigmap}}\pysigline{\sphinxbfcode{\sphinxupquote{timeorigmap}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{timeorigmax (infrapy.database.schema.loc\_results attribute)@\spxentry{timeorigmax}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.timeorigmax}}\pysigline{\sphinxbfcode{\sphinxupquote{timeorigmax}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{timeorigmean (infrapy.database.schema.loc\_results attribute)@\spxentry{timeorigmean}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.timeorigmean}}\pysigline{\sphinxbfcode{\sphinxupquote{timeorigmean}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{timeorigmin (infrapy.database.schema.loc\_results attribute)@\spxentry{timeorigmin}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.timeorigmin}}\pysigline{\sphinxbfcode{\sphinxupquote{timeorigmin}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{timeorigvar (infrapy.database.schema.loc\_results attribute)@\spxentry{timeorigvar}\spxextra{infrapy.database.schema.loc\_results attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.loc_results.timeorigvar}}\pysigline{\sphinxbfcode{\sphinxupquote{timeorigvar}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}


\end{fulllineitems}

\index{noise\_params (class in infrapy.database.schema)@\spxentry{noise\_params}\spxextra{class in infrapy.database.schema}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.noise_params}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{infrapy.database.schema.}}\sphinxbfcode{\sphinxupquote{noise\_params}}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{\sphinxupquote{pisces.schema.util.Base}}
\index{algorithm (infrapy.database.schema.noise\_params attribute)@\spxentry{algorithm}\spxextra{infrapy.database.schema.noise\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.noise_params.algorithm}}\pysigline{\sphinxbfcode{\sphinxupquote{algorithm}}\sphinxbfcode{\sphinxupquote{ = Column(None, String(length=15), table=None)}}}
\end{fulllineitems}

\index{filterh (infrapy.database.schema.noise\_params attribute)@\spxentry{filterh}\spxextra{infrapy.database.schema.noise\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.noise_params.filterh}}\pysigline{\sphinxbfcode{\sphinxupquote{filterh}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{filterl (infrapy.database.schema.noise\_params attribute)@\spxentry{filterl}\spxextra{infrapy.database.schema.noise\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.noise_params.filterl}}\pysigline{\sphinxbfcode{\sphinxupquote{filterl}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=24), table=None)}}}
\end{fulllineitems}

\index{filtertype (infrapy.database.schema.noise\_params attribute)@\spxentry{filtertype}\spxextra{infrapy.database.schema.noise\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.noise_params.filtertype}}\pysigline{\sphinxbfcode{\sphinxupquote{filtertype}}\sphinxbfcode{\sphinxupquote{ = Column(None, String(length=15), table=None)}}}
\end{fulllineitems}

\index{from\_string() (infrapy.database.schema.noise\_params class method)@\spxentry{from\_string()}\spxextra{infrapy.database.schema.noise\_params class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.noise_params.from_string}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{from\_string}}}{\emph{line}, \emph{default\_on\_error=None}}{}
Construct a mapped table instance from correctly formatted flat file line.

Works with fixed\sphinxhyphen{}length fields, separated by a single whitespace.
\begin{description}
\item[{line: str}] \leavevmode
Flat file line (best to remove newline, but maybe not a problem).

\item[{default\_on\_error: list, optional}] \leavevmode
Supply a list of column names that return default values if they
produce an error during parsing (e.g. lddate).

\end{description}

ValueError:  Can’t properly parse the line.

default\_on\_error is useful for malformed fields, but it will also mask
other problems with line parsing. It’s better to pre\sphinxhyphen{}process tables 
to match the table specifications or catch exceptions and isolate 
these lines.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TA.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{ffsite}\PYG{p}{:}
\PYG{g+go}{        for line in ffsite:}
\PYG{g+go}{            isite = Site.from\PYGZus{}string(line)}
\PYG{g+go}{or}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TA.site}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{ffsite}\PYG{p}{:}
\PYG{g+go}{        for line in ffsite:}
\PYG{g+go}{            isite = Site.from\PYGZus{}string(line, default\PYGZus{}on\PYGZus{}error=[\PYGZsq{}lddate\PYGZsq{}])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{n\_octave (infrapy.database.schema.noise\_params attribute)@\spxentry{n\_octave}\spxextra{infrapy.database.schema.noise\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.noise_params.n_octave}}\pysigline{\sphinxbfcode{\sphinxupquote{n\_octave}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{name (infrapy.database.schema.noise\_params attribute)@\spxentry{name}\spxextra{infrapy.database.schema.noise\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.noise_params.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}

\index{overlapwlen (infrapy.database.schema.noise\_params attribute)@\spxentry{overlapwlen}\spxextra{infrapy.database.schema.noise\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.noise_params.overlapwlen}}\pysigline{\sphinxbfcode{\sphinxupquote{overlapwlen}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{pnoiseid (infrapy.database.schema.noise\_params attribute)@\spxentry{pnoiseid}\spxextra{infrapy.database.schema.noise\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.noise_params.pnoiseid}}\pysigline{\sphinxbfcode{\sphinxupquote{pnoiseid}}\sphinxbfcode{\sphinxupquote{ = Column(None, Integer(), table=None)}}}
\end{fulllineitems}

\index{wlen (infrapy.database.schema.noise\_params attribute)@\spxentry{wlen}\spxextra{infrapy.database.schema.noise\_params attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.database:infrapy.database.schema.noise_params.wlen}}\pysigline{\sphinxbfcode{\sphinxupquote{wlen}}\sphinxbfcode{\sphinxupquote{ = Column(None, Float(precision=53), table=None)}}}
\end{fulllineitems}


\end{fulllineitems}



\subsection{Beamforming/Detection}
\label{\detokenize{infrapy.detection:beamforming-detection}}\label{\detokenize{infrapy.detection::doc}}

\subsubsection{Beamforming}
\label{\detokenize{infrapy.detection:module-infrapy.detection.beamforming}}\label{\detokenize{infrapy.detection:beamforming}}\index{infrapy.detection.beamforming (module)@\spxentry{infrapy.detection.beamforming}\spxextra{module}}\index{AIC() (in module infrapy.detection.beamforming)@\spxentry{AIC()}\spxextra{in module infrapy.detection.beamforming}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming.AIC}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming.}}\sphinxbfcode{\sphinxupquote{AIC}}}{\emph{eigenV}, \emph{n}, \emph{m}}{}
\end{fulllineitems}

\index{MDL() (in module infrapy.detection.beamforming)@\spxentry{MDL()}\spxextra{in module infrapy.detection.beamforming}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming.MDL}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming.}}\sphinxbfcode{\sphinxupquote{MDL}}}{\emph{eigenV}, \emph{n}, \emph{m}}{}
\end{fulllineitems}

\index{bfstat() (in module infrapy.detection.beamforming)@\spxentry{bfstat()}\spxextra{in module infrapy.detection.beamforming}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming.bfstat}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming.}}\sphinxbfcode{\sphinxupquote{bfstat}}}{\emph{beam}}{}
Returns the F\sphinxhyphen{}statistic using the formalism of Blandford (1974) for a particular window
(FK sliding window)

Inputs:
\sphinxhyphen{} beam is the time\sphinxhyphen{}aligned waveform in a particular window (FK sliding window)

Outputs:
\sphinxhyphen{} F is the Blandford F\sphinxhyphen{}statistic

\end{fulllineitems}

\index{bfstat2() (in module infrapy.detection.beamforming)@\spxentry{bfstat2()}\spxextra{in module infrapy.detection.beamforming}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming.bfstat2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming.}}\sphinxbfcode{\sphinxupquote{bfstat2}}}{\emph{beam}}{}
Returns the F\sphinxhyphen{}statistic using the formalism of Blandford (1974) for a particular window
(FK sliding window)

Inputs:
\sphinxhyphen{} beam is the time\sphinxhyphen{}aligned waveform in a particular window (FK sliding window)

Outputs:
\sphinxhyphen{} F is the Blandford F\sphinxhyphen{}statistic

\end{fulllineitems}

\index{bfstatT() (in module infrapy.detection.beamforming)@\spxentry{bfstatT()}\spxextra{in module infrapy.detection.beamforming}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming.bfstatT}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming.}}\sphinxbfcode{\sphinxupquote{bfstatT}}}{\emph{beam}}{}
Returns the F\sphinxhyphen{}statistic using the formalism of Blandford (1974) for a particular window
(FK sliding window)

Inputs:
\sphinxhyphen{} beam is the time\sphinxhyphen{}aligned waveform in a particular window (FK sliding window)

Outputs:
\sphinxhyphen{} F is the Blandford F\sphinxhyphen{}statistic

\end{fulllineitems}

\index{corrp() (in module infrapy.detection.beamforming)@\spxentry{corrp()}\spxextra{in module infrapy.detection.beamforming}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming.corrp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming.}}\sphinxbfcode{\sphinxupquote{corrp}}}{\emph{beam}}{}
Computes the maximum average cross correlation from all triplets of elements in an
array for a particular window (FK sliding window)

Inputs:
\sphinxhyphen{} beam is the time\sphinxhyphen{}aligned waveform in a particular window (FK sliding\sphinxhyphen{}window)

Outputs:
\sphinxhyphen{} C is the minimum, maximum, mean average cross\sphinxhyphen{}correlation

\end{fulllineitems}

\index{corrpT() (in module infrapy.detection.beamforming)@\spxentry{corrpT()}\spxextra{in module infrapy.detection.beamforming}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming.corrpT}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming.}}\sphinxbfcode{\sphinxupquote{corrpT}}}{\emph{beam}}{}
Computes the maximum average cross correlation from all triplets of elements in an
array for a particular window (FK sliding window)

Inputs:
\sphinxhyphen{} beam is the time\sphinxhyphen{}aligned waveform in a particular window (FK sliding\sphinxhyphen{}window)

Outputs:
\sphinxhyphen{} C is the minimum, maximum, mean average cross\sphinxhyphen{}correlation

\end{fulllineitems}

\index{detect\_peaks() (in module infrapy.detection.beamforming)@\spxentry{detect\_peaks()}\spxextra{in module infrapy.detection.beamforming}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming.detect_peaks}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming.}}\sphinxbfcode{\sphinxupquote{detect\_peaks}}}{\emph{image}, \emph{size=3}, \emph{num\_peaks=None}}{}
Takes an image and detect the peaks using the local maximum filter.
Returns a boolean mask of the peaks (i.e. 1 when
the pixel’s value is the neighborhood maximum, 0 otherwise)

\end{fulllineitems}

\index{dist\_az() (in module infrapy.detection.beamforming)@\spxentry{dist\_az()}\spxextra{in module infrapy.detection.beamforming}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming.dist_az}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming.}}\sphinxbfcode{\sphinxupquote{dist\_az}}}{\emph{X1}, \emph{X2}}{}
Returns the angular distance and direction between two locations

\end{fulllineitems}

\index{fkPROC() (in module infrapy.detection.beamforming)@\spxentry{fkPROC()}\spxextra{in module infrapy.detection.beamforming}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming.fkPROC}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming.}}\sphinxbfcode{\sphinxupquote{fkPROC}}}{\emph{method}, \emph{stream}, \emph{sps}, \emph{slow}, \emph{mult\_vectors}, \emph{fN}, \emph{x}, \emph{y}, \emph{timeSTAMP}, \emph{func}, \emph{freqN}, \emph{aux}, \emph{num\_sources=None}}{}
\end{fulllineitems}

\index{fkfromOStream() (in module infrapy.detection.beamforming)@\spxentry{fkfromOStream()}\spxextra{in module infrapy.detection.beamforming}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming.fkfromOStream}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming.}}\sphinxbfcode{\sphinxupquote{fkfromOStream}}}{\emph{St}, \emph{wlen}, \emph{overlap}, \emph{freqmin}, \emph{freqmax}, \emph{slow=None}}{}
\end{fulllineitems}

\index{getXY\_array() (in module infrapy.detection.beamforming)@\spxentry{getXY\_array()}\spxextra{in module infrapy.detection.beamforming}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming.getXY_array}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming.}}\sphinxbfcode{\sphinxupquote{getXY\_array}}}{\emph{stream}}{}
Returns the site coordinates for a specific array in the format required
by fk

\end{fulllineitems}

\index{procPEAKS() (in module infrapy.detection.beamforming)@\spxentry{procPEAKS()}\spxextra{in module infrapy.detection.beamforming}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming.procPEAKS}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming.}}\sphinxbfcode{\sphinxupquote{procPEAKS}}}{\emph{peaks}, \emph{slow}}{}
\end{fulllineitems}

\index{svdAV\_wv() (in module infrapy.detection.beamforming)@\spxentry{svdAV\_wv()}\spxextra{in module infrapy.detection.beamforming}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming.svdAV_wv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming.}}\sphinxbfcode{\sphinxupquote{svdAV\_wv}}}{\emph{stream}, \emph{sps}, \emph{slow}, \emph{mult\_vectors}, \emph{fN}, \emph{x}, \emph{y}, \emph{timeSTAMP}, \emph{func}, \emph{freqN}, \emph{number\_div=None}}{}
\end{fulllineitems}

\index{tapering() (in module infrapy.detection.beamforming)@\spxentry{tapering()}\spxextra{in module infrapy.detection.beamforming}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming.tapering}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming.}}\sphinxbfcode{\sphinxupquote{tapering}}}{\emph{st\_aux}}{}
\end{fulllineitems}

\index{tdelay() (in module infrapy.detection.beamforming)@\spxentry{tdelay()}\spxextra{in module infrapy.detection.beamforming}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming.tdelay}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming.}}\sphinxbfcode{\sphinxupquote{tdelay}}}{\emph{data}, \emph{sps}, \emph{bazimuth}, \emph{slowness}, \emph{x}, \emph{y}}{}
Returns the time\sphinxhyphen{}delay\sphinxhyphen{}and\sphinxhyphen{}sum beam of data for a particular window (FK sliding window)

Inputs:
\sphinxhyphen{} data is the non\sphinxhyphen{}time\sphinxhyphen{}aligned waveform in a particular window (FK sliding window), this may be already in real values
\sphinxhyphen{} samprate is the sampling rate
\sphinxhyphen{} x is the array of x coordinates
\sphinxhyphen{} y is the array of y coordinates
\sphinxhyphen{} azimuth is the azimuth for calculating the beam
\sphinxhyphen{} slowness is the slowness for calculating the beam

Outputs:
\sphinxhyphen{} beam is the time\sphinxhyphen{}aligned waveform in a particular window (FK sliding window)

\end{fulllineitems}

\index{tdelayT() (in module infrapy.detection.beamforming)@\spxentry{tdelayT()}\spxextra{in module infrapy.detection.beamforming}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming.tdelayT}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming.}}\sphinxbfcode{\sphinxupquote{tdelayT}}}{\emph{data}, \emph{sps}, \emph{bazimuth}, \emph{slowness}, \emph{x}, \emph{y}, \emph{slowx}, \emph{slowy}}{}
Returns the time\sphinxhyphen{}delay\sphinxhyphen{}and\sphinxhyphen{}sum beam of data for a particular window (FK sliding window)

Inputs:
\sphinxhyphen{} data is the non\sphinxhyphen{}time\sphinxhyphen{}aligned waveform in a particular window (FK sliding window), this may be already in real values
\sphinxhyphen{} samprate is the sampling rate
\sphinxhyphen{} x is the array of x coordinates
\sphinxhyphen{} y is the array of y coordinates
\sphinxhyphen{} azimuth is the azimuth for calculating the beam
\sphinxhyphen{} slowness is the slowness for calculating the beam

Outputs:
\sphinxhyphen{} beam is the time\sphinxhyphen{}aligned waveform in a particular window (FK sliding window)

\end{fulllineitems}

\index{xcorr\_beam() (in module infrapy.detection.beamforming)@\spxentry{xcorr\_beam()}\spxextra{in module infrapy.detection.beamforming}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming.xcorr_beam}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming.}}\sphinxbfcode{\sphinxupquote{xcorr\_beam}}}{\emph{dat\_st}}{}
\end{fulllineitems}



\subsubsection{Beamforming\_new}
\label{\detokenize{infrapy.detection:module-infrapy.detection.beamforming_new}}\label{\detokenize{infrapy.detection:beamforming-new}}\index{infrapy.detection.beamforming\_new (module)@\spxentry{infrapy.detection.beamforming\_new}\spxextra{module}}
infrapy.detection.beamforming\_new.py

Methods for reading in time series data, analyzing
it, and identifying infrasonic signals using various
beamforming methods.

Author            Philip Blom (\sphinxhref{mailto:pblom@lanl.gov}{pblom@lanl.gov})
\index{build\_slowness() (in module infrapy.detection.beamforming\_new)@\spxentry{build\_slowness()}\spxextra{in module infrapy.detection.beamforming\_new}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming_new.build_slowness}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming\_new.}}\sphinxbfcode{\sphinxupquote{build\_slowness}}}{\emph{back\_azs}, \emph{trc\_vels}}{}
Compute the slowness values for a polar grid

Computes the slowness grid usingg a polar grid defined by a series of back azimuth
values and trave velocity values.  Returns a grid specified such that grid{[}n{]} is
the x and y component of the nth slowness vector.
\begin{description}
\item[{back\_azs}] \leavevmode{[}1darray{]}
Back azimuth values for slowness grid, K\_1 values

\item[{trc\_vels}] \leavevmode{[}1darray{]}
Trace velocity values for slowness grid K\_2 values

\end{description}
\begin{description}
\item[{grid}] \leavevmode{[}2darray{]}
(K\_1 x K\_2) by 2 array of slowness vectors

\end{description}

\end{fulllineitems}

\index{calc\_det\_thresh() (in module infrapy.detection.beamforming\_new)@\spxentry{calc\_det\_thresh()}\spxextra{in module infrapy.detection.beamforming\_new}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming_new.calc_det_thresh}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming\_new.}}\sphinxbfcode{\sphinxupquote{calc\_det\_thresh}}}{\emph{fstat\_vals}, \emph{det\_thresh}, \emph{TB\_prod}, \emph{channel\_cnt}}{}
\end{fulllineitems}

\index{compute\_beam\_power() (in module infrapy.detection.beamforming\_new)@\spxentry{compute\_beam\_power()}\spxextra{in module infrapy.detection.beamforming\_new}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming_new.compute_beam_power}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming\_new.}}\sphinxbfcode{\sphinxupquote{compute\_beam\_power}}}{\emph{data}, \emph{steering}, \emph{method=\textquotesingle{}bartlett\textquotesingle{}}, \emph{ns\_covar\_inv=None}, \emph{signal\_cnt=1}}{}
Compute the beampower for a specific frequency

Cmoputes the beampower at a single frequency using either the FFT’d data, X(f),
for Bartlett or GLS analysis or the covariance matrix, S(f), for Capon and MUSIC.

Generalized Least Square (GLS) analysis requires a noise covariance for the
background which must be M x M where M is the length of X(f).

MUltiple SIgnal Classification (MUSIC) analysis requires knowledge of the number
of coherent signals in the data specified as signal\_cnt.
\begin{description}
\item[{data}] \leavevmode{[}ndarray{]}
Vector of length M, X\_m(f\_n), for “bartlett” and “gls” or matrix of
dimension M x M, S(f\_n), for covariance based methods

\item[{steering}] \leavevmode{[}2darray{]}
Matrix representing K steering vectors each of length K

\item[{method}] \leavevmode{[}str{]}
Beamforming method to be applied to the data (must match
for of data)

\item[{ns\_covar\_inv}] \leavevmode{[}2darray{]}
Noise covariance used in “gls” beamforming method

\item[{signal\_cnt}] \leavevmode{[}int{]}
Number of signals assumed in MUSIC algorithm

\end{description}
\begin{description}
\item[{beam\_power}] \leavevmode{[}1darray{]}
Beam power for each steering vector (length K)

\end{description}

\end{fulllineitems}

\index{compute\_beam\_power\_wrapper() (in module infrapy.detection.beamforming\_new)@\spxentry{compute\_beam\_power\_wrapper()}\spxextra{in module infrapy.detection.beamforming\_new}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming_new.compute_beam_power_wrapper}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming\_new.}}\sphinxbfcode{\sphinxupquote{compute\_beam\_power\_wrapper}}}{\emph{args}}{}
\end{fulllineitems}

\index{compute\_delays() (in module infrapy.detection.beamforming\_new)@\spxentry{compute\_delays()}\spxextra{in module infrapy.detection.beamforming\_new}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming_new.compute_delays}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming\_new.}}\sphinxbfcode{\sphinxupquote{compute\_delays}}}{\emph{dxdy}, \emph{param\_grid}, \emph{param\_opt=\textquotesingle{}planar\textquotesingle{}}, \emph{sph\_vel=340.0}, \emph{sph\_src\_ht=0.0}}{}
Compute the delays for a planewave

Computes the time delays for each pair in param\_grid given the
array geometry in dxdy.  For planar parameterization, grid
specifies s\_x and s\_y of the slowness.  For spherical
parameterization, it specifies the x,y location of the source
and requires specification of the velocity of the wavefront.

For the slowness grid, use the build\_slowness function to
convert back azimuth and trace velocity values into a grid.
Use np.meshgrid and flatten to produce a grid for the
spherical wavefront source grid.
\begin{description}
\item[{dxdy}] \leavevmode{[}2darray{]}
M x 2 matrix describing the array geometry

\item[{param\_grid}] \leavevmode{[}2darray{]}
K x 2 matrix of parameterization vectors containing
either the slowness components (for ‘planar’) or
the source location (for ‘spherical’)

\end{description}
\begin{description}
\item[{delays}] \leavevmode{[}2darray{]}
K x M of time delays across the array for each slowness

\end{description}

\end{fulllineitems}

\index{detect\_signals() (in module infrapy.detection.beamforming\_new)@\spxentry{detect\_signals()}\spxextra{in module infrapy.detection.beamforming\_new}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming_new.detect_signals}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming\_new.}}\sphinxbfcode{\sphinxupquote{detect\_signals}}}{\emph{times}, \emph{beam\_results}, \emph{win\_len}, \emph{TB\_prod}, \emph{channel\_cnt}, \emph{det\_thresh=0.99}, \emph{min\_seq=5}, \emph{back\_az\_lim=15}, \emph{fixed\_thresh=None}}{}
Identify detections with beamforming results

Identify detection in the beamforming results using either Kernel Density
Estimate (KDE) fits to the f\sphinxhyphen{}statistic distribution or the adaptive
F\sphinxhyphen{}detector methods developed by Arrowsmith.
\begin{description}
\item[{times}] \leavevmode{[}1darray{]}
Times of beamforming results as numpy datetime64’s

\item[{beam\_results}] \leavevmode{[}2darray{]}
Beamforming results consisting of back azimuth, trace velocity, and
f\sphinxhyphen{}value at each time step. This is a 2D array with dimensions (len(times), 3), 
where the first column has back azimuth values, the second has trace velocity 
values, and the third has f\sphinxhyphen{}statistic values

\item[{win\_len}] \leavevmode{[}float{]}
Window length to define the adaptive fstat threshold

\item[{TB\_prod}] \leavevmode{[}int{]}
Time\sphinxhyphen{}bandwidth product needed to compute the Fisher statistic

\item[{channel\_cnt}] \leavevmode{[}int{]}
Number of channels on the array; needed to compute the Fisher statistic

\item[{det\_thresh}] \leavevmode{[}float{]}
Threshold for declaring a detection

\item[{min\_seq}] \leavevmode{[}int{]}
Threshold for the number of sequential above\sphinxhyphen{}threshold values to declare
a detection

\item[{back\_az\_lim}] \leavevmode{[}float{]}
Threshold below which the maximum separation of back azimuths must be
in order to declare a detection

\item[{fixed\_thresh}] \leavevmode{[}float{]}\begin{description}
\item[{A fixed detection threshold for fstat values (overrides adaptive }] \leavevmode
threshold calculation)

\end{description}

\end{description}
\begin{description}
\item[{dets}] \leavevmode{[}list{]}
List of identified detections including detection time, relative start
and end times of the detection, back azimuth, trace velocity, and f\sphinxhyphen{}stat.

\end{description}

\end{fulllineitems}

\index{extract\_signal() (in module infrapy.detection.beamforming\_new)@\spxentry{extract\_signal()}\spxextra{in module infrapy.detection.beamforming\_new}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming_new.extract_signal}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming\_new.}}\sphinxbfcode{\sphinxupquote{extract\_signal}}}{\emph{X}, \emph{f}, \emph{slowness}, \emph{dxdy}}{}
Extract the signal along the beam for a given slowness vector

Extract the “best beam” signal from the array data for a given slowness pair and
array geometry.  Returns both the extracted signal and the residual on each trace
of the array
\begin{description}
\item[{Note: following Laslo’s work, the frequency domain Fisher ratio can be computed as:}] \leavevmode
F{[}nf{]} = abs(sig\_est)**2 / np.mean(np.abs(residual), axis=1)**2 * (X.shape{[}1{]} \sphinxhyphen{} 1)

\end{description}
\begin{description}
\item[{f}] \leavevmode{[}1darray{]}
Frequencies

\item[{X}] \leavevmode{[}2darray{]}
FFT of data in analysis window, x(t) \textendash{}\textgreater{} X(f)

\item[{slowness}] \leavevmode{[}2darray{]}
Slowness components (either back azimuth and trace velocity or
s\_x and s\_y depending on slowness option)

\item[{dxdy}] \leavevmode{[}2darray{]}
Array geometry

\end{description}
\begin{description}
\item[{sig\_estimate}] \leavevmode{[}1darray{]}
Extracted frequency domain signal along the beam

\item[{residual}] \leavevmode{[}2darray{]}
Residual across the array once beamed signal is extracted

\end{description}

\end{fulllineitems}

\index{fft\_array\_data() (in module infrapy.detection.beamforming\_new)@\spxentry{fft\_array\_data()}\spxextra{in module infrapy.detection.beamforming\_new}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming_new.fft_array_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming\_new.}}\sphinxbfcode{\sphinxupquote{fft\_array\_data}}}{\emph{x}, \emph{t}, \emph{window=None}, \emph{sub\_window\_len=None}, \emph{sub\_window\_overlap=0.5}, \emph{fft\_window=\textquotesingle{}hanning\textquotesingle{}}, \emph{normalize\_windowing=False}}{}
Compute the Fourier transform of the array data to perform analysis

Compute the Fourier transform of the array data within an analysis window defined by window = {[}t1, t2{]}
and potentially using subwindows to obtain a full rank covariance matrix for beamforming analyses
requiring such data.  Multiple FFT window options are available and a normalization option scales to
account for the amplitude loss at the window edges.
\begin{description}
\item[{x}] \leavevmode{[}2darray{]}
M x N matrix of array data, x{[}m{]}{[}n{]} = x\_m(t\_n)

\item[{t}] \leavevmode{[}1darray{]}
Vector of N sampled points in time, t{[}n{]} = t\_n

\item[{window}] \leavevmode{[}float{]}
Start and end time of the window relative to times in t, {[}t\_1, t\_2{]}

\item[{sub\_window\_len}] \leavevmode{[}float{]}
Duration of the subwindow in seconds

\item[{sub\_window\_overlap}] \leavevmode{[}float{]}
Fraction of subwindow to overlap (limited range of 0.0 to 0.9)

\item[{fft\_window}] \leavevmode{[}str{]}
Fourier windowing method

\item[{normalize\_windowing}] \leavevmode{[}boolean{]}
Boolean to apply normalization of window scaling

\end{description}
\begin{description}
\item[{X}] \leavevmode{[}2darray{]}
M x N\_f matrix of the FFT’d data, X{[}m{]}{[}n{]} = X\_m(f\_n)

\item[{S}] \leavevmode{[}3darray{]}
M x M x N\_f cube of the covariance matrices, S{[}m1{]}{[}m2{]}{[}n{]} = mean(X\_\{m1\}(f\_n) conj(X\_\{m2\}(f\_n)))

\item[{f}] \leavevmode{[}1darray{]}
Vector of N\_f frequencies for the FFT’d data, f{[}n{]} = f\_n

\end{description}

\end{fulllineitems}

\index{find\_peaks() (in module infrapy.detection.beamforming\_new)@\spxentry{find\_peaks()}\spxextra{in module infrapy.detection.beamforming\_new}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming_new.find_peaks}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming\_new.}}\sphinxbfcode{\sphinxupquote{find\_peaks}}}{\emph{beam\_power}, \emph{slowness\_vals1}, \emph{slowness\_vals2}, \emph{signal\_cnt=1}, \emph{freq\_weights=None}}{}
Identify the peak(s) in the beampower defined over a slowness grid

Finds the peaks of a distribution using a frequency averaged beamforming result
over a defined slowness grid.
\begin{description}
\item[{beam\_power}] \leavevmode{[}2darray{]}
Beam power for each steering vector at each frequency in the
band (dimension K x N\_f)

\item[{slowness\_vals1}] \leavevmode{[}1darray{]}
Slowness values along first axis (polar or Cartesian grid)

\item[{slowness\_vals2}] \leavevmode{[}1darray{]}
Slowness values along second axis (polar or Cartesian grid)

\item[{signal\_cnt}] \leavevmode{[}int{]}
Number of signals to identify in the slowness grid

\item[{freq\_weights}] \leavevmode{[}string or 1darray{]}
Weights or method to use in frequency averaging of the beam power

\end{description}
\begin{description}
\item[{peaks}] \leavevmode{[}ndarray{]}
signal\_cnt x 3 array of the peaks identified containing slowness
value 1 (back azimuth), slowness value 2 (trace velocity),
and beam value

\end{description}

\end{fulllineitems}

\index{project\_ABA (in module infrapy.detection.beamforming\_new)@\spxentry{project\_ABA}\spxextra{in module infrapy.detection.beamforming\_new}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming_new.project_ABA}}\pysigline{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming\_new.}}\sphinxbfcode{\sphinxupquote{project\_ABA}}}
Project matrix of K vectors, a\_k, onto Hermitian matrix B
\begin{quote}

Projects each of K vectors, a\_k, in matrix, A, of dimension K x M
onto a Hermitian matrix, B, of dimension M x M producing a
vector of scalars, c, of length K
\begin{description}
\item[{A}] \leavevmode{[}2darray{]}
K x M matrix representing a set of K vectors, a\_k, each of length M

\item[{B}] \leavevmode{[}2darray{]}
M x M Hermitian matrix

\end{description}
\begin{description}
\item[{c}] \leavevmode{[}1darray{]}
Vector c where each scalar c\_k = a\_k\textasciicircum{}dagger B a\_k

\end{description}
\end{quote}

\end{fulllineitems}

\index{project\_ABc (in module infrapy.detection.beamforming\_new)@\spxentry{project\_ABc}\spxextra{in module infrapy.detection.beamforming\_new}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming_new.project_ABc}}\pysigline{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming\_new.}}\sphinxbfcode{\sphinxupquote{project\_ABc}}}
Project matrix of K vectors, a\_k, through Hermitian matrix B and onto vector c

Projects each of K vectors, a\_k, in matrix, A, of dimension K x M
through a Hermitian matrix, B, of dimension M x M and onto a vector,
c, producing a vector of scalars, d, of length K
\begin{description}
\item[{A}] \leavevmode{[}2darray{]}
K x M matrix representing a set of K vectors, a\_k, each of length M

\item[{B}] \leavevmode{[}2darray{]}
M x M Hermitian matrix

\item[{c}] \leavevmode{[}1darray{]}
Vector of length M

\end{description}
\begin{description}
\item[{d}] \leavevmode{[}1darray{]}
Vector d where each scalar d\_k = a\_k\textasciicircum{}dagger B c

\end{description}

\end{fulllineitems}

\index{project\_Ab (in module infrapy.detection.beamforming\_new)@\spxentry{project\_Ab}\spxextra{in module infrapy.detection.beamforming\_new}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming_new.project_Ab}}\pysigline{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming\_new.}}\sphinxbfcode{\sphinxupquote{project\_Ab}}}
Project matrix of K vectors, a\_k, onto a vector b

Projects a vector, b, of length M onto a set of K vectors, a\_k,
each of length M producing a vector, c, of length K
\begin{description}
\item[{A}] \leavevmode{[}2darray{]}
K x M matrix representing a set of K vectors, a\_k, each of length M

\item[{b}] \leavevmode{[}1darray{]}
Vector of length M to project onto each a\_k

\end{description}
\begin{description}
\item[{c}] \leavevmode{[}1darray{]}
Vector c where each scalar c\_k = a\_k\textasciicircum{}dagger b

\end{description}

\end{fulllineitems}

\index{project\_beam() (in module infrapy.detection.beamforming\_new)@\spxentry{project\_beam()}\spxextra{in module infrapy.detection.beamforming\_new}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming_new.project_beam}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming\_new.}}\sphinxbfcode{\sphinxupquote{project\_beam}}}{\emph{beam\_power}, \emph{back\_az\_vals}, \emph{trc\_vel\_vals}, \emph{freq\_weights=None}, \emph{method=\textquotesingle{}max\textquotesingle{}}}{}
Project polar slowness grid onto only azimuth

Projects the polar slowness grid onto back azimuth and trace velocity in order to
more easily view each.  The method can either use the maximum value to project or
average to approximate the marginal distribution
\begin{description}
\item[{beam\_power}] \leavevmode{[}2darray{]}
Beam power for each steering vector at each frequency in the band (K x N\_f)

\item[{back\_az\_vals}] \leavevmode{[}1darray{]}
Back azimuth values defining polar slowness grid

\item[{trc\_vel\_vals}] \leavevmode{[}1darray{]}
Trace velocity values defining polar slowness grid

\item[{freq\_weights}] \leavevmode{[}1darray{]}
Weights to use in frequency averaging of the beam power

\item[{method}] \leavevmode{[}str{]}
Determines whether mean or maximum along trace velocity axis is used to
define the projections

\end{description}
\begin{description}
\item[{back\_az\_proj}] \leavevmode{[}1darray{]}
Projection of the beam power onto the back azimuth axis

\item[{trc\_vel\_proj}] \leavevmode{[}1darray{]}
Projection of the beam power onto the trace velocity axis

\end{description}

\end{fulllineitems}

\index{pure\_state\_filter() (in module infrapy.detection.beamforming\_new)@\spxentry{pure\_state\_filter()}\spxextra{in module infrapy.detection.beamforming\_new}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming_new.pure_state_filter}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming\_new.}}\sphinxbfcode{\sphinxupquote{pure\_state\_filter}}}{\emph{S}}{}
Compute the pure state filter applied to a Hermitian matrix, S(f)

Computes the pure state filter for a matrix.  Here, the covariance matrix is utilized
to measure the average coeherence across the entire array at a given frequency.

Pure state filter value are useful for weighting a multi\sphinxhyphen{}frequency beam average.
\begin{description}
\item[{S}] \leavevmode{[}3darray{]}
Covariance matrix of data in analysis window for all frequencies,
x(t) \textendash{}\textgreater{} S(f) = mean(X(f) X\textasciicircum{}dagger(f))

\end{description}
\begin{description}
\item[{pure\_state}] \leavevmode{[}1darray{]}
Pure state filter value at each frequency

\end{description}

\end{fulllineitems}

\index{run() (in module infrapy.detection.beamforming\_new)@\spxentry{run()}\spxextra{in module infrapy.detection.beamforming\_new}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming_new.run}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming\_new.}}\sphinxbfcode{\sphinxupquote{run}}}{\emph{X}, \emph{S}, \emph{f}, \emph{dxdy}, \emph{delays}, \emph{freq\_band}, \emph{method=\textquotesingle{}bartlett\textquotesingle{}}, \emph{ns\_covar\_inv=None}, \emph{signal\_cnt=1}, \emph{normalize\_beam=True}, \emph{pool=None}}{}
Run beamforming analysis over frequencies of interest

Computes the beam at multiple frequencies within a specified band given data in X(f)
and S(f) and frequencies f as produced by the fft\_array\_data function.

Normalization of the beam returns coherence in the case of Bartlett and a normalized
version of the Capon beam but does not alter the output of the MUSIC algorithm as
its result is a mathematical projection onto a noise subspace.

A multiprocessing pool can be used to accelerate calculation of different frequencies
in parallel.
\begin{description}
\item[{X}] \leavevmode{[}2darray{]}
M x N\_f matrix of the FFT’d data, X{[}m{]}{[}n{]} = X\_m(f\_n)

\item[{S}] \leavevmode{[}3darray{]}
M x M x N\_f cube of the covariance matrices, S{[}m1{]}{[}m2{]}{[}n{]} = mean(X\_\{m1\}(f\_n) conj(X\_\{m2\}(f\_n)))

\item[{f}] \leavevmode{[}1darray{]}
Frequencies

\item[{delays}] \leavevmode{[}1darray{]}
Set of delays for the parameterization (length K)

\item[{freq\_band}] \leavevmode{[}iterable{]}
List or tuple with minimum and maximum frequency (e.g.,  {[}f\_min, f\_max{]})

\item[{method}] \leavevmode{[}str{]}
Beamforming method to be applied to the data (must match form of data)

\item[{signal\_cnt}] \leavevmode{[}int{]}
Number of signals assumed in MUSIC algorithm

\item[{ns\_covar\_inv}] \leavevmode{[}2darray{]}
Noise covariance used in “gls” beamforming method

\item[{normalize\_beam}] \leavevmode{[}boolean{]}
Option to normalize the beam and return coherence (value between 0 and 1)

\item[{pool}] \leavevmode{[}multiprocessing pool{]}
Multiprocessing pool for accelerating caluclation (maps over frequency)

\item[{param\_opt}] \leavevmode{[}string{]}
Option for the solution parameterization: ‘planar’ or ‘spherical’

\item[{sph\_vel}] \leavevmode{[}float{]}
Velocity of the wavefront in the ‘spherical’ param\_opt method

\end{description}
\begin{description}
\item[{bmpwr}] \leavevmode{[}2darray{]}
Beam power for each steering vector at each frequency in the band (dimension K x N\_f)

\end{description}

\end{fulllineitems}

\index{stream\_to\_array\_data() (in module infrapy.detection.beamforming\_new)@\spxentry{stream\_to\_array\_data()}\spxextra{in module infrapy.detection.beamforming\_new}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.detection:infrapy.detection.beamforming_new.stream_to_array_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.detection.beamforming\_new.}}\sphinxbfcode{\sphinxupquote{stream\_to\_array\_data}}}{\emph{stream}, \emph{latlon=None}, \emph{t\_start=None}, \emph{t\_end=None}}{}
Extract time series from ObsPy stream on common time samples and define the array geometry

Extracts the time series from individual traces of an Obspy stream and identifies a
common set of time samples where all are defined.  Interpolates the individual traces
into a single numpy array (x) for which x{[}m{]} = x\_m(t).  The geometry of the array is
also extracted to enable beamforming analysis.
\begin{description}
\item[{stream}] \leavevmode{[}ObsPy stream{]}
Obspy stream containing traces for all array elements

\item[{latlon}] \leavevmode{[}2darray{]}
(M x 2) 2darray containing the latitudes and longitudes of the array elements if they aren’t in the stream

\end{description}
\begin{description}
\item[{x}] \leavevmode{[}2darray{]}
M x N matrix of array data, x{[}m{]}{[}n{]} = x\_m(t\_n)

\item[{t}] \leavevmode{[}1darray{]}
Vector of N sampled points in time, t{[}n{]} = t\_n

\item[{t\_ref}] \leavevmode{[}datetime64{]}
Datetime corresponding to t{[}0{]}

\item[{dxdy}] \leavevmode{[}2darray{]}
M x 2 matrix of slowness vectors

\end{description}

\end{fulllineitems}



\subsection{Location}
\label{\detokenize{infrapy.location:location}}\label{\detokenize{infrapy.location::doc}}

\subsubsection{BISL}
\label{\detokenize{infrapy.location:module-infrapy.location.bisl}}\label{\detokenize{infrapy.location:bisl}}\index{infrapy.location.bisl (module)@\spxentry{infrapy.location.bisl}\spxextra{module}}\index{calc\_conf\_ellipse() (in module infrapy.location.bisl)@\spxentry{calc\_conf\_ellipse()}\spxextra{in module infrapy.location.bisl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.location:infrapy.location.bisl.calc_conf_ellipse}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.location.bisl.}}\sphinxbfcode{\sphinxupquote{calc\_conf\_ellipse}}}{\emph{means}, \emph{st\_devs}, \emph{conf\_lvl}, \emph{pnts=100}}{}
Compute the confidence ellipse around a latitude longitude point

Computes the points on an ellipse centered at a latitude, longitude point with
standard deviations (E/W, N/S, and covariance) defiend in kilometers for a given confidence
level.
\begin{description}
\item[{means}] \leavevmode{[}float{]}
Latitude and longitude of the center

\item[{st\_devs}] \leavevmode{[}float{]}
East/West and North/South standard deviations, and covariance for the ellipse

\item[{conf\_lvl}] \leavevmode{[}float{]}
Confidence level in percentage (e.g., 95.0 = 95\%)

\item[{pnts}] \leavevmode{[}int{]}
Number of points to return around the ellipse contour

\end{description}
\begin{description}
\item[{latlon}] \leavevmode{[}float{]}
Latitutde and longitude points of the ellipse

\end{description}

\end{fulllineitems}

\index{find\_confidence() (in module infrapy.location.bisl)@\spxentry{find\_confidence()}\spxextra{in module infrapy.location.bisl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.location:infrapy.location.bisl.find_confidence}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.location.bisl.}}\sphinxbfcode{\sphinxupquote{find\_confidence}}}{\emph{func}, \emph{lims}, \emph{conf\_lvl}}{}
Computes the bounds for a function given a confidence level

Identifies the points for which int\_\{x\_1\}\textasciicircum{}\{x\_2\}\{f(x) dx\} includes a given
fraction of the overall integral such that f(x\_1) = f(x\_2)
\begin{description}
\item[{func}] \leavevmode{[}function of single float parameter{]}
Function to be analyzed

\item[{lims}] \leavevmode{[}float{]}
Limits for the integration of the norm and bounds for possible limits

\end{description}
\begin{description}
\item[{bnds}] \leavevmode{[}float{]}
The values of x\_1 and x\_2 for the confidence bound

\item[{conf}] \leavevmode{[}float{]}
Actual confidence value obtained

\item[{thresh}] \leavevmode{[}float{]}
Value of the function at x\_1 and x\_2

\end{description}

\end{fulllineitems}

\index{run() (in module infrapy.location.bisl)@\spxentry{run()}\spxextra{in module infrapy.location.bisl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.location:infrapy.location.bisl.run}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.location.bisl.}}\sphinxbfcode{\sphinxupquote{run}}}{\emph{det\_list, path\_geo\_model=None, custom\_region=None, resol=180, bm\_width=10.0, rng\_max=10005.97260168349, rad\_min=100.0, angle={[}\sphinxhyphen{}180, 180{]}, rad\_max=1000.0, MaP\_mthd=\textquotesingle{}grid\textquotesingle{}}}{}
Run analysis of the posterior pdf for BISL

Compute the marginal disribution…
\begin{description}
\item[{det\_list}] \leavevmode{[}iterable of InfrasoundDetection instances{]}
Detections attributed to the event

\item[{path\_geo\_model}] \leavevmode{[}Propagation\sphinxhyphen{}based, stochastic path geometry model{]}
Optional path geometry model if available

\item[{custom\_region}] \leavevmode{[}float{]}
Latitude, Longitude, and radius of a specific region to conduct analysis (overrides use of set\_region function)

\item[{resol}] \leavevmode{[}int{]}
Number of radial and azimuthal points used in the polar projection of the spatial PDFs

\item[{bm\_width}] \leavevmode{[}float{]}
Width of the projected beam {[}degrees{]}

\item[{rng\_max}] \leavevmode{[}float{]}
Maximmum range for beam projection {[}km{]}

\item[{rad\_min}] \leavevmode{[}float{]}
Minimum radius of the integration region {[}km{]}

\item[{rad\_max}] \leavevmode{[}float{]}
Maximum radius of the integration region {[}km{]}

\item[{angle}] \leavevmode{[}float{]}
Minimum and maximum angles for polar projection of the spatial PDFs

\item[{MaP\_method}] \leavevmode{[}string{]}
Method to use for searching for the maximum a posteriori solution (“grid” or “random”)

\end{description}
\begin{description}
\item[{result}] \leavevmode{[}dictionary{]}\begin{description}
\item[{Dictionary containing all localization results:}] \leavevmode
‘lat\_mean’: Mean latitude for the marginalized spatial distribution
‘lon\_mean’ : Mean longitude for the marginalized spatial distribution
‘EW\_stdev’: Standard deviation of the marginalized spatial distribution in the east/west direction in km
‘NS\_stdev’: Standard deviation of the marginalized spatial distribution in the north/south direction in km
‘covar’: Relative covariance, sigma\_\{xy\}\textasciicircum{}2 / (sigma\_x sigma\_y)
‘t\_mean’: Mean marginalized temporal distribution
‘t\_stdev’: Standard deviation of the marginalized temporal distribution
‘t\_min’ : 95\% confidence bound lower limit for the marginalized temporal distribution
‘t\_max’ : 95\% confidence bound upper limit for the marginalized temporal distribution
‘lat\_MaP’: Maximum a Posteriori latitude
‘lon\_MaP’: Maximum a Posteriori longitude
‘t\_MaP’: Maximum a Posteriori origin time
‘MaP\_val’ : Maximum a Posteriori value

\end{description}

\end{description}

\end{fulllineitems}

\index{set\_region() (in module infrapy.location.bisl)@\spxentry{set\_region()}\spxextra{in module infrapy.location.bisl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.location:infrapy.location.bisl.set_region}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.location.bisl.}}\sphinxbfcode{\sphinxupquote{set\_region}}}{\emph{det\_list}, \emph{bm\_width=10.0}, \emph{rng\_max=10005.97260168349}, \emph{rad\_min=100.0}, \emph{rad\_max=1000.0}}{}
Defines the integration region for computation of the BISL probability distribution

Projects finite width beams from each of the detecting arrays and looks for intersections
of the primary (center) and secondary (edge) lines to define the integration region
for computation of the localization distribution
\begin{description}
\item[{det\_list}] \leavevmode{[}iterable of InfrasoundDetection instances{]}
Detections attributed to the event

\item[{bm\_width}] \leavevmode{[}float{]}
Width of the projected beam {[}degrees{]}

\item[{rng\_max}] \leavevmode{[}float{]}
Maximmum range for beam projection {[}km{]}

\item[{rad\_min}] \leavevmode{[}float{]}
Minimum radius of the integration region {[}km{]}

\item[{rad\_max}] \leavevmode{[}float{]}
Maximum radius of the integration region {[}km{]}

\end{description}
\begin{description}
\item[{Center}] \leavevmode{[}float{]}
Center of the integration region as latitude, longitude pair {[}degrees{]}

\item[{Radius}] \leavevmode{[}float{]}
Radius of the integration region {[}km{]}

\end{description}

\end{fulllineitems}

\index{summarize() (in module infrapy.location.bisl)@\spxentry{summarize()}\spxextra{in module infrapy.location.bisl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.location:infrapy.location.bisl.summarize}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.location.bisl.}}\sphinxbfcode{\sphinxupquote{summarize}}}{\emph{result}, \emph{confidence\_level=95}}{}
Outputs results of BISL analysis

Prints all results to screen in a readable format
\begin{description}
\item[{bisl\_result}] \leavevmode{[}dictionary{]}
Dictionary output of the BISL analysis methods

\end{description}

\end{fulllineitems}



\subsection{Propagation}
\label{\detokenize{infrapy.propagation:propagation}}\label{\detokenize{infrapy.propagation::doc}}

\subsubsection{Infrasound}
\label{\detokenize{infrapy.propagation:module-infrapy.propagation.infrasound}}\label{\detokenize{infrapy.propagation:infrasound}}\index{infrapy.propagation.infrasound (module)@\spxentry{infrapy.propagation.infrasound}\spxextra{module}}\index{PathGeometryModel (class in infrapy.propagation.infrasound)@\spxentry{PathGeometryModel}\spxextra{class in infrapy.propagation.infrasound}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.PathGeometryModel}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{infrapy.propagation.infrasound.}}\sphinxbfcode{\sphinxupquote{PathGeometryModel}}}
Bases: \sphinxcode{\sphinxupquote{object}}
\index{az\_bin\_cnt (infrapy.propagation.infrasound.PathGeometryModel attribute)@\spxentry{az\_bin\_cnt}\spxextra{infrapy.propagation.infrasound.PathGeometryModel attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.PathGeometryModel.az_bin_cnt}}\pysigline{\sphinxbfcode{\sphinxupquote{az\_bin\_cnt}}\sphinxbfcode{\sphinxupquote{ = 8}}}
\end{fulllineitems}

\index{az\_bin\_wdth (infrapy.propagation.infrasound.PathGeometryModel attribute)@\spxentry{az\_bin\_wdth}\spxextra{infrapy.propagation.infrasound.PathGeometryModel attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.PathGeometryModel.az_bin_wdth}}\pysigline{\sphinxbfcode{\sphinxupquote{az\_bin\_wdth}}\sphinxbfcode{\sphinxupquote{ = 60.0}}}
\end{fulllineitems}

\index{bnc\_max (infrapy.propagation.infrasound.PathGeometryModel attribute)@\spxentry{bnc\_max}\spxextra{infrapy.propagation.infrasound.PathGeometryModel attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.PathGeometryModel.bnc_max}}\pysigline{\sphinxbfcode{\sphinxupquote{bnc\_max}}\sphinxbfcode{\sphinxupquote{ = 10}}}
\end{fulllineitems}

\index{bnd\_overlap (infrapy.propagation.infrasound.PathGeometryModel attribute)@\spxentry{bnd\_overlap}\spxextra{infrapy.propagation.infrasound.PathGeometryModel attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.PathGeometryModel.bnd_overlap}}\pysigline{\sphinxbfcode{\sphinxupquote{bnd\_overlap}}\sphinxbfcode{\sphinxupquote{ = 0.075}}}
\end{fulllineitems}

\index{build() (infrapy.propagation.infrasound.PathGeometryModel method)@\spxentry{build()}\spxextra{infrapy.propagation.infrasound.PathGeometryModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.PathGeometryModel.build}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build}}}{\emph{results\_file}, \emph{model\_file}, \emph{show\_fits=False}, \emph{file\_id=None}, \emph{verbose\_output=False}, \emph{rng\_width=40.0}, \emph{rng\_spacing=10.0}, \emph{data\_format=\textquotesingle{}new\textquotesingle{}}, \emph{abs\_lim=\sphinxhyphen{}100.0}, \emph{trn\_ht\_min=2.0}}{}
\end{fulllineitems}

\index{default\_az\_dev\_var (infrapy.propagation.infrasound.PathGeometryModel attribute)@\spxentry{default\_az\_dev\_var}\spxextra{infrapy.propagation.infrasound.PathGeometryModel attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.PathGeometryModel.default_az_dev_var}}\pysigline{\sphinxbfcode{\sphinxupquote{default\_az\_dev\_var}}\sphinxbfcode{\sphinxupquote{ = 4.0}}}
\end{fulllineitems}

\index{display() (infrapy.propagation.infrasound.PathGeometryModel method)@\spxentry{display()}\spxextra{infrapy.propagation.infrasound.PathGeometryModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.PathGeometryModel.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{\emph{file\_id=None}, \emph{hold\_fig=None}}{}
\end{fulllineitems}

\index{eval\_az\_dev\_mn() (infrapy.propagation.infrasound.PathGeometryModel method)@\spxentry{eval\_az\_dev\_mn()}\spxextra{infrapy.propagation.infrasound.PathGeometryModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.PathGeometryModel.eval_az_dev_mn}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{eval\_az\_dev\_mn}}}{\emph{rng}, \emph{az}}{}
\end{fulllineitems}

\index{eval\_az\_dev\_vr() (infrapy.propagation.infrasound.PathGeometryModel method)@\spxentry{eval\_az\_dev\_vr()}\spxextra{infrapy.propagation.infrasound.PathGeometryModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.PathGeometryModel.eval_az_dev_vr}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{eval\_az\_dev\_vr}}}{\emph{rng}, \emph{az}}{}
\end{fulllineitems}

\index{eval\_rcel\_gmm() (infrapy.propagation.infrasound.PathGeometryModel method)@\spxentry{eval\_rcel\_gmm()}\spxextra{infrapy.propagation.infrasound.PathGeometryModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.PathGeometryModel.eval_rcel_gmm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{eval\_rcel\_gmm}}}{\emph{rng}, \emph{rcel}, \emph{az}}{}
\end{fulllineitems}

\index{load() (infrapy.propagation.infrasound.PathGeometryModel method)@\spxentry{load()}\spxextra{infrapy.propagation.infrasound.PathGeometryModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.PathGeometryModel.load}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load}}}{\emph{model\_file}, \emph{smooth=None}}{}
\end{fulllineitems}

\index{min\_az\_dev\_var (infrapy.propagation.infrasound.PathGeometryModel attribute)@\spxentry{min\_az\_dev\_var}\spxextra{infrapy.propagation.infrasound.PathGeometryModel attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.PathGeometryModel.min_az_dev_var}}\pysigline{\sphinxbfcode{\sphinxupquote{min\_az\_dev\_var}}\sphinxbfcode{\sphinxupquote{ = 0.9}}}
\end{fulllineitems}

\index{rcel\_vrs\_min (infrapy.propagation.infrasound.PathGeometryModel attribute)@\spxentry{rcel\_vrs\_min}\spxextra{infrapy.propagation.infrasound.PathGeometryModel attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.PathGeometryModel.rcel_vrs_min}}\pysigline{\sphinxbfcode{\sphinxupquote{rcel\_vrs\_min}}\sphinxbfcode{\sphinxupquote{ = 0.05}}}
\end{fulllineitems}

\index{rng\_max (infrapy.propagation.infrasound.PathGeometryModel attribute)@\spxentry{rng\_max}\spxextra{infrapy.propagation.infrasound.PathGeometryModel attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.PathGeometryModel.rng_max}}\pysigline{\sphinxbfcode{\sphinxupquote{rng\_max}}\sphinxbfcode{\sphinxupquote{ = 1000.0}}}
\end{fulllineitems}

\index{strat\_therm\_bnd (infrapy.propagation.infrasound.PathGeometryModel attribute)@\spxentry{strat\_therm\_bnd}\spxextra{infrapy.propagation.infrasound.PathGeometryModel attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.PathGeometryModel.strat_therm_bnd}}\pysigline{\sphinxbfcode{\sphinxupquote{strat\_therm\_bnd}}\sphinxbfcode{\sphinxupquote{ = 3.846153846153846}}}
\end{fulllineitems}

\index{tropo\_strat\_bnd (infrapy.propagation.infrasound.PathGeometryModel attribute)@\spxentry{tropo\_strat\_bnd}\spxextra{infrapy.propagation.infrasound.PathGeometryModel attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.PathGeometryModel.tropo_strat_bnd}}\pysigline{\sphinxbfcode{\sphinxupquote{tropo\_strat\_bnd}}\sphinxbfcode{\sphinxupquote{ = 3.2258064516129035}}}
\end{fulllineitems}


\end{fulllineitems}

\index{TLossModel (class in infrapy.propagation.infrasound)@\spxentry{TLossModel}\spxextra{class in infrapy.propagation.infrasound}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.TLossModel}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{infrapy.propagation.infrasound.}}\sphinxbfcode{\sphinxupquote{TLossModel}}}
Bases: \sphinxcode{\sphinxupquote{object}}
\index{az\_bin\_cnt (infrapy.propagation.infrasound.TLossModel attribute)@\spxentry{az\_bin\_cnt}\spxextra{infrapy.propagation.infrasound.TLossModel attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.TLossModel.az_bin_cnt}}\pysigline{\sphinxbfcode{\sphinxupquote{az\_bin\_cnt}}\sphinxbfcode{\sphinxupquote{ = 8}}}
\end{fulllineitems}

\index{az\_bin\_wdth (infrapy.propagation.infrasound.TLossModel attribute)@\spxentry{az\_bin\_wdth}\spxextra{infrapy.propagation.infrasound.TLossModel attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.TLossModel.az_bin_wdth}}\pysigline{\sphinxbfcode{\sphinxupquote{az\_bin\_wdth}}\sphinxbfcode{\sphinxupquote{ = 60.0}}}
\end{fulllineitems}

\index{build() (infrapy.propagation.infrasound.TLossModel method)@\spxentry{build()}\spxextra{infrapy.propagation.infrasound.TLossModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.TLossModel.build}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{build}}}{\emph{results\_file}, \emph{model\_file}, \emph{show\_fits=False}, \emph{file\_id=None}, \emph{pool=None}}{}
\end{fulllineitems}

\index{display() (infrapy.propagation.infrasound.TLossModel method)@\spxentry{display()}\spxextra{infrapy.propagation.infrasound.TLossModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.TLossModel.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{\emph{title=\textquotesingle{}Transmission Loss Statistics\textquotesingle{}}, \emph{file\_id=None}, \emph{hold\_fig=None}}{}
\end{fulllineitems}

\index{eval() (infrapy.propagation.infrasound.TLossModel method)@\spxentry{eval()}\spxextra{infrapy.propagation.infrasound.TLossModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.TLossModel.eval}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{eval}}}{\emph{rng}, \emph{tloss}, \emph{az}}{}
\end{fulllineitems}

\index{load() (infrapy.propagation.infrasound.TLossModel method)@\spxentry{load()}\spxextra{infrapy.propagation.infrasound.TLossModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.TLossModel.load}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load}}}{\emph{model\_file}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{canonical\_rcel() (in module infrapy.propagation.infrasound)@\spxentry{canonical\_rcel()}\spxextra{in module infrapy.propagation.infrasound}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.canonical_rcel}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.propagation.infrasound.}}\sphinxbfcode{\sphinxupquote{canonical\_rcel}}}{\emph{rcel}}{}
\end{fulllineitems}

\index{canonical\_tloss() (in module infrapy.propagation.infrasound)@\spxentry{canonical\_tloss()}\spxextra{in module infrapy.propagation.infrasound}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.canonical_tloss}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.propagation.infrasound.}}\sphinxbfcode{\sphinxupquote{canonical\_tloss}}}{\emph{rng}, \emph{tloss}}{}
\end{fulllineitems}

\index{find\_azimuth\_bin() (in module infrapy.propagation.infrasound)@\spxentry{find\_azimuth\_bin()}\spxextra{in module infrapy.propagation.infrasound}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.infrasound.find_azimuth_bin}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.propagation.infrasound.}}\sphinxbfcode{\sphinxupquote{find\_azimuth\_bin}}}{\emph{az}, \emph{bin\_cnt=8}}{}
\end{fulllineitems}



\subsubsection{Likelihoods}
\label{\detokenize{infrapy.propagation:module-infrapy.propagation.likelihoods}}\label{\detokenize{infrapy.propagation:likelihoods}}\index{infrapy.propagation.likelihoods (module)@\spxentry{infrapy.propagation.likelihoods}\spxextra{module}}\index{BadArrayDimensionError@\spxentry{BadArrayDimensionError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.BadArrayDimensionError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{infrapy.propagation.likelihoods.}}\sphinxbfcode{\sphinxupquote{BadArrayDimensionError}}}
Bases: {\hyperref[\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.CustomError}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{infrapy.propagation.likelihoods.CustomError}}}}}

Raised when someone tries to set the array dimension to something that isnt an integer

\end{fulllineitems}

\index{BadLatitudeError@\spxentry{BadLatitudeError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.BadLatitudeError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{infrapy.propagation.likelihoods.}}\sphinxbfcode{\sphinxupquote{BadLatitudeError}}}
Bases: {\hyperref[\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.CustomError}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{infrapy.propagation.likelihoods.CustomError}}}}}

Rasied when the latitude is out of range

\end{fulllineitems}

\index{BadLongitudeError@\spxentry{BadLongitudeError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.BadLongitudeError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{infrapy.propagation.likelihoods.}}\sphinxbfcode{\sphinxupquote{BadLongitudeError}}}
Bases: {\hyperref[\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.CustomError}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{infrapy.propagation.likelihoods.CustomError}}}}}

Raised when the longitude is out of range

\end{fulllineitems}

\index{CustomError@\spxentry{CustomError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.CustomError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{infrapy.propagation.likelihoods.}}\sphinxbfcode{\sphinxupquote{CustomError}}}
Bases: \sphinxcode{\sphinxupquote{Exception}}

\end{fulllineitems}

\index{Infrapy\_Encoder (class in infrapy.propagation.likelihoods)@\spxentry{Infrapy\_Encoder}\spxextra{class in infrapy.propagation.likelihoods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.Infrapy_Encoder}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{infrapy.propagation.likelihoods.}}\sphinxbfcode{\sphinxupquote{Infrapy\_Encoder}}}{\emph{*}, \emph{skipkeys=False}, \emph{ensure\_ascii=True}, \emph{check\_circular=True}, \emph{allow\_nan=True}, \emph{sort\_keys=False}, \emph{indent=None}, \emph{separators=None}, \emph{default=None}}{}
Bases: \sphinxcode{\sphinxupquote{json.encoder.JSONEncoder}}
\index{default() (infrapy.propagation.likelihoods.Infrapy\_Encoder method)@\spxentry{default()}\spxextra{infrapy.propagation.likelihoods.Infrapy\_Encoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.Infrapy_Encoder.default}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{default}}}{\emph{obj}}{}
Implement this method in a subclass such that it returns
a serializable object for \sphinxcode{\sphinxupquote{o}}, or calls the base implementation
(to raise a \sphinxcode{\sphinxupquote{TypeError}}).

For example, to support arbitrary iterators, you could
implement default like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{default}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{o}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{n}{iterable} \PYG{o}{=} \PYG{n+nb}{iter}\PYG{p}{(}\PYG{n}{o}\PYG{p}{)}
    \PYG{k}{except} \PYG{n+ne}{TypeError}\PYG{p}{:}
        \PYG{k}{pass}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{iterable}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} Let the base class default method raise the TypeError}
    \PYG{k}{return} \PYG{n}{JSONEncoder}\PYG{o}{.}\PYG{n}{default}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{o}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}


\end{fulllineitems}

\index{InfrasoundDetection (class in infrapy.propagation.likelihoods)@\spxentry{InfrasoundDetection}\spxextra{class in infrapy.propagation.likelihoods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{infrapy.propagation.likelihoods.}}\sphinxbfcode{\sphinxupquote{InfrasoundDetection}}}{\emph{lat\_loc=None}, \emph{lon\_loc=None}, \emph{time=None}, \emph{azimuth=None}, \emph{f\_stat=None}, \emph{array\_d=None}}{}
Bases: \sphinxcode{\sphinxupquote{object}}
\index{array\_dim() (infrapy.propagation.likelihoods.InfrasoundDetection property)@\spxentry{array\_dim()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.array_dim}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{array\_dim}}}
(int) Number of elements in the detecting array

\end{fulllineitems}

\index{az\_pdf() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{az\_pdf()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.az_pdf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{az\_pdf}}}{\emph{lat}, \emph{lon}, \emph{path\_geo\_model=None}}{}
\end{fulllineitems}

\index{back\_azimuth() (infrapy.propagation.likelihoods.InfrasoundDetection property)@\spxentry{back\_azimuth()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.back_azimuth}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{back\_azimuth}}}
(float) Back azimuth of the detected signal

\end{fulllineitems}

\index{calc\_kappa\_etc() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{calc\_kappa\_etc()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.calc_kappa_etc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calc\_kappa\_etc}}}{}{}
\end{fulllineitems}

\index{elevation() (infrapy.propagation.likelihoods.InfrasoundDetection property)@\spxentry{elevation()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.elevation}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{elevation}}}
Elevation of the detecting array

\end{fulllineitems}

\index{end() (infrapy.propagation.likelihoods.InfrasoundDetection property)@\spxentry{end()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.end}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{end}}}
(float) End time in seconds relative to the peak F utc time of the detection

\end{fulllineitems}

\index{event\_id() (infrapy.propagation.likelihoods.InfrasoundDetection property)@\spxentry{event\_id()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.event_id}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{event\_id}}}
Optional id of the event

\end{fulllineitems}

\index{fillFromDict() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{fillFromDict()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.fillFromDict}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fillFromDict}}}{\emph{dict}}{}
\end{fulllineitems}

\index{frequency\_range() (infrapy.propagation.likelihoods.InfrasoundDetection property)@\spxentry{frequency\_range()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.frequency_range}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{frequency\_range}}}
(tuple) Frequency range of the measurement

\end{fulllineitems}

\index{generateDict() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{generateDict()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.generateDict}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{generateDict}}}{}{}
\end{fulllineitems}

\index{get\_array\_dim() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{get\_array\_dim()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.get_array_dim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_array\_dim}}}{}{}
\end{fulllineitems}

\index{get\_back\_azimuth() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{get\_back\_azimuth()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.get_back_azimuth}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_back\_azimuth}}}{}{}
\end{fulllineitems}

\index{get\_ele() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{get\_ele()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.get_ele}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_ele}}}{}{}
\end{fulllineitems}

\index{get\_end() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{get\_end()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.get_end}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_end}}}{}{}
\end{fulllineitems}

\index{get\_event\_id() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{get\_event\_id()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.get_event_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_event\_id}}}{}{}
\end{fulllineitems}

\index{get\_freq\_range() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{get\_freq\_range()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.get_freq_range}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_freq\_range}}}{}{}
\end{fulllineitems}

\index{get\_lat() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{get\_lat()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.get_lat}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_lat}}}{}{}
\end{fulllineitems}

\index{get\_lon() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{get\_lon()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.get_lon}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_lon}}}{}{}
\end{fulllineitems}

\index{get\_method() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{get\_method()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.get_method}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_method}}}{}{}
\end{fulllineitems}

\index{get\_name() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{get\_name()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.get_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_name}}}{}{}
\end{fulllineitems}

\index{get\_note() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{get\_note()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.get_note}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_note}}}{}{}
\end{fulllineitems}

\index{get\_peakF\_UTCtime() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{get\_peakF\_UTCtime()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.get_peakF_UTCtime}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_peakF\_UTCtime}}}{\emph{type=\textquotesingle{}numpy\textquotesingle{}}}{}
\end{fulllineitems}

\index{get\_peakF\_value() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{get\_peakF\_value()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.get_peakF_value}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_peakF\_value}}}{}{}
\end{fulllineitems}

\index{get\_start() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{get\_start()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.get_start}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_start}}}{}{}
\end{fulllineitems}

\index{get\_trace\_velocity() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{get\_trace\_velocity()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.get_trace_velocity}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_trace\_velocity}}}{}{}
\end{fulllineitems}

\index{latitude() (infrapy.propagation.likelihoods.InfrasoundDetection property)@\spxentry{latitude()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.latitude}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{latitude}}}
Latitude of the array

\end{fulllineitems}

\index{longitude() (infrapy.propagation.likelihoods.InfrasoundDetection property)@\spxentry{longitude()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.longitude}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{longitude}}}
Longitude of the detecting array

\end{fulllineitems}

\index{method() (infrapy.propagation.likelihoods.InfrasoundDetection property)@\spxentry{method()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.method}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{method}}}
(string) Beamforming method used to generate the detection

\end{fulllineitems}

\index{name() (infrapy.propagation.likelihoods.InfrasoundDetection property)@\spxentry{name()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.name}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{name}}}
Optional name of the detection

\end{fulllineitems}

\index{note() (infrapy.propagation.likelihoods.InfrasoundDetection property)@\spxentry{note()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.note}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{note}}}
Optional note regarding the detection

\end{fulllineitems}

\index{pdf() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{pdf()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.pdf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pdf}}}{\emph{lat}, \emph{lon}, \emph{t}, \emph{path\_geo\_model=None}}{}
\end{fulllineitems}

\index{peakF\_UTCtime() (infrapy.propagation.likelihoods.InfrasoundDetection property)@\spxentry{peakF\_UTCtime()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.peakF_UTCtime}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{peakF\_UTCtime}}}
time of the peak F value, in UTC

\end{fulllineitems}

\index{peakF\_value() (infrapy.propagation.likelihoods.InfrasoundDetection property)@\spxentry{peakF\_value()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.peakF_value}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{peakF\_value}}}
Peak F values

\end{fulllineitems}

\index{rng\_pdf() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{rng\_pdf()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.rng_pdf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{rng\_pdf}}}{\emph{lat}, \emph{lon}, \emph{t}, \emph{path\_geo\_model=None}}{}
\end{fulllineitems}

\index{set\_array\_dim() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{set\_array\_dim()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.set_array_dim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_array\_dim}}}{\emph{ad}}{}
\end{fulllineitems}

\index{set\_back\_azimuth() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{set\_back\_azimuth()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.set_back_azimuth}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_back\_azimuth}}}{\emph{ba}}{}
\end{fulllineitems}

\index{set\_ele() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{set\_ele()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.set_ele}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_ele}}}{\emph{ele}}{}
\end{fulllineitems}

\index{set\_end() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{set\_end()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.set_end}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_end}}}{\emph{end}}{}
\end{fulllineitems}

\index{set\_event\_id() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{set\_event\_id()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.set_event_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_event\_id}}}{\emph{evt}}{}
\end{fulllineitems}

\index{set\_freq\_range() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{set\_freq\_range()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.set_freq_range}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_freq\_range}}}{\emph{frange}}{}
\end{fulllineitems}

\index{set\_lat() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{set\_lat()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.set_lat}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_lat}}}{\emph{lat}}{}
\end{fulllineitems}

\index{set\_lon() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{set\_lon()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.set_lon}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_lon}}}{\emph{lon}}{}
\end{fulllineitems}

\index{set\_method() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{set\_method()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.set_method}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_method}}}{\emph{method}}{}
\end{fulllineitems}

\index{set\_name() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{set\_name()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.set_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_name}}}{\emph{n}}{}
\end{fulllineitems}

\index{set\_note() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{set\_note()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.set_note}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_note}}}{\emph{note}}{}
\end{fulllineitems}

\index{set\_peakF\_UTCtime() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{set\_peakF\_UTCtime()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.set_peakF_UTCtime}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_peakF\_UTCtime}}}{\emph{pf\_UTCtime}}{}
\end{fulllineitems}

\index{set\_peakF\_value() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{set\_peakF\_value()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.set_peakF_value}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_peakF\_value}}}{\emph{pfv}}{}
\end{fulllineitems}

\index{set\_start() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{set\_start()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.set_start}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_start}}}{\emph{start}}{}
\end{fulllineitems}

\index{set\_trace\_velocity() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{set\_trace\_velocity()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.set_trace_velocity}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_trace\_velocity}}}{\emph{tv}}{}
\end{fulllineitems}

\index{src\_spec\_pdf() (infrapy.propagation.likelihoods.InfrasoundDetection method)@\spxentry{src\_spec\_pdf()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.src_spec_pdf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{src\_spec\_pdf}}}{\emph{lat}, \emph{lon}, \emph{freqs}, \emph{src\_spec}, \emph{smn\_spec}, \emph{tloss\_models}}{}
Defines the probability of detection being produced by a given source

Computes the probability of a given source spectral amplitude, P(f),
producing this detection given its signal\sphinxhyphen{}minus\sphinxhyphen{}noise spectrum and
a transmission loss model
\begin{description}
\item[{lat}] \leavevmode{[}float{]}
Latitude of the hypothetical source

\item[{lon}] \leavevmode{[}float{]}
Longitue of the hypothetical source

\item[{freqs}] \leavevmode{[}1darray{]}
Frequencies at which to evaluate the source spectrum

\item[{src\_spec}] \leavevmode{[}1darray{]}
Values at which to evaluate the source spectrum

\item[{smn\_spec}] \leavevmode{[}2darray{]}
Numpy array containing frequencies and signal\sphinxhyphen{}minus\sphinxhyphen{}noise spectral amplitudes of the detection

\item[{tloss\_models}] \leavevmode{[}frequencies and TLossModel instances{]}
Transmission loss models to use and frequencies at which they are computed

\end{description}
\begin{description}
\item[{freq\_grid}] \leavevmode{[}1darray{]}
Frequencies at which the pdf is evaluated

\item[{src\_spec\_grid}] \leavevmode{[}1darray{]}
Spectral amplitudes at which the pdf is evaluated

\item[{pdf}] \leavevmode{[}2darray{]}
Grid of probability for source spectrum at frequencies and source spectrum amplitudes specified by input

\end{description}

\end{fulllineitems}

\index{start() (infrapy.propagation.likelihoods.InfrasoundDetection property)@\spxentry{start()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.start}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{start}}}
(float) Start time in seconds relative to the peak F utc time of the detection

\end{fulllineitems}

\index{trace\_velocity() (infrapy.propagation.likelihoods.InfrasoundDetection property)@\spxentry{trace\_velocity()}\spxextra{infrapy.propagation.likelihoods.InfrasoundDetection property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.InfrasoundDetection.trace_velocity}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{trace\_velocity}}}
Trace velocity of the detection

\end{fulllineitems}


\end{fulllineitems}

\index{SeismicDetection (class in infrapy.propagation.likelihoods)@\spxentry{SeismicDetection}\spxextra{class in infrapy.propagation.likelihoods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.SeismicDetection}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{infrapy.propagation.likelihoods.}}\sphinxbfcode{\sphinxupquote{SeismicDetection}}}{\emph{lat}, \emph{lon}, \emph{time}, \emph{phase=\textquotesingle{}p\textquotesingle{}}, \emph{slowness=None}}{}
Bases: \sphinxcode{\sphinxupquote{object}}
\index{pdf() (infrapy.propagation.likelihoods.SeismicDetection method)@\spxentry{pdf()}\spxextra{infrapy.propagation.likelihoods.SeismicDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.SeismicDetection.pdf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pdf}}}{\emph{lat}, \emph{lon}, \emph{t}}{}
\end{fulllineitems}

\index{sigma() (infrapy.propagation.likelihoods.SeismicDetection method)@\spxentry{sigma()}\spxextra{infrapy.propagation.likelihoods.SeismicDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.SeismicDetection.sigma}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sigma}}}{}{}
\end{fulllineitems}

\index{trvl\_tm() (infrapy.propagation.likelihoods.SeismicDetection method)@\spxentry{trvl\_tm()}\spxextra{infrapy.propagation.likelihoods.SeismicDetection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.SeismicDetection.trvl_tm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{trvl\_tm}}}{\emph{rng}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{db2dets() (in module infrapy.propagation.likelihoods)@\spxentry{db2dets()}\spxextra{in module infrapy.propagation.likelihoods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.db2dets}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.propagation.likelihoods.}}\sphinxbfcode{\sphinxupquote{db2dets}}}{\emph{file\_name}}{}
\end{fulllineitems}

\index{detection\_list\_to\_json() (in module infrapy.propagation.likelihoods)@\spxentry{detection\_list\_to\_json()}\spxextra{in module infrapy.propagation.likelihoods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.detection_list_to_json}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.propagation.likelihoods.}}\sphinxbfcode{\sphinxupquote{detection\_list\_to\_json}}}{\emph{filename}, \emph{detections}}{}
\end{fulllineitems}

\index{file2dets() (in module infrapy.propagation.likelihoods)@\spxentry{file2dets()}\spxextra{in module infrapy.propagation.likelihoods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.file2dets}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.propagation.likelihoods.}}\sphinxbfcode{\sphinxupquote{file2dets}}}{\emph{file\_name}}{}
\end{fulllineitems}

\index{joint\_pdf() (in module infrapy.propagation.likelihoods)@\spxentry{joint\_pdf()}\spxextra{in module infrapy.propagation.likelihoods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.joint_pdf}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.propagation.likelihoods.}}\sphinxbfcode{\sphinxupquote{joint\_pdf}}}{\emph{lat}, \emph{lon}, \emph{t}, \emph{det\_list}, \emph{path\_geo\_model=None}, \emph{prog\_step=0}}{}
\end{fulllineitems}

\index{joint\_pdf\_wrapper() (in module infrapy.propagation.likelihoods)@\spxentry{joint\_pdf\_wrapper()}\spxextra{in module infrapy.propagation.likelihoods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.joint_pdf_wrapper}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.propagation.likelihoods.}}\sphinxbfcode{\sphinxupquote{joint\_pdf\_wrapper}}}{\emph{args}}{}
\end{fulllineitems}

\index{json\_to\_detection\_list() (in module infrapy.propagation.likelihoods)@\spxentry{json\_to\_detection\_list()}\spxextra{in module infrapy.propagation.likelihoods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.json_to_detection_list}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.propagation.likelihoods.}}\sphinxbfcode{\sphinxupquote{json\_to\_detection\_list}}}{\emph{filename}}{}
\end{fulllineitems}

\index{marginal\_spatial\_pdf() (in module infrapy.propagation.likelihoods)@\spxentry{marginal\_spatial\_pdf()}\spxextra{in module infrapy.propagation.likelihoods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.marginal_spatial_pdf}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.propagation.likelihoods.}}\sphinxbfcode{\sphinxupquote{marginal\_spatial\_pdf}}}{\emph{lat}, \emph{lon}, \emph{det\_list}, \emph{path\_geo\_model=None}, \emph{prog\_step=0}, \emph{resol=100}}{}
\end{fulllineitems}

\index{marginal\_spatial\_pdf\_wrapper() (in module infrapy.propagation.likelihoods)@\spxentry{marginal\_spatial\_pdf\_wrapper()}\spxextra{in module infrapy.propagation.likelihoods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.likelihoods.marginal_spatial_pdf_wrapper}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.propagation.likelihoods.}}\sphinxbfcode{\sphinxupquote{marginal\_spatial\_pdf\_wrapper}}}{\emph{args}}{}
\end{fulllineitems}



\subsubsection{Seismic}
\label{\detokenize{infrapy.propagation:module-infrapy.propagation.seismic}}\label{\detokenize{infrapy.propagation:seismic}}\index{infrapy.propagation.seismic (module)@\spxentry{infrapy.propagation.seismic}\spxextra{module}}\index{ak135\_p\_tr\_time() (in module infrapy.propagation.seismic)@\spxentry{ak135\_p\_tr\_time()}\spxextra{in module infrapy.propagation.seismic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.seismic.ak135_p_tr_time}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.propagation.seismic.}}\sphinxbfcode{\sphinxupquote{ak135\_p\_tr\_time}}}{\emph{rng}}{}
\end{fulllineitems}

\index{ak135\_s\_tr\_time() (in module infrapy.propagation.seismic)@\spxentry{ak135\_s\_tr\_time()}\spxextra{in module infrapy.propagation.seismic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.propagation:infrapy.propagation.seismic.ak135_s_tr_time}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.propagation.seismic.}}\sphinxbfcode{\sphinxupquote{ak135\_s\_tr\_time}}}{\emph{rng}}{}
\end{fulllineitems}



\subsection{Utils}
\label{\detokenize{infrapy.utils:module-infrapy.utils}}\label{\detokenize{infrapy.utils:utils}}\label{\detokenize{infrapy.utils::doc}}\index{infrapy.utils (module)@\spxentry{infrapy.utils}\spxextra{module}}

\subsubsection{infrapy.utils.cart2pol module}
\label{\detokenize{infrapy.utils:module-infrapy.utils.cart2pol}}\label{\detokenize{infrapy.utils:infrapy-utils-cart2pol-module}}\index{infrapy.utils.cart2pol (module)@\spxentry{infrapy.utils.cart2pol}\spxextra{module}}\index{cart2pol() (in module infrapy.utils.cart2pol)@\spxentry{cart2pol()}\spxextra{in module infrapy.utils.cart2pol}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.cart2pol.cart2pol}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.cart2pol.}}\sphinxbfcode{\sphinxupquote{cart2pol}}}{\emph{x}, \emph{y}}{}
Transform Cartesian to polar coordinates

Inputs:
x is the x coordinate
y is the y coordinate

Outputs:
th is the angle
r is the range

\end{fulllineitems}



\subsubsection{infrapy.utils.confidence module}
\label{\detokenize{infrapy.utils:module-infrapy.utils.confidence}}\label{\detokenize{infrapy.utils:infrapy-utils-confidence-module}}\index{infrapy.utils.confidence (module)@\spxentry{infrapy.utils.confidence}\spxextra{module}}\index{find\_confidence() (in module infrapy.utils.confidence)@\spxentry{find\_confidence()}\spxextra{in module infrapy.utils.confidence}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.confidence.find_confidence}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.confidence.}}\sphinxbfcode{\sphinxupquote{find\_confidence}}}{\emph{func}, \emph{lims}, \emph{conf\_aim}}{}
\end{fulllineitems}



\subsubsection{infrapy.utils.db2db module}
\label{\detokenize{infrapy.utils:module-infrapy.utils.db2db}}\label{\detokenize{infrapy.utils:infrapy-utils-db2db-module}}\index{infrapy.utils.db2db (module)@\spxentry{infrapy.utils.db2db}\spxextra{module}}

\subsubsection{infrapy.utils.db2sac module}
\label{\detokenize{infrapy.utils:module-infrapy.utils.db2sac}}\label{\detokenize{infrapy.utils:infrapy-utils-db2sac-module}}\index{infrapy.utils.db2sac (module)@\spxentry{infrapy.utils.db2sac}\spxextra{module}}

\subsubsection{infrapy.utils.files2db module}
\label{\detokenize{infrapy.utils:module-infrapy.utils.files2db}}\label{\detokenize{infrapy.utils:infrapy-utils-files2db-module}}\index{infrapy.utils.files2db (module)@\spxentry{infrapy.utils.files2db}\spxextra{module}}\index{CoreTable (class in infrapy.utils.files2db)@\spxentry{CoreTable}\spxextra{class in infrapy.utils.files2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.files2db.CoreTable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{infrapy.utils.files2db.}}\sphinxbfcode{\sphinxupquote{CoreTable}}}{\emph{name}, \emph{prototype}, \emph{table}}{}
Bases: \sphinxcode{\sphinxupquote{tuple}}
\index{name() (infrapy.utils.files2db.CoreTable property)@\spxentry{name()}\spxextra{infrapy.utils.files2db.CoreTable property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.files2db.CoreTable.name}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{name}}}
Alias for field number 0

\end{fulllineitems}

\index{prototype() (infrapy.utils.files2db.CoreTable property)@\spxentry{prototype()}\spxextra{infrapy.utils.files2db.CoreTable property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.files2db.CoreTable.prototype}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{prototype}}}
Alias for field number 1

\end{fulllineitems}

\index{table() (infrapy.utils.files2db.CoreTable property)@\spxentry{table()}\spxextra{infrapy.utils.files2db.CoreTable property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.files2db.CoreTable.table}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{table}}}
Alias for field number 2

\end{fulllineitems}


\end{fulllineitems}

\index{apply\_plugins() (in module infrapy.utils.files2db)@\spxentry{apply\_plugins()}\spxextra{in module infrapy.utils.files2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.files2db.apply_plugins}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.files2db.}}\sphinxbfcode{\sphinxupquote{apply\_plugins}}}{\emph{plugins}, \emph{**rows}}{}
\end{fulllineitems}

\index{dicts2rows() (in module infrapy.utils.files2db)@\spxentry{dicts2rows()}\spxextra{in module infrapy.utils.files2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.files2db.dicts2rows}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.files2db.}}\sphinxbfcode{\sphinxupquote{dicts2rows}}}{\emph{dicts}, \emph{classes}}{}
\end{fulllineitems}

\index{expand\_glob() (in module infrapy.utils.files2db)@\spxentry{expand\_glob()}\spxextra{in module infrapy.utils.files2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.files2db.expand_glob}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.files2db.}}\sphinxbfcode{\sphinxupquote{expand\_glob}}}{\emph{option}, \emph{opt\_str}, \emph{value}, \emph{parser}}{}
Returns an iglob iterator for file iteration. Good for large file lists.

\end{fulllineitems}

\index{get\_files() (in module infrapy.utils.files2db)@\spxentry{get\_files()}\spxextra{in module infrapy.utils.files2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.files2db.get_files}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.files2db.}}\sphinxbfcode{\sphinxupquote{get\_files}}}{\emph{options}}{}
Return a sequence of WFDISC file names from either a list of file names
(trivial) or a text file list (presumable because there are too many files
to use normal shell expansion).

\end{fulllineitems}

\index{get\_or\_create\_tables() (in module infrapy.utils.files2db)@\spxentry{get\_or\_create\_tables()}\spxextra{in module infrapy.utils.files2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.files2db.get_or_create_tables}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.files2db.}}\sphinxbfcode{\sphinxupquote{get\_or\_create\_tables}}}{\emph{options}, \emph{session}, \emph{create=True}}{}
Load or create canonical ORM KB Core table classes.

options : argparse.ArgumentParser
session : sqlalchemy.orm.Session
\begin{description}
\item[{tables}] \leavevmode{[}dict{]}
Mapping between canonical table names and SQLA ORM classes.
e.g. \{‘origin’: MyOrigin, …\}

\end{description}

\end{fulllineitems}

\index{get\_parser() (in module infrapy.utils.files2db)@\spxentry{get\_parser()}\spxextra{in module infrapy.utils.files2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.files2db.get_parser}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.files2db.}}\sphinxbfcode{\sphinxupquote{get\_parser}}}{}{}
This is where the command\sphinxhyphen{}line options are defined, to be parsed from argv

argparse.ArgumentParser instance

Test the parser with this syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{sac2db} \PYG{k+kn}{import} \PYG{n}{get\PYGZus{}parser}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{parser} \PYG{o}{=} \PYG{n}{get\PYGZus{}parser}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{options} \PYG{o}{=} \PYG{n}{parser}\PYG{o}{.}\PYG{n}{parse\PYGZus{}args}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}origin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{origin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}affiliation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{g+go}{                                                                 \PYGZsq{}myaffiliation\PYGZsq{}, \PYGZsq{}sqlite:///mydb.sqlite\PYGZsq{},}
\PYG{g+go}{                                                                 \PYGZsq{}*.sac\PYGZsq{}])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{options}
\PYG{g+go}{Namespace(affiliation=\PYGZsq{}my.affiliation\PYGZsq{}, arrival=None,}
\PYG{g+go}{assoc=None, event=None, files=[\PYGZsq{}*.sac\PYGZsq{}], instrument=None, lastid=None,}
\PYG{g+go}{origin=\PYGZsq{}origin\PYGZsq{}, absolute\PYGZus{}path=False, site=None, sitechan=None,}
\PYG{g+go}{url=\PYGZsq{}sqlite:///mydb.sqlite\PYGZsq{}, wfdisc=None)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{get\_plugins() (in module infrapy.utils.files2db)@\spxentry{get\_plugins()}\spxextra{in module infrapy.utils.files2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.files2db.get_plugins}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.files2db.}}\sphinxbfcode{\sphinxupquote{get\_plugins}}}{\emph{options}}{}
Returns a list of imported plugin function objects.

\end{fulllineitems}

\index{get\_session() (in module infrapy.utils.files2db)@\spxentry{get\_session()}\spxextra{in module infrapy.utils.files2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.files2db.get_session}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.files2db.}}\sphinxbfcode{\sphinxupquote{get\_session}}}{\emph{options}}{}
\end{fulllineitems}

\index{get\_wfdisc() (in module infrapy.utils.files2db)@\spxentry{get\_wfdisc()}\spxextra{in module infrapy.utils.files2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.files2db.get_wfdisc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.files2db.}}\sphinxbfcode{\sphinxupquote{get\_wfdisc}}}{\emph{options}}{}
Return a sequence of WFDISC file names from either a list of file names
(trivial) or a text file list (presumable because there are too many files
to use normal shell expansion).

\end{fulllineitems}

\index{main() (in module infrapy.utils.files2db)@\spxentry{main()}\spxextra{in module infrapy.utils.files2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.files2db.main}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.files2db.}}\sphinxbfcode{\sphinxupquote{main}}}{\emph{argv=None}}{}
Command\sphinxhyphen{}line arguments are created and parsed, fed to functions.

\end{fulllineitems}

\index{make\_atomic() (in module infrapy.utils.files2db)@\spxentry{make\_atomic()}\spxextra{in module infrapy.utils.files2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.files2db.make_atomic}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.files2db.}}\sphinxbfcode{\sphinxupquote{make\_atomic}}}{\emph{last}, \emph{**rows}}{}
Unify related table instances/row, including: ids, dir, and dfile

\end{fulllineitems}

\index{ms2db() (in module infrapy.utils.files2db)@\spxentry{ms2db()}\spxextra{in module infrapy.utils.files2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.files2db.ms2db}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.files2db.}}\sphinxbfcode{\sphinxupquote{ms2db}}}{\emph{files}, \emph{url}, \emph{tables}, \emph{plugins=None}, \emph{abs\_paths=False}}{}
\end{fulllineitems}



\subsubsection{infrapy.utils.get\_arraywaveforms module}
\label{\detokenize{infrapy.utils:module-infrapy.utils.get_arraywaveforms}}\label{\detokenize{infrapy.utils:infrapy-utils-get-arraywaveforms-module}}\index{infrapy.utils.get\_arraywaveforms (module)@\spxentry{infrapy.utils.get\_arraywaveforms}\spxextra{module}}\index{get\_arraywaveforms() (in module infrapy.utils.get\_arraywaveforms)@\spxentry{get\_arraywaveforms()}\spxextra{in module infrapy.utils.get\_arraywaveforms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.get_arraywaveforms.get_arraywaveforms}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.get\_arraywaveforms.}}\sphinxbfcode{\sphinxupquote{get\_arraywaveforms}}}{\emph{session}, \emph{Site}, \emph{Wfdisc}, \emph{array}, \emph{t0=None}, \emph{te=None}, \emph{channel=None}}{}
\end{fulllineitems}

\index{get\_channel() (in module infrapy.utils.get\_arraywaveforms)@\spxentry{get\_channel()}\spxextra{in module infrapy.utils.get\_arraywaveforms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.get_arraywaveforms.get_channel}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.get\_arraywaveforms.}}\sphinxbfcode{\sphinxupquote{get\_channel}}}{\emph{session}, \emph{Site}, \emph{Wfdisc}, \emph{array}}{}
\end{fulllineitems}



\subsubsection{infrapy.utils.get\_header\_table module}
\label{\detokenize{infrapy.utils:module-infrapy.utils.get_header_table}}\label{\detokenize{infrapy.utils:infrapy-utils-get-header-table-module}}\index{infrapy.utils.get\_header\_table (module)@\spxentry{infrapy.utils.get\_header\_table}\spxextra{module}}\index{get\_header\_table() (in module infrapy.utils.get\_header\_table)@\spxentry{get\_header\_table()}\spxextra{in module infrapy.utils.get\_header\_table}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.get_header_table.get_header_table}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.get\_header\_table.}}\sphinxbfcode{\sphinxupquote{get\_header\_table}}}{\emph{table\_name}}{}
\end{fulllineitems}



\subsubsection{infrapy.utils.get\_mean\_locations module}
\label{\detokenize{infrapy.utils:module-infrapy.utils.get_mean_locations}}\label{\detokenize{infrapy.utils:infrapy-utils-get-mean-locations-module}}\index{infrapy.utils.get\_mean\_locations (module)@\spxentry{infrapy.utils.get\_mean\_locations}\spxextra{module}}\index{get\_mean\_locations() (in module infrapy.utils.get\_mean\_locations)@\spxentry{get\_mean\_locations()}\spxextra{in module infrapy.utils.get\_mean\_locations}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.get_mean_locations.get_mean_locations}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.get\_mean\_locations.}}\sphinxbfcode{\sphinxupquote{get\_mean\_locations}}}{\emph{session}, \emph{net}, \emph{Affiliation}, \emph{Site}, \emph{t0\_E\_jday}, \emph{te\_E\_jday}}{}
Get mean location information for a given network.

session : SQLAlchemy Session instance
net : str
\begin{quote}

Network code.
\end{quote}
\begin{description}
\item[{Affiliation, Site}] \leavevmode{[}SQLAlchemy ORM mapped table classes{]}
Affiliation, Site classes (not instances).

\item[{t0\_E\_jday, te\_E\_jday}] \leavevmode{[}int{]}
Julian date (YYYJJJ) Site.ondate, offdate.

\end{description}
\begin{description}
\item[{refsta}] \leavevmode{[}list of dict{]}
One dict for each unique refsta, each dict contains mean lat, lon,
elev, values in ‘lat’, ‘lon’, ‘elev’ keys, name of refsta in ‘name’
key, and number of stations in the means in ‘numsta’.

\end{description}

\end{fulllineitems}



\subsubsection{infrapy.utils.latlon module}
\label{\detokenize{infrapy.utils:module-infrapy.utils.latlon}}\label{\detokenize{infrapy.utils:infrapy-utils-latlon-module}}\index{infrapy.utils.latlon (module)@\spxentry{infrapy.utils.latlon}\spxextra{module}}\index{azdiff() (in module infrapy.utils.latlon)@\spxentry{azdiff()}\spxextra{in module infrapy.utils.latlon}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.latlon.azdiff}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.latlon.}}\sphinxbfcode{\sphinxupquote{azdiff}}}{\emph{az1}, \emph{az2}}{}
AZDIFF    Returns the angle between azimuths
\begin{quote}

Usage:    d=azdiff(az1,az2)
\begin{description}
\item[{Description:}] \leavevmode
D=AZDIFF(AZ1,AZ2) calculates the angle D from AZ1 to AZ2.  D is
always within +/\sphinxhyphen{}180.

\end{description}

Notes:
\begin{description}
\item[{Examples:}] \leavevmode
\# 340 \textendash{}\textgreater{} 20 should give 40:
\textgreater{}\textgreater{}\textgreater{} azdiff(340,20)
array({[}{[} 40.{]}{]})

\# 20 \textendash{}\textgreater{} 340 should give \sphinxhyphen{}40:
\textgreater{}\textgreater{}\textgreater{} azdiff(20,340)
array({[}{[}\sphinxhyphen{}40.{]}{]})

\# Several examples with equivalent azimuths:
\textgreater{}\textgreater{}\textgreater{} azdiff({[}180,0,540{]},{[}\sphinxhyphen{}180,720,\sphinxhyphen{}180{]})
array({[}{[} 0.,  0.,  0.{]}{]})

\end{description}

See also: AZMEAN, AZINRNG, INLONRNG, LONMOD, INLATLONBOX, LATMOD
\end{quote}

\end{fulllineitems}

\index{azinrng() (in module infrapy.utils.latlon)@\spxentry{azinrng()}\spxextra{in module infrapy.utils.latlon}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.latlon.azinrng}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.latlon.}}\sphinxbfcode{\sphinxupquote{azinrng}}}{\emph{azrng}, \emph{az}}{}
AZINRNG    Returns TRUE for azimuths within azimuth range
\begin{quote}

Usage:    tf=azinrng(azrng,az)
\begin{description}
\item[{Description:}] \leavevmode
TF=AZINRNG(AZRNG,AZ) returns a logical matrix TF of equal shape to AZ
with each element set to TRUE for the elements of AZ that are within
the range AZRNG as {[}MIN MAX{]} (e.g., including MIN \& MAX).  Note that
wrapping is done on all azimuths.  So if the range is 10 to 20 deg then
values within that range and 370 to 380, \sphinxhyphen{}350 to \sphinxhyphen{}340, etc all are
within the range.  Also note that the range always extends clockwise
from AZMIN to AZMAX.  To get the full azimuth range set the limits such
that AZMAX\sphinxhyphen{}AZMIN equals 360.  If you set AZMIN=0 and AZMAX=361 then you
will actually have a range from 0 to 1.

\item[{Notes:}] \leavevmode\begin{itemize}
\item {} 
This is just a wrapper for INLONRNG.

\end{itemize}

\item[{Examples:}] \leavevmode
\% “Dateline” check:
\textgreater{}\textgreater{}\textgreater{} azinrng({[}178,\sphinxhyphen{}178{]},np.arange(177,184))
array({[}False,  True,  True,  True,  True,  True, False{]}, dtype=bool)

\item[{See also: INLONRNG, AZDIFF, AZMEAN, LONMOD, LATMOD, FIXLATLON,}] \leavevmode
INLATLONBOX

\end{description}
\end{quote}

\end{fulllineitems}

\index{azmean() (in module infrapy.utils.latlon)@\spxentry{azmean()}\spxextra{in module infrapy.utils.latlon}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.latlon.azmean}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.latlon.}}\sphinxbfcode{\sphinxupquote{azmean}}}{\emph{az}, \emph{dim=None}}{}
AZMEAN    Returns the mean azimuth of a set of azimuths
\begin{quote}
\begin{description}
\item[{Usage:    avg=azmean(az)}] \leavevmode
avg=azmean(az,dim)

\item[{Description:}] \leavevmode
AVG=AZMEAN(AZ) returns the average azimuth of the azimuths in AZ.  AZ
is expected in degrees.  Operates down the first non\sphinxhyphen{}singleton
dimension.

AVG=AZMEAN(AZ,DIM) takes the mean across along dimension DIM.

\item[{Notes:}] \leavevmode\begin{itemize}
\item {} 
NaNs are allowed and are ignored.

\end{itemize}

\item[{Examples:}] \leavevmode
\# Average North scattered azimuths:
\textgreater{}\textgreater{}\textgreater{} azmean({[}\sphinxhyphen{}5,\sphinxhyphen{}15,5{]})
array({[}\sphinxhyphen{}5.{]})

\# Test dimension input:
\textgreater{}\textgreater{}\textgreater{} azmean({[}\sphinxhyphen{}5,\sphinxhyphen{}15,5{]},0)
array({[} \sphinxhyphen{}5., \sphinxhyphen{}15.,   5.{]})
\textgreater{}\textgreater{}\textgreater{} azmean({[}\sphinxhyphen{}5,\sphinxhyphen{}15,5{]},1)
array({[}\sphinxhyphen{}5.{]})
\textgreater{}\textgreater{}\textgreater{} azmean({[}{[}\sphinxhyphen{}5,\sphinxhyphen{}15,5{]},{[}20,40,0{]}{]},0)
array({[}  7.5,  12.5,   2.5{]})
\textgreater{}\textgreater{}\textgreater{} azmean({[}{[}\sphinxhyphen{}5,\sphinxhyphen{}15,5{]},{[}20,40,0{]}{]},1)
array({[} \sphinxhyphen{}5.,  20.{]})

\end{description}

See also: AZDIFF, AZINRNG, ARRAYCENTER
\end{quote}

\end{fulllineitems}

\index{fixlatlon() (in module infrapy.utils.latlon)@\spxentry{fixlatlon()}\spxextra{in module infrapy.utils.latlon}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.latlon.fixlatlon}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.latlon.}}\sphinxbfcode{\sphinxupquote{fixlatlon}}}{\emph{latlon}}{}
FIXLATLON    Returns latitudes \& longitudes in reasonable ranges
\begin{quote}

Usage:    latlon=fixlatlon(latlon)
\begin{description}
\item[{Description:}] \leavevmode
LATLON=FIXLATLON(LATLON) returns latitudes within the range +/\sphinxhyphen{}90
and longitudes within +/\sphinxhyphen{}180 taking care to preserve the actual
corresponding location.  The input LATLON must be Nx2 real array.

\end{description}

Notes:
\begin{description}
\item[{Examples:}] \leavevmode
\# Some dumb programs may go “over the pole” in terms of latitude.
\# FIXLATLON can fix this while handling the accompanying shift in
\# longitude:
\textgreater{}\textgreater{}\textgreater{} fixlatlon({[}100, 0{]})
array({[}{[}  80.,  180.{]}{]})

\# Bring some longitudes from 0\sphinxhyphen{}360 to \sphinxhyphen{}180\sphinxhyphen{}180:
\textgreater{}\textgreater{}\textgreater{} fixlatlon({[}{[}80, 210{]},{[}\sphinxhyphen{}45,10{]},{[}\sphinxhyphen{}5,315{]}{]})
array({[}{[}  80., \sphinxhyphen{}150.{]},
\begin{quote}

{[} \sphinxhyphen{}45.,   10.{]},
{[}  \sphinxhyphen{}5.,  \sphinxhyphen{}45.{]}{]})
\end{quote}

\end{description}

See also: LATMOD, LONMOD, INLONRNG, INLATLONBOX
\end{quote}

\end{fulllineitems}

\index{gc\_intersect() (in module infrapy.utils.latlon)@\spxentry{gc\_intersect()}\spxextra{in module infrapy.utils.latlon}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.latlon.gc_intersect}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.latlon.}}\sphinxbfcode{\sphinxupquote{gc\_intersect}}}{\emph{latlona0}, \emph{latlona1}, \emph{latlonb0}, \emph{latlonb1}}{}
GC\_INTERSECT    Return intersection points between great circles
\begin{quote}
\begin{description}
\item[{Usage:    latloni0,latloni1=gc\_intersect(latlona0,latlona1,}] \leavevmode
latlonb0,latlonb1)

\item[{Description:}] \leavevmode
LATLONI0,LATLONI1=GC\_INTERSECT(LATLONA0,LATLONA1,LATLONB0,LATLONB1)
finds the intersection points of great circles given by points
LATLONA0/1 with great circles given by points LATLONB0/1.  Great
circles either intersect twice or are equal.  LATLONI0 has 1
intersection point and LATLONI1 gives the other (antipodal to the
first).  When two great circles are equal both intersection points are
set to NaNs. All LATLON must either be scalar points (1x2) or arrays
(Nx2) with the same shape.  This allows finding intersections between
one great circle and several others or to find intersections between
distinct pairs.  All inputs must be in degrees! Outputs are in degrees.

\item[{Notes:}] \leavevmode\begin{itemize}
\item {} 
Assumes positions are given in geocentric coordinates.

\end{itemize}

\item[{Examples:}] \leavevmode
\#

\item[{See also: DEGDIST\_FROM\_GC, CLOSEST\_POINT\_ON\_GC, GC2LATLON,}] \leavevmode
GCARC2LATLON, GCARC\_INTERSECT

\end{description}
\end{quote}

\end{fulllineitems}

\index{gcarc\_intersect() (in module infrapy.utils.latlon)@\spxentry{gcarc\_intersect()}\spxextra{in module infrapy.utils.latlon}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.latlon.gcarc_intersect}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.latlon.}}\sphinxbfcode{\sphinxupquote{gcarc\_intersect}}}{\emph{latlona0}, \emph{latlona1}, \emph{latlonb0}, \emph{latlonb1}}{}
GCARC\_INTERSECT    Return intersection points between great circle arcs
\begin{quote}

Usage:    latloni=gcarc\_intersect(latlona0,latlona1,latlonb0,latlonb1)
\begin{description}
\item[{Description:}] \leavevmode
LATLONI=GCARC\_INTERSECT(LATLONA0,LATLONA1,LATLONB0,LATLONB1) finds the
intersection points of great circle arcs given by points LATLONA0/1
with great circle arcs given by points LATLONB0/1.  Arcs are the
shortest path between points (no arcs are \textgreater{}180deg in length)!  Great
circle arcs either intersect once or not at all (equal arcs are always
treated as non\sphinxhyphen{}intersecting).  LATLONI gives the intersection points.
When two great circle arcs do not intersect (or are equal) the
corresponding intersection is set to NaNs.  All LATLON must either be
scalar points (1x2) or arrays (Nx2) with the same shape.  This allows
finding intersections between one great circle arc and several others
or to find intersections between distinct pairs.  All inputs must be in
degrees! Outputs are in degrees.

\item[{Notes:}] \leavevmode\begin{itemize}
\item {} 
Arcs are always \textless{}=180deg!

\item {} 
Assumes positions are given in geocentric coordinates.

\end{itemize}

\item[{Examples:}] \leavevmode
\# Simple case:
\textgreater{}\textgreater{}\textgreater{} gcarc\_intersect({[}0,0{]},{[}0,10{]},{[}\sphinxhyphen{}5,5{]},{[}5,5{]})
array({[}{[}\sphinxhyphen{}0.,  5.{]}{]})

\# Do 2 great circle arcs on the same great circle intersect?
\textgreater{}\textgreater{}\textgreater{} gcarc\_intersect({[}0,0{]},{[}0,10{]},{[}0,5{]},{[}0,15{]})
array({[}{[} nan,  nan{]}{]})

\# How about endpoints?
\textgreater{}\textgreater{}\textgreater{} gcarc\_intersect({[}0,0{]},{[}0,10{]},{[}0,0{]},{[}10,0{]})
array({[}{[} nan,  nan{]}{]})
\textgreater{}\textgreater{}\textgreater{} gcarc\_intersect({[}0,0{]},{[}0,10{]},{[}\sphinxhyphen{}10,0{]},{[}10,0{]})
array({[}{[} nan,  nan{]}{]})

\# You can also do several intersections:
\textgreater{}\textgreater{}\textgreater{} gcarc\_intersect({[}0,0{]},{[}0,10{]},{[}{[}0,5{]},{[}\sphinxhyphen{}5,5{]}{]},{[}{[}0,15{]},{[}5,5{]}{]})
array({[}{[} nan,  nan{]},
\begin{quote}

{[} \sphinxhyphen{}0.,   5.{]}{]})
\end{quote}

\item[{See also: DEGDIST\_FROM\_GC, CLOSEST\_POINT\_ON\_GC, GC2LATLON,}] \leavevmode
GCARC2LATLON, GC\_INTERSECT

\end{description}
\end{quote}

\end{fulllineitems}

\index{geocentric2geographiclat() (in module infrapy.utils.latlon)@\spxentry{geocentric2geographiclat()}\spxextra{in module infrapy.utils.latlon}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.latlon.geocentric2geographiclat}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.latlon.}}\sphinxbfcode{\sphinxupquote{geocentric2geographiclat}}}{\emph{lat}, \emph{ecc=0.08181919084262149}}{}
GEOCENTRIC2GEOGRAPHICLAT    Convert latitude from geocentric to geographic
\begin{quote}
\begin{description}
\item[{Usage:    lat=geocentric2geographiclat(lat)}] \leavevmode
lat=geocentric2geographiclat(lat,ecc)

\item[{Description:}] \leavevmode
LAT=GEOCENTRIC2GEOGRAPHICLAT(LAT) converts geocentric latitudes LAT to
geographic latitudes.  LAT is in degrees.  Assumes the WGS\sphinxhyphen{}84 reference
ellipsoid.

LAT=GEOCENTRIC2GEOGRAPHICLAT(LAT,ECC) specifies the eccentricity for
the ellipsoid to use in the conversion.

\item[{Notes:}] \leavevmode\begin{itemize}
\item {} 
If the location is not on the surface use GEOCENTRIC2GEOGRAPHIC.

\end{itemize}

\item[{Examples:}] \leavevmode
\# At what geographic latitude is 45N \& 60N?:
\textgreater{}\textgreater{}\textgreater{} geocentric2geographiclat((45,60))
array({[} 45.19242322,  60.16636419{]})

\# Show the difference in latitudes (geographic pushes to the poles):
import matplotlib.pyplot as plt
x=np.arange(\sphinxhyphen{}90,91)
plt.plot(x,geocentric2geographiclat(x)\sphinxhyphen{}x)
plt.xlabel(‘geocentric latitude (\textasciicircum{}o)’)
plt.ylabel(‘geographic adjustment (\textasciicircum{}o)’)
plt.show()

\end{description}

See also: GEOGRAPHIC2GEOCENTRICLAT, GEOGRAPHICLAT2RADIUS
\end{quote}

\end{fulllineitems}

\index{geocentric2xyz() (in module infrapy.utils.latlon)@\spxentry{geocentric2xyz()}\spxextra{in module infrapy.utils.latlon}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.latlon.geocentric2xyz}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.latlon.}}\sphinxbfcode{\sphinxupquote{geocentric2xyz}}}{\emph{latlon}, \emph{radius=1.0}}{}
GEOCENTRIC2XYZ    Converts coordinates from geocentric to cartesian
\begin{quote}
\begin{description}
\item[{Usage:    xyz=geocentric2xyz(latlon)}] \leavevmode
xyz=geocentric2xyz(latlon,radius)

\item[{Description:}] \leavevmode
XYZ=GEOCENTRIC2XYZ(LATLON) converts coordinates in geocentric latitude,
longitude, radius to Earth\sphinxhyphen{}centered, Earth\sphinxhyphen{}Fixed (ECEF).  LATLON is in
degrees and should be a Nx2 array.  XYZ will contain unit vectors.

XYZ=GEOCENTRIC2XYZ(LATLON,RADIUS) converts coordinates in geocentric
latitude, longitude, radius to Earth\sphinxhyphen{}centered, Earth\sphinxhyphen{}Fixed (ECEF).
LATLON is in degrees and should be a Nx2 array.  XYZ will match the
units of RADIUS.

\item[{Notes:}] \leavevmode\begin{itemize}
\item {} 
The ECEF coordinate system has the X axis passing through the
equator at the prime meridian, the Z axis through the north pole
and the Y axis through the equator at 90 degrees longitude.

\end{itemize}

\item[{Examples:}] \leavevmode
\# Test the ECEF definition:
\textgreater{}\textgreater{}\textgreater{} geocentric2xyz({[}{[}0,0{]},{[}0,90{]},{[}90,0{]}{]},{[}{[}1{]},{[}1{]},{[}1{]}{]})
array({[}{[}  1.00000000e+00,   0.00000000e+00,   0.00000000e+00{]},
\begin{quote}

{[}  6.12323400e\sphinxhyphen{}17,   1.00000000e+00,   0.00000000e+00{]},
{[}  6.12323400e\sphinxhyphen{}17,   0.00000000e+00,   1.00000000e+00{]}{]})
\end{quote}

\end{description}

See also: XYZ2GEOCENTRIC
\end{quote}

\end{fulllineitems}

\index{geographic2geocentriclat() (in module infrapy.utils.latlon)@\spxentry{geographic2geocentriclat()}\spxextra{in module infrapy.utils.latlon}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.latlon.geographic2geocentriclat}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.latlon.}}\sphinxbfcode{\sphinxupquote{geographic2geocentriclat}}}{\emph{lat}, \emph{ecc=0.08181919084262149}}{}
GEOGRAPHIC2GEOCENTRICLAT    Convert latitude from geographic to geocentric
\begin{quote}
\begin{description}
\item[{Usage:    lat=geographic2geocentriclat(lat)}] \leavevmode
lat=geographic2geocentriclat(lat,ecc)

\item[{Description:}] \leavevmode
LAT=GEOGRAPHIC2GEOCENTRICLAT(LAT) converts geographic latitudes LAT to
geocentric latitudes.  LAT is in degrees.  Assumes the WGS\sphinxhyphen{}84 reference
ellipsoid.

LAT=GEOGRAPHIC2GEOCENTRICLAT(LAT,ECC) specifies the eccentricity for
the ellipsoid to use in the conversion.

\item[{Notes:}] \leavevmode\begin{itemize}
\item {} 
If the location is not on the surface use GEOGRAPHIC2GEOCENTRIC.

\end{itemize}

\item[{Examples:}] \leavevmode
\# Get the geocentric latitude for St. Louis, MO \& Los Alamos, NM:
\textgreater{}\textgreater{}\textgreater{} geographic2geocentriclat((38.649,35.891))
array({[} 38.46142446,  35.70841385{]})

\% Show the difference in latitudes (geocentric pushes to the equator):
import matplotlib.pyplot as plt
x=np.arange(\sphinxhyphen{}90,91)
plt.plot(x,geographic2geocentriclat(x)\sphinxhyphen{}x)
plt.xlabel(‘geographic latitude (\textasciicircum{}o)’)
plt.ylabel(‘geocentric adjustment (\textasciicircum{}o)’)
plt.show()

\end{description}

See also: GEOCENTRIC2GEOGRAPHICLAT, GEOGRAPHICLAT2RADIUS
\end{quote}

\end{fulllineitems}

\index{geographiclat2radius() (in module infrapy.utils.latlon)@\spxentry{geographiclat2radius()}\spxextra{in module infrapy.utils.latlon}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.latlon.geographiclat2radius}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.latlon.}}\sphinxbfcode{\sphinxupquote{geographiclat2radius}}}{\emph{lat}, \emph{ellipsoid=None}}{}
GEOGRAPHICLAT2RADIUS    Returns the radius at a geographic latitude
\begin{quote}
\begin{description}
\item[{Usage:    radius=geographiclat2radius(lat)}] \leavevmode
radius=geographiclat2radius(lat,ellipsoid)

\item[{Description:}] \leavevmode
RADIUS=GEOGRAPHICLAT2RADIUS(LAT) returns the radii at geographic
latitudes in LAT.  LAT must be in degrees.  Assumes the WGS\sphinxhyphen{}84
reference ellipsoid.

RADIUS=GEOGRAPHICLAT2RADIUS(LAT,ELLIPSOID) allows specifying the
ellipsoid as {[}A, F{]} where the parameters A (equatorial radius in
kilometers) and F (flattening) must be scalar and float.

\end{description}

Notes:
\begin{description}
\item[{Examples:}] \leavevmode
\# Get the radius for St. Louis, MO \& Los Alamos, NM:
\textgreater{}\textgreater{}\textgreater{} geographiclat2radius((38.649,35.891))
array({[} 6369.83836784,  6370.82788438{]})

\# What is the radius at the pole \& equator?:
\textgreater{}\textgreater{}\textgreater{} geographiclat2radius((90,0))
array({[} 6356.75231425,  6378.137     {]})

\end{description}

See also: GEOCENTRIC2GEOGRAPHICLAT, GEOGRAPHIC2GEOCENTRICLAT
\end{quote}

\end{fulllineitems}

\index{haversine() (in module infrapy.utils.latlon)@\spxentry{haversine()}\spxextra{in module infrapy.utils.latlon}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.latlon.haversine}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.latlon.}}\sphinxbfcode{\sphinxupquote{haversine}}}{\emph{latlon0}, \emph{latlon1}}{}
HAVERSINE    Returns distance between 2 points using the Haversine formula
\begin{quote}

Usage:    gcdist=haversine(latlon0,latlon1)
\begin{description}
\item[{Description:}] \leavevmode
GCDIST=HAVERSINE(LATLON0,LATLON1) finds the spherical great\sphinxhyphen{}circle\sphinxhyphen{}arc
degree distance between two points GCDIST.  LATLON0 \& LATLON1 must all
be in degrees and the latitudes must be geocentric.

\item[{Notes:}] \leavevmode\begin{itemize}
\item {} 
‘half versed sine’ is better suited for accuracy at small distances
compared to SPHERICALINV as it uses a half\sphinxhyphen{}versed sine function
rather than a cosine which becomes inefficient at small distances.

\end{itemize}

\item[{Examples:}] \leavevmode
\# Plot distance discrepancy for SPHERICALINV and HAVERSINE:
d2m=1000*6371*np.pi/180
d0=10**(np.linspace(\sphinxhyphen{}1,7.2,num=83))/d2m
d0=d0{[}:,np.newaxis{]}
pos=np.zeros((83,2))
pos{[}:,{[}1{]}{]}=d0
dc,\_,\_=sphericalinv((0,0),pos)
dh=haversine((0,0),pos)
hsph,=plt.plot(d2m*d0,d2m*abs(d0\sphinxhyphen{}dc),’r’,label=’SPHERICALINV’)
hhav,=plt.plot(d2m*d0,d2m*abs(d0\sphinxhyphen{}dh),’g’,label=’HAVERSINE’)
plt.xscale(‘log’)
plt.yscale(‘log’)
plt.xlabel(‘distance (m)’)
plt.ylabel(‘discrepancy (m)’)
plt.legend(handles={[}hsph,hhav{]})
plt.show()
\# demonstrates convincingly this function is more accurate!

\# St. Louis, MO to Yaounde, Cameroon:
\textgreater{}\textgreater{}\textgreater{} haversine((38.649,\sphinxhyphen{}90.305),(3.861,11.521))
array({[}{[} 96.75578437{]}{]})

\# St. Louis, MO to Isla Isabella, Galapagos:
\textgreater{}\textgreater{}\textgreater{} haversine((38.649,\sphinxhyphen{}90.305),(\sphinxhyphen{}0.823,\sphinxhyphen{}91.097))
array({[}{[} 39.47872366{]}{]})

\# St. Louis, MO to Los Alamos, NM:
\textgreater{}\textgreater{}\textgreater{} haversine((38.649,\sphinxhyphen{}90.305),(35.891,\sphinxhyphen{}106.298))
array({[}{[} 13.00431661{]}{]})

\end{description}

See also: SPHERICALINV, VINCENTYINV, SPHERICALFWD, VINCENTYFWD
\end{quote}

\end{fulllineitems}

\index{inlatlonbox() (in module infrapy.utils.latlon)@\spxentry{inlatlonbox()}\spxextra{in module infrapy.utils.latlon}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.latlon.inlatlonbox}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.latlon.}}\sphinxbfcode{\sphinxupquote{inlatlonbox}}}{\emph{latrng}, \emph{lonrng}, \emph{latlon}}{}
INLATLONBOX    Returns TRUE for positions within the specified region

Usage:    tf=inlatlonbox(latrng,lonrng,latlon)

Description:
TF=INLATLONBOX(LATRNG,LONRNG,LATLON) returns TRUE or FALSE depending
on if the positions given by LATLON are within the region specified
by LATRNG \& LONRNG.  LATRNG \& LONRNG should be specified as {[}MIN MAX{]}
and LATLON should be given as {[}LAT LON{]}.  TF is a NROWSx1 logical
array where NROWS is the number of rows in LATLON.

Notes:
\sphinxhyphen{} Does not call FIXLATLON!

Examples:
\# Make a region covering 1/4th the Earth and see how close to 1/4th
\# of a random set of positions is in the region:
np.sum(inlatlonbox({[}0 90{]},{[}0 180{]},randlatlon(1000)))/1000

\# Longitude wrapping just works:
\textgreater{}\textgreater{}\textgreater{} inlatlonbox({[}0,45{]},{[}160, 200{]},{[}{[}30,\sphinxhyphen{}170{]},{[}0,\sphinxhyphen{}180{]},{[}20,190{]}{]})
array({[} True,  True,  True{]}, dtype=bool)
\textgreater{}\textgreater{}\textgreater{} inlatlonbox({[}0,45{]},{[}160, 200{]},{[}{[}30,\sphinxhyphen{}160{]},{[}45,180{]},{[}\sphinxhyphen{}20,\sphinxhyphen{}170{]}{]})
array({[} True,  True, False{]}, dtype=bool)

\# Test pole handling:
\textgreater{}\textgreater{}\textgreater{} inlatlonbox({[}90,90{]},{[}180,180{]},{[}90,0{]})
array({[}False{]}, dtype=bool)
\textgreater{}\textgreater{}\textgreater{} inlatlonbox({[}90,90{]},{[}180,180{]},{[}90,180{]})
array({[} True{]}, dtype=bool)
\textgreater{}\textgreater{}\textgreater{} inlatlonbox({[}90,90{]},{[}180,180{]},{[}90,\sphinxhyphen{}180{]})
array({[} True{]}, dtype=bool)

See also: INLONRNG, FIXLATLON, LATMOD, LONMOD, AZINRNG

\end{fulllineitems}

\index{inlonrng() (in module infrapy.utils.latlon)@\spxentry{inlonrng()}\spxextra{in module infrapy.utils.latlon}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.latlon.inlonrng}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.latlon.}}\sphinxbfcode{\sphinxupquote{inlonrng}}}{\emph{rng}, \emph{lon}}{}
INLONRNG    Returns TRUE for longitudes within the specified range
\begin{quote}

Usage:    tf=inlonrng(rng,lon)
\begin{description}
\item[{Description:}] \leavevmode
TF=INLONRNG(RNG,LON) returns TRUE or FALSE depending on if LON is in
the longitude range specified by RNG.  RNG must be {[}MIN MAX{]} and
handles wraparound of longitudes.

\end{description}

Notes:
\begin{description}
\item[{Examples:}] \leavevmode
\% A few tests that should return TRUE:
\textgreater{}\textgreater{}\textgreater{} inlonrng({[}\sphinxhyphen{}10, 10{]},360)
array({[} True{]}, dtype=bool)
\textgreater{}\textgreater{}\textgreater{} inlonrng({[}170, 190{]},\sphinxhyphen{}180)
array({[} True{]}, dtype=bool)
\textgreater{}\textgreater{}\textgreater{} inlonrng({[}170, 190{]},180)
array({[} True{]}, dtype=bool)
\textgreater{}\textgreater{}\textgreater{} inlonrng({[}\sphinxhyphen{}190, \sphinxhyphen{}170{]},\sphinxhyphen{}180)
array({[} True{]}, dtype=bool)
\textgreater{}\textgreater{}\textgreater{} inlonrng({[}\sphinxhyphen{}190, \sphinxhyphen{}170{]},180)
array({[} True{]}, dtype=bool)
\textgreater{}\textgreater{}\textgreater{} inlonrng({[}350, 370{]},0)
array({[} True{]}, dtype=bool)

\% A few tougher cases that should return TRUE:
\textgreater{}\textgreater{}\textgreater{} inlonrng({[}0, 0{]},360)
array({[} True{]}, dtype=bool)
\textgreater{}\textgreater{}\textgreater{} inlonrng({[}180, 180{]},\sphinxhyphen{}180)
array({[} True{]}, dtype=bool)
\textgreater{}\textgreater{}\textgreater{} inlonrng({[}180, 180{]},180)
array({[} True{]}, dtype=bool)
\textgreater{}\textgreater{}\textgreater{} inlonrng({[}\sphinxhyphen{}180, \sphinxhyphen{}180{]},\sphinxhyphen{}180)
array({[} True{]}, dtype=bool)
\textgreater{}\textgreater{}\textgreater{} inlonrng({[}\sphinxhyphen{}180, \sphinxhyphen{}180{]},180) \# FIXME IT FAILS
array({[} True{]}, dtype=bool)
\textgreater{}\textgreater{}\textgreater{} inlonrng({[}360, 360{]},0)
array({[} True{]}, dtype=bool)

\% Yet more cases that should return TRUE:
\textgreater{}\textgreater{}\textgreater{} inlonrng({[}0, 360{]},0)
array({[} True{]}, dtype=bool)
\textgreater{}\textgreater{}\textgreater{} inlonrng({[}0, 360{]},360)
array({[} True{]}, dtype=bool)
\textgreater{}\textgreater{}\textgreater{} inlonrng({[}\sphinxhyphen{}180, 180{]},\sphinxhyphen{}180)
array({[} True{]}, dtype=bool)
\textgreater{}\textgreater{}\textgreater{} inlonrng({[}\sphinxhyphen{}180, 180{]},180)
array({[} True{]}, dtype=bool)

\end{description}

See also: AZINRNG, LONMOD, LATMOD, FIXLATLON, INLATLONBOX
\end{quote}

\end{fulllineitems}

\index{latmod() (in module infrapy.utils.latlon)@\spxentry{latmod()}\spxextra{in module infrapy.utils.latlon}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.latlon.latmod}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.latlon.}}\sphinxbfcode{\sphinxupquote{latmod}}}{\emph{lat}, \emph{wrap=90}}{}
LATMOD    Returns a latitude modulus (i.e., wraps latitudes into range)
\begin{quote}
\begin{description}
\item[{Usage:    wlat,px=latmod(lat)}] \leavevmode
wlat,px=latmod(lat,wrap)

\item[{Description:}] \leavevmode
WLAT,PX=LATMOD(LAT) returns latitudes LAT to be within the range +/\sphinxhyphen{}90
and  also returns the number of pole\sphinxhyphen{}crossings each latitude in LAT
made in PX.  For example, if LAT=100 \& WRAP=90 then WLAT=80 \& PX=1.
This is useful for coupling LATMOD with LONMOD to preserve the
positions while reducing the values to reasonable ranges.  See the
Examples section below for instructions on how to use this output.
Note that LATMOD expects floats and so integers are converted to
floats such that WLAT and PX are always float.  LAT may be a numpy
array.

WLAT,PX=LATMOD(LAT,WRAP) is S.*(LAT\sphinxhyphen{}N.*WRAP) where N=round(LAT./WRAP)
if WRAP\textasciitilde{}=0 and S=1\sphinxhyphen{}2.*MOD(N,2).  Thus LATMOD(LAT,WRAP) is always
within the range +/\sphinxhyphen{}WRAP and forms a continuous function (but is
discontinuous in the 1st derivative) that looks like a “triangle wave”.
The function is primarily intended for wrapping latitude values back
to a valid range.  The inputs LAT and WRAP must be equal in shape or
scalar.  WRAP is optional and defaults to 90.

\item[{Notes:}] \leavevmode\begin{description}
\item[{By convention:}] \leavevmode
C,PX=latmod(A,0) returns C=A, PX=inf
C,PX=latmod(A,A) returns C=A, PX=0
C,PX=latmod(0,0) returns C=0, PX=nan

\end{description}

\item[{Examples:}] \leavevmode
\# Modifying the latitude should also take into account the longitude
\# shift necessary to preserve the actual position.  This may be done
\# by utilizing the second output to shift the longitude by 180 degrees
\# if there are an odd number of pole\sphinxhyphen{}crossings:
lat,px=latmod(lat)
lon=lonmod(lon+np.mod(px,2)*180)

\# Try a few cases:
\textgreater{}\textgreater{}\textgreater{} latmod((\sphinxhyphen{}89,\sphinxhyphen{}90,\sphinxhyphen{}91))
(array({[}\sphinxhyphen{}89., \sphinxhyphen{}90., \sphinxhyphen{}89.{]}), array({[}\sphinxhyphen{}0.,  0.,  1.{]}))
\textgreater{}\textgreater{}\textgreater{} latmod((\sphinxhyphen{}269,\sphinxhyphen{}270,\sphinxhyphen{}271))
(array({[} 89.,  90.,  89.{]}), array({[} 1.,  1.,  2.{]}))
\textgreater{}\textgreater{}\textgreater{} latmod((89,90,91))
(array({[} 89.,  90.,  89.{]}), array({[}\sphinxhyphen{}0.,  0.,  1.{]}))
\textgreater{}\textgreater{}\textgreater{} latmod((269,270,271))
(array({[}\sphinxhyphen{}89., \sphinxhyphen{}90., \sphinxhyphen{}89.{]}), array({[} 1.,  1.,  2.{]}))

\# Now playing with wrap=0:
\textgreater{}\textgreater{}\textgreater{} latmod((180, 0, 54.3),0)
(array({[} 180. ,    0. ,   54.3{]}), array({[} inf,  nan,  inf{]}))

\end{description}

See also: LONMOD, FIXLATLON, INLONRNG, INLATLONBOX
\end{quote}

\end{fulllineitems}

\index{lonmod() (in module infrapy.utils.latlon)@\spxentry{lonmod()}\spxextra{in module infrapy.utils.latlon}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.latlon.lonmod}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.latlon.}}\sphinxbfcode{\sphinxupquote{lonmod}}}{\emph{lon}, \emph{wrap=360}}{}
LONMOD    Returns a longitude modulus (i.e., wraps longitudes into range)
\begin{quote}
\begin{description}
\item[{Usage:    wlon=lonmod(lon)}] \leavevmode
wlon=lonmod(lon,wrap)

\item[{Description:}] \leavevmode
WLON=LONMOD(LON) returns the longitudes LON within the range +/\sphinxhyphen{}180.
For example, LON=181 is output as \sphinxhyphen{}179.  See the other usage form for
more algorithm details.  LON must be array\_like and composed of floats
or integers.  WLON is an ndarray of floats.

WLON=LONMOD(LON,WRAP) is LON\sphinxhyphen{}N.*WRAP where N=round(LON./WRAP) if
WRAP\textasciitilde{}=0.  Thus LONMOD(LON,WRAP) is always within the range +/\sphinxhyphen{}(WRAP/2).
The inputs LON and WRAP must be equal in shape or scalar.  WRAP is
optional and defaults to 360.

\item[{Notes:}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{By convention:}] \leavevmode
C=lonmod(A,0) returns C=A
C=lonmod(A,A) returns C=0

\end{description}

\end{itemize}

\item[{Examples:}] \leavevmode
\# Try a few cases:
\textgreater{}\textgreater{}\textgreater{} lonmod((181, 180, \sphinxhyphen{}180, \sphinxhyphen{}181, 360, \sphinxhyphen{}360, 540, \sphinxhyphen{}540))
array({[}\sphinxhyphen{}179.,  180., \sphinxhyphen{}180.,  179.,    0.,    0.,  180., \sphinxhyphen{}180.{]})

\# Now playing with wrap=0:
\textgreater{}\textgreater{}\textgreater{} lonmod((180, 0, 54.3),0)
array({[} 180. ,    0. ,   54.3{]})

\# wrap=lon:
\textgreater{}\textgreater{}\textgreater{} lonmod((180, 0, 54.3),(180, 0, 54.3))
array({[} 0.,  0.,  0.{]})

\end{description}

See also: LATMOD, FIXLATLON, INLONRNG, INLATLONBOX
\end{quote}

\end{fulllineitems}

\index{randlatlon() (in module infrapy.utils.latlon)@\spxentry{randlatlon()}\spxextra{in module infrapy.utils.latlon}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.latlon.randlatlon}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.latlon.}}\sphinxbfcode{\sphinxupquote{randlatlon}}}{\emph{n}}{}
RANDLATLON    Returns lat/lon points uniformly distributed on a sphere
\begin{quote}

Usage:    latlon=randlatlon(n)
\begin{description}
\item[{Description:}] \leavevmode
LATLON=RANDLATLON(N) returns the random position of N points uniformly
distributed on a sphere (not within).  The output LATLON is formatted
as a Nx2 array of {[}LAT LON{]} where the latitudes and longitudes are in
degrees.  Longitudes are in the range \sphinxhyphen{}180 to 180 degrees.

\end{description}

Notes:
\begin{description}
\item[{Examples:}] \leavevmode
\# Get 5 random points in latitude \& longitude:
randlatlon(5)

\# Map 1000 random lat/lon points:
p=randlatlon(1000)
from mpl\_toolkits.basemap import Basemap
import matplotlib.pyplot as plt
map=Basemap(projection=’hammer’,lon\_0=0)
map.drawcoastlines()
x,y=map(p{[}:,1{]},p{[}:,0{]})
map.plot(x,y,’ro’)
plt.show()

\# Output is Nx2:
\textgreater{}\textgreater{}\textgreater{} np.shape(randlatlon(1000))
(1000, 2)

\end{description}

See also: RANDSPHERE
\end{quote}

\end{fulllineitems}

\index{randsphere() (in module infrapy.utils.latlon)@\spxentry{randsphere()}\spxextra{in module infrapy.utils.latlon}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.latlon.randsphere}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.latlon.}}\sphinxbfcode{\sphinxupquote{randsphere}}}{\emph{n}, \emph{dim=3}}{}
RANDSPHERE    Returns points uniformly distributed within a sphere
\begin{quote}
\begin{description}
\item[{Usage:    x=randsphere(n)}] \leavevmode
x=randsphere(n,dim)

\item[{Description:}] \leavevmode
X=RANDSPHERE(N) returns the random positions of N points uniformly
distributed within a unit sphere.  The output X is a Nx3 array of
cartesian coordinates.

X=RANDSPHERE(N,DIM) allows getting points in an DIM dimensional sphere.
DIM should be a scalar integer \textgreater{}=2.

\end{description}

Notes:
\begin{description}
\item[{Examples:}] \leavevmode
\# Return 1000 points and plot in 3D:
x=randsphere(1000)
import matplotlib.pyplot as plt
from mpl\_toolkits.mplot3d import Axes3D
fig = plt.figure()
ax = Axes3D(fig)
ax.scatter(x{[}:,0{]},x{[}:,1{]},x{[}:,2{]})
plt.show()

\# output is NxM
\textgreater{}\textgreater{}\textgreater{} np.shape(randsphere(1000))
(1000, 3)
\textgreater{}\textgreater{}\textgreater{} np.shape(randsphere(1000,5))
(1000, 5)

\end{description}

See also: RANDLATLON
\end{quote}

\end{fulllineitems}

\index{sphericalfwd() (in module infrapy.utils.latlon)@\spxentry{sphericalfwd()}\spxextra{in module infrapy.utils.latlon}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.latlon.sphericalfwd}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.latlon.}}\sphinxbfcode{\sphinxupquote{sphericalfwd}}}{\emph{latlon0}, \emph{gcdist}, \emph{az}}{}
SPHERICALFWD    Finds a point on a sphere relative to another point
\begin{quote}

Usage:    latlon1,baz=sphericalfwd(latlon0,gcdist,az)
\begin{description}
\item[{Description:}] \leavevmode
LATLON1,BAZ=SPHERICALFWD(LATLON0,GCDIST,AZ) finds geocentric latitudes
and longitudes in LATLON1 of destination point(s), as well as the back
azimuths BAZ, given the great circle distances GCDIST and forward
azimuths AZ from initial point(s) with geocentric latitudes and
longitudes in LATLON0.  Inputs must all be in degrees.  Outputs are
also all in degrees.

\item[{Notes:}] \leavevmode\begin{itemize}
\item {} 
Latitudes are geocentric (0 deg lat == equator, range +/\sphinxhyphen{}90)

\item {} 
Longitudes are returned in the range +/\sphinxhyphen{}180

\item {} 
Backazimuth is returned in the range 0\sphinxhyphen{}360

\end{itemize}

\item[{Examples:}] \leavevmode
\# Heading 45deg NW of St. Louis, MO to ???:
\textgreater{}\textgreater{}\textgreater{} sphericalfwd((38.649,\sphinxhyphen{}90.305),45,\sphinxhyphen{}30)
(array({[}{[}  66.90805234, \sphinxhyphen{}154.65352366{]}{]}), array({[}{[} 95.35931627{]}{]}))

\# Go 10deg South of Los Alamos, NM to ???:
\textgreater{}\textgreater{}\textgreater{} sphericalfwd((35.891,106.298),10,180)
(array({[}{[}  25.891,  106.298{]}{]}), array({[}{[} 0.{]}{]}))

\end{description}

See also: SPHERICALINV
\end{quote}

\end{fulllineitems}

\index{sphericalinv() (in module infrapy.utils.latlon)@\spxentry{sphericalinv()}\spxextra{in module infrapy.utils.latlon}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.latlon.sphericalinv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.latlon.}}\sphinxbfcode{\sphinxupquote{sphericalinv}}}{\emph{latlon0}, \emph{latlon1}}{}
SPHERICALINV    Return distance and azimuths between 2 locations on sphere
\begin{quote}

Usage:    gcdist,az,baz=sphericalinv(latlon0,latlon1)
\begin{description}
\item[{Description:}] \leavevmode
GCDIST,AZ,BAZ=SPHERICALINV(LATLON0,LATLON1) returns the
great\sphinxhyphen{}circle\sphinxhyphen{}arc degree distances GCDIST, forward azimuths AZ and
backward azimuths BAZ between initial point(s) with geocentric
latitudes and longitudes LATLON0 and final point(s) with geocentric
latitudes and longitudes LATLON1 on a sphere.  Inputs must be in
degrees.  Outputs are also all in degrees.

\item[{Notes:}] \leavevmode\begin{itemize}
\item {} 
Will always return the shorter distance (GCDIST\textless{}=180)

\item {} 
GCDIST accuracy degrades when \textless{} 3000km (see HAVERSINE example!)

\item {} 
Azimuths are returned in the range 0\textless{}=az\textless{}=360

\end{itemize}

\item[{Examples:}] \leavevmode
\# St. Louis, MO to Yaounde, Cameroon:
\textgreater{}\textgreater{}\textgreater{} sphericalinv((38.649,\sphinxhyphen{}90.305),(3.861,11.521))
(array({[}{[} 96.75578437{]}{]}), array({[}{[} 79.53972827{]}{]}), array({[}{[} 309.66814964{]}{]}))

\# St. Louis, MO to Isla Isabella, Galapagos:
\textgreater{}\textgreater{}\textgreater{} sphericalinv((38.649,\sphinxhyphen{}90.305),(\sphinxhyphen{}0.823,\sphinxhyphen{}91.097))
(array({[}{[} 39.47872366{]}{]}), array({[}{[} 181.24562107{]}{]}), array({[}{[} 0.97288389{]}{]}))

\# St. Louis, MO to Los Alamos, NM:
\textgreater{}\textgreater{}\textgreater{} sphericalinv((38.649,\sphinxhyphen{}90.305),(35.891,\sphinxhyphen{}106.298))
(array({[}{[} 13.00431661{]}{]}), array({[}{[} 262.71497244{]}{]}), array({[}{[} 72.98729659{]}{]}))

\end{description}

See also: SPHERICALFWD
\end{quote}

\end{fulllineitems}

\index{xyz2geocentric() (in module infrapy.utils.latlon)@\spxentry{xyz2geocentric()}\spxextra{in module infrapy.utils.latlon}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.latlon.xyz2geocentric}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.latlon.}}\sphinxbfcode{\sphinxupquote{xyz2geocentric}}}{\emph{xyz}}{}
XYZ2GEOCENTRIC    Converts coordinates from cartesian to geocentric
\begin{quote}

Usage:    latlon,radius=xyz2geocentric(xyz)
\begin{description}
\item[{Description:}] \leavevmode
LATLON,RADIUS=XYZ2GEOCENTRIC(XYZ) converts arrays of coordinates in
Earth\sphinxhyphen{}centered, Earth\sphinxhyphen{}Fixed (ECEF) to geocentric latitude, longitude, \&
radius.  LAT and LON are in degrees.  X, Y and Z of XYZ (a Nx3 array of
floats) must have the same units (RADIUS will will be in those units).

\item[{Notes:}] \leavevmode\begin{itemize}
\item {} 
The ECEF coordinate system has the X axis passing through the equator
at the prime meridian, the Z axis through the north pole and the Y
axis through the equator at 90 degrees longitude.

\end{itemize}

\item[{Examples:}] \leavevmode
\# Test the ECEF definition:
\textgreater{}\textgreater{}\textgreater{} xyz2geocentric({[}{[}1, 0, 0{]},{[}0, 1, 0{]},{[}0, 0, 1{]}{]})
(array({[}{[}  0.,   0.{]},
\begin{quote}

{[}  0.,  90.{]},
{[} 90.,   0.{]}{]}), array({[}{[} 1.{]},
{[} 1.{]},
{[} 1.{]}{]}))
\end{quote}

\end{description}

See also: GEOCENTRIC2XYZ
\end{quote}

\end{fulllineitems}



\subsubsection{infrapy.utils.ms2db module}
\label{\detokenize{infrapy.utils:module-infrapy.utils.ms2db}}\label{\detokenize{infrapy.utils:infrapy-utils-ms2db-module}}\index{infrapy.utils.ms2db (module)@\spxentry{infrapy.utils.ms2db}\spxextra{module}}\index{CoreTable (class in infrapy.utils.ms2db)@\spxentry{CoreTable}\spxextra{class in infrapy.utils.ms2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ms2db.CoreTable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{infrapy.utils.ms2db.}}\sphinxbfcode{\sphinxupquote{CoreTable}}}{\emph{name}, \emph{prototype}, \emph{table}}{}
Bases: \sphinxcode{\sphinxupquote{tuple}}
\index{name() (infrapy.utils.ms2db.CoreTable property)@\spxentry{name()}\spxextra{infrapy.utils.ms2db.CoreTable property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ms2db.CoreTable.name}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{name}}}
Alias for field number 0

\end{fulllineitems}

\index{prototype() (infrapy.utils.ms2db.CoreTable property)@\spxentry{prototype()}\spxextra{infrapy.utils.ms2db.CoreTable property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ms2db.CoreTable.prototype}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{prototype}}}
Alias for field number 1

\end{fulllineitems}

\index{table() (infrapy.utils.ms2db.CoreTable property)@\spxentry{table()}\spxextra{infrapy.utils.ms2db.CoreTable property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ms2db.CoreTable.table}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{table}}}
Alias for field number 2

\end{fulllineitems}


\end{fulllineitems}

\index{apply\_plugins() (in module infrapy.utils.ms2db)@\spxentry{apply\_plugins()}\spxextra{in module infrapy.utils.ms2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ms2db.apply_plugins}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ms2db.}}\sphinxbfcode{\sphinxupquote{apply\_plugins}}}{\emph{plugins}, \emph{**rows}}{}
\end{fulllineitems}

\index{dicts2rows() (in module infrapy.utils.ms2db)@\spxentry{dicts2rows()}\spxextra{in module infrapy.utils.ms2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ms2db.dicts2rows}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ms2db.}}\sphinxbfcode{\sphinxupquote{dicts2rows}}}{\emph{dicts}, \emph{classes}}{}
\end{fulllineitems}

\index{expand\_glob() (in module infrapy.utils.ms2db)@\spxentry{expand\_glob()}\spxextra{in module infrapy.utils.ms2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ms2db.expand_glob}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ms2db.}}\sphinxbfcode{\sphinxupquote{expand\_glob}}}{\emph{option}, \emph{opt\_str}, \emph{value}, \emph{parser}}{}
Returns an iglob iterator for file iteration. Good for large file lists.

\end{fulllineitems}

\index{get\_files() (in module infrapy.utils.ms2db)@\spxentry{get\_files()}\spxextra{in module infrapy.utils.ms2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ms2db.get_files}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ms2db.}}\sphinxbfcode{\sphinxupquote{get\_files}}}{\emph{options}}{}
Return a sequence of SAC file names from either a list of file names
(trivial) or a text file list (presumable because there are too many files
to use normal shell expansion).

\end{fulllineitems}

\index{get\_or\_create\_tables() (in module infrapy.utils.ms2db)@\spxentry{get\_or\_create\_tables()}\spxextra{in module infrapy.utils.ms2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ms2db.get_or_create_tables}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ms2db.}}\sphinxbfcode{\sphinxupquote{get\_or\_create\_tables}}}{\emph{options}, \emph{session}, \emph{create=True}}{}
Load or create canonical ORM KB Core table classes.

options : argparse.ArgumentParser
session : sqlalchemy.orm.Session
\begin{description}
\item[{tables}] \leavevmode{[}dict{]}
Mapping between canonical table names and SQLA ORM classes.
e.g. \{‘origin’: MyOrigin, …\}

\end{description}

\end{fulllineitems}

\index{get\_parser() (in module infrapy.utils.ms2db)@\spxentry{get\_parser()}\spxextra{in module infrapy.utils.ms2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ms2db.get_parser}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ms2db.}}\sphinxbfcode{\sphinxupquote{get\_parser}}}{}{}
This is where the command\sphinxhyphen{}line options are defined, to be parsed from argv

argparse.ArgumentParser instance

Test the parser with this syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{sac2db} \PYG{k+kn}{import} \PYG{n}{get\PYGZus{}parser}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{parser} \PYG{o}{=} \PYG{n}{get\PYGZus{}parser}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{options} \PYG{o}{=} \PYG{n}{parser}\PYG{o}{.}\PYG{n}{parse\PYGZus{}args}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}origin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{origin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}affiliation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{g+go}{                                                                 \PYGZsq{}myaffiliation\PYGZsq{}, \PYGZsq{}sqlite:///mydb.sqlite\PYGZsq{},}
\PYG{g+go}{                                                                 \PYGZsq{}*.sac\PYGZsq{}])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{options}
\PYG{g+go}{Namespace(affiliation=\PYGZsq{}my.affiliation\PYGZsq{}, arrival=None,}
\PYG{g+go}{assoc=None, event=None, files=[\PYGZsq{}*.sac\PYGZsq{}], instrument=None, lastid=None,}
\PYG{g+go}{origin=\PYGZsq{}origin\PYGZsq{}, absolute\PYGZus{}path=False, site=None, sitechan=None,}
\PYG{g+go}{url=\PYGZsq{}sqlite:///mydb.sqlite\PYGZsq{}, wfdisc=None)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{get\_plugins() (in module infrapy.utils.ms2db)@\spxentry{get\_plugins()}\spxextra{in module infrapy.utils.ms2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ms2db.get_plugins}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ms2db.}}\sphinxbfcode{\sphinxupquote{get\_plugins}}}{\emph{options}}{}
Returns a list of imported plugin function objects.

\end{fulllineitems}

\index{get\_session() (in module infrapy.utils.ms2db)@\spxentry{get\_session()}\spxextra{in module infrapy.utils.ms2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ms2db.get_session}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ms2db.}}\sphinxbfcode{\sphinxupquote{get\_session}}}{\emph{options}}{}
\end{fulllineitems}

\index{main() (in module infrapy.utils.ms2db)@\spxentry{main()}\spxextra{in module infrapy.utils.ms2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ms2db.main}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ms2db.}}\sphinxbfcode{\sphinxupquote{main}}}{\emph{argv=None}}{}
Command\sphinxhyphen{}line arguments are created and parsed, fed to functions.

\end{fulllineitems}

\index{make\_atomic() (in module infrapy.utils.ms2db)@\spxentry{make\_atomic()}\spxextra{in module infrapy.utils.ms2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ms2db.make_atomic}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ms2db.}}\sphinxbfcode{\sphinxupquote{make\_atomic}}}{\emph{last}, \emph{**rows}}{}
Unify related table instances/row, including: ids, dir, and dfile

\end{fulllineitems}

\index{ms2db() (in module infrapy.utils.ms2db)@\spxentry{ms2db()}\spxextra{in module infrapy.utils.ms2db}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ms2db.ms2db}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ms2db.}}\sphinxbfcode{\sphinxupquote{ms2db}}}{\emph{files}, \emph{url}, \emph{tables}, \emph{plugins=None}, \emph{abs\_paths=False}}{}
\end{fulllineitems}



\subsubsection{infrapy.utils.obspy\_conversion module}
\label{\detokenize{infrapy.utils:module-infrapy.utils.obspy_conversion}}\label{\detokenize{infrapy.utils:infrapy-utils-obspy-conversion-module}}\index{infrapy.utils.obspy\_conversion (module)@\spxentry{infrapy.utils.obspy\_conversion}\spxextra{module}}\index{stream2array() (in module infrapy.utils.obspy\_conversion)@\spxentry{stream2array()}\spxextra{in module infrapy.utils.obspy\_conversion}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.obspy_conversion.stream2array}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.obspy\_conversion.}}\sphinxbfcode{\sphinxupquote{stream2array}}}{\emph{str}}{}
turn obspy stream into 2D array
\begin{description}
\item[{the data from stream is extracted and copied to a 2D numpy array}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{** parameters**, \sphinxstylestrong{types}, \sphinxstylestrong{return}, and \sphinxstylestrong{return types}::}] \leavevmode\begin{quote}\begin{description}
\item[{param arg1}] \leavevmode
stream to be converted

\item[{type arg1}] \leavevmode
obspy stream

\item[{return}] \leavevmode
2D array with time series for all channels

\item[{rtype}] \leavevmode
numpy array

\end{description}\end{quote}

\end{description}

\end{itemize}

\end{description}

\end{fulllineitems}



\subsubsection{infrapy.utils.prog\_bar module}
\label{\detokenize{infrapy.utils:module-infrapy.utils.prog_bar}}\label{\detokenize{infrapy.utils:infrapy-utils-prog-bar-module}}\index{infrapy.utils.prog\_bar (module)@\spxentry{infrapy.utils.prog\_bar}\spxextra{module}}\index{close() (in module infrapy.utils.prog\_bar)@\spxentry{close()}\spxextra{in module infrapy.utils.prog\_bar}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.prog_bar.close}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.prog\_bar.}}\sphinxbfcode{\sphinxupquote{close}}}{}{}
\end{fulllineitems}

\index{increment() (in module infrapy.utils.prog\_bar)@\spxentry{increment()}\spxextra{in module infrapy.utils.prog\_bar}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.prog_bar.increment}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.prog\_bar.}}\sphinxbfcode{\sphinxupquote{increment}}}{\emph{n=1}}{}
\end{fulllineitems}

\index{prep() (in module infrapy.utils.prog\_bar)@\spxentry{prep()}\spxextra{in module infrapy.utils.prog\_bar}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.prog_bar.prep}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.prog\_bar.}}\sphinxbfcode{\sphinxupquote{prep}}}{\emph{length}}{}
\end{fulllineitems}

\index{set\_step() (in module infrapy.utils.prog\_bar)@\spxentry{set\_step()}\spxextra{in module infrapy.utils.prog\_bar}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.prog_bar.set_step}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.prog\_bar.}}\sphinxbfcode{\sphinxupquote{set\_step}}}{\emph{n}, \emph{N}, \emph{len}}{}
\end{fulllineitems}



\subsubsection{infrapy.utils.ref2sac module}
\label{\detokenize{infrapy.utils:module-infrapy.utils.ref2sac}}\label{\detokenize{infrapy.utils:infrapy-utils-ref2sac-module}}\index{infrapy.utils.ref2sac (module)@\spxentry{infrapy.utils.ref2sac}\spxextra{module}}\index{beta() (in module infrapy.utils.ref2sac)@\spxentry{beta()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.beta}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{beta}}}{\emph{a}, \emph{b}, \emph{size=None}}{}
Draw samples from a Beta distribution.

The Beta distribution is a special case of the Dirichlet distribution,
and is related to the Gamma distribution.  It has the probability
distribution function
\begin{equation*}
\begin{split}f(x; a,b) = \frac{1}{B(\alpha, \beta)} x^{\alpha - 1}
(1 - x)^{\beta - 1},\end{split}
\end{equation*}
where the normalization, B, is the beta function,
\begin{equation*}
\begin{split}B(\alpha, \beta) = \int_0^1 t^{\alpha - 1}
(1 - t)^{\beta - 1} dt.\end{split}
\end{equation*}
It is often seen in Bayesian inference and order statistics.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{beta}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{a}] \leavevmode{[}float or array\_like of floats{]}
Alpha, positive (\textgreater{}0).

\item[{b}] \leavevmode{[}float or array\_like of floats{]}
Beta, positive (\textgreater{}0).

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}} are both scalars.
Otherwise, \sphinxcode{\sphinxupquote{np.broadcast(a, b).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized beta distribution.

\end{description}

Generator.beta: which should be used for new code.

\end{fulllineitems}

\index{binomial() (in module infrapy.utils.ref2sac)@\spxentry{binomial()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.binomial}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{binomial}}}{\emph{n}, \emph{p}, \emph{size=None}}{}
Draw samples from a binomial distribution.

Samples are drawn from a binomial distribution with specified
parameters, n trials and p probability of success where
n an integer \textgreater{}= 0 and p is in the interval {[}0,1{]}. (n may be
input as a float, but it is truncated to an integer in use)

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{binomial}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{n}] \leavevmode{[}int or array\_like of ints{]}
Parameter of the distribution, \textgreater{}= 0. Floats are also accepted,
but they will be truncated to integers.

\item[{p}] \leavevmode{[}float or array\_like of floats{]}
Parameter of the distribution, \textgreater{}= 0 and \textless{}=1.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{n}} and \sphinxcode{\sphinxupquote{p}} are both scalars.
Otherwise, \sphinxcode{\sphinxupquote{np.broadcast(n, p).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized binomial distribution, where
each sample is equal to the number of successes over the n trials.

\end{description}
\begin{description}
\item[{scipy.stats.binom}] \leavevmode{[}probability density function, distribution or{]}
cumulative density function, etc.

\end{description}

Generator.binomial: which should be used for new code.

The probability density for the binomial distribution is
\begin{equation*}
\begin{split}P(N) = \binom{n}{N}p^N(1-p)^{n-N},\end{split}
\end{equation*}
where \(n\) is the number of trials, \(p\) is the probability
of success, and \(N\) is the number of successes.

When estimating the standard error of a proportion in a population by
using a random sample, the normal distribution works well unless the
product p*n \textless{}=5, where p = population proportion estimate, and n =
number of samples, in which case the binomial distribution is used
instead. For example, a sample of 15 people shows 4 who are left
handed, and 11 who are right handed. Then p = 4/15 = 27\%. 0.27*15 = 4,
so the binomial distribution should be used in this case.

Draw samples from the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{n}\PYG{p}{,} \PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{o}{.}\PYG{l+m+mi}{5}  \PYG{c+c1}{\PYGZsh{} number of trials, probability of each trial}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{binomial}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{g+go}{\PYGZsh{} result of flipping a coin 10 times, tested 1000 times.}
\end{sphinxVerbatim}

A real world example. A company drills 9 wild\sphinxhyphen{}cat oil exploration
wells, each with an estimated probability of success of 0.1. All nine
wells fail. What is the probability of that happening?

Let’s do 20,000 trials of the model, and count the number that
generate zero positive results.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{binomial}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mi}{20000}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{20000.}
\PYG{g+go}{\PYGZsh{} answer = 0.38885, or 38\PYGZpc{}.}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{chisquare() (in module infrapy.utils.ref2sac)@\spxentry{chisquare()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.chisquare}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{chisquare}}}{\emph{df}, \emph{size=None}}{}
Draw samples from a chi\sphinxhyphen{}square distribution.

When \sphinxtitleref{df} independent random variables, each with standard normal
distributions (mean 0, variance 1), are squared and summed, the
resulting distribution is chi\sphinxhyphen{}square (see Notes).  This distribution
is often used in hypothesis testing.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{chisquare}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{df}] \leavevmode{[}float or array\_like of floats{]}
Number of degrees of freedom, must be \textgreater{} 0.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{df}} is a scalar.  Otherwise,
\sphinxcode{\sphinxupquote{np.array(df).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized chi\sphinxhyphen{}square distribution.

\end{description}
\begin{description}
\item[{ValueError}] \leavevmode
When \sphinxtitleref{df} \textless{}= 0 or when an inappropriate \sphinxtitleref{size} (e.g. \sphinxcode{\sphinxupquote{size=\sphinxhyphen{}1}})
is given.

\end{description}

Generator.chisquare: which should be used for new code.

The variable obtained by summing the squares of \sphinxtitleref{df} independent,
standard normally distributed random variables:
\begin{equation*}
\begin{split}Q = \sum_{i=0}^{\mathtt{df}} X^2_i\end{split}
\end{equation*}
is chi\sphinxhyphen{}square distributed, denoted
\begin{equation*}
\begin{split}Q \sim \chi^2_k.\end{split}
\end{equation*}
The probability density function of the chi\sphinxhyphen{}squared distribution is
\begin{equation*}
\begin{split}p(x) = \frac{(1/2)^{k/2}}{\Gamma(k/2)}
x^{k/2 - 1} e^{-x/2},\end{split}
\end{equation*}
where \(\Gamma\) is the gamma function,
\begin{equation*}
\begin{split}\Gamma(x) = \int_0^{-\infty} t^{x - 1} e^{-t} dt.\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{chisquare}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+go}{array([ 1.89920014,  9.00867716,  3.13710533,  5.62318272]) \PYGZsh{} random}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{choice() (in module infrapy.utils.ref2sac)@\spxentry{choice()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.choice}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{choice}}}{\emph{a}, \emph{size=None}, \emph{replace=True}, \emph{p=None}}{}
Generates a random sample from a given 1\sphinxhyphen{}D array
\begin{quote}

\DUrole{versionmodified,added}{New in version 1.7.0.}
\end{quote}

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{choice}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{a}] \leavevmode{[}1\sphinxhyphen{}D array\sphinxhyphen{}like or int{]}
If an ndarray, a random sample is generated from its elements.
If an int, the random sample is generated as if a were np.arange(a)

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  Default is None, in which case a
single value is returned.

\item[{replace}] \leavevmode{[}boolean, optional{]}
Whether the sample is with or without replacement

\item[{p}] \leavevmode{[}1\sphinxhyphen{}D array\sphinxhyphen{}like, optional{]}
The probabilities associated with each entry in a.
If not given the sample assumes a uniform distribution over all
entries in a.

\end{description}
\begin{description}
\item[{samples}] \leavevmode{[}single item or ndarray{]}
The generated random samples

\end{description}
\begin{description}
\item[{ValueError}] \leavevmode
If a is an int and less than zero, if a or p are not 1\sphinxhyphen{}dimensional,
if a is an array\sphinxhyphen{}like of size 0, if p is not a vector of
probabilities, if a and p have different lengths, or if
replace=False and the sample size is greater than the population
size

\end{description}

randint, shuffle, permutation
Generator.choice: which should be used in new code

Generate a uniform random sample from np.arange(5) of size 3:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+go}{array([0, 3, 4]) \PYGZsh{} random}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{}This is equivalent to np.random.randint(0,5,3)}
\end{sphinxVerbatim}

Generate a non\sphinxhyphen{}uniform random sample from np.arange(5) of size 3:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{array([3, 3, 0]) \PYGZsh{} random}
\end{sphinxVerbatim}

Generate a uniform random sample from np.arange(5) of size 3 without
replacement:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{replace}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{g+go}{array([3,1,0]) \PYGZsh{} random}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{}This is equivalent to np.random.permutation(np.arange(5))[:3]}
\end{sphinxVerbatim}

Generate a non\sphinxhyphen{}uniform random sample from np.arange(5) of size
3 without replacement:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{replace}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{array([2, 3, 0]) \PYGZsh{} random}
\end{sphinxVerbatim}

Any of the above can be repeated with an arbitrary array\sphinxhyphen{}like
instead of just integers. For instance:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{aa\PYGZus{}milne\PYGZus{}arr} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pooh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rabbit}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{piglet}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Christopher}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{n}{aa\PYGZus{}milne\PYGZus{}arr}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{array([\PYGZsq{}pooh\PYGZsq{}, \PYGZsq{}pooh\PYGZsq{}, \PYGZsq{}pooh\PYGZsq{}, \PYGZsq{}Christopher\PYGZsq{}, \PYGZsq{}piglet\PYGZsq{}], \PYGZsh{} random}
\PYG{g+go}{      dtype=\PYGZsq{}\PYGZlt{}U11\PYGZsq{})}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{dirichlet() (in module infrapy.utils.ref2sac)@\spxentry{dirichlet()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.dirichlet}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{dirichlet}}}{\emph{alpha}, \emph{size=None}}{}
Draw samples from the Dirichlet distribution.

Draw \sphinxtitleref{size} samples of dimension k from a Dirichlet distribution. A
Dirichlet\sphinxhyphen{}distributed random variable can be seen as a multivariate
generalization of a Beta distribution. The Dirichlet distribution
is a conjugate prior of a multinomial distribution in Bayesian
inference.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{dirichlet}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{alpha}] \leavevmode{[}array{]}
Parameter of the distribution (k dimension for sample of
dimension k).

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  Default is None, in which case a
single value is returned.

\end{description}
\begin{description}
\item[{samples}] \leavevmode{[}ndarray,{]}
The drawn samples, of shape (size, alpha.ndim).

\end{description}
\begin{description}
\item[{ValueError}] \leavevmode
If any value in alpha is less than or equal to zero

\end{description}

Generator.dirichlet: which should be used for new code.

The Dirichlet distribution is a distribution over vectors
\(x\) that fulfil the conditions \(x_i>0\) and
\(\sum_{i=1}^k x_i = 1\).

The probability density function \(p\) of a
Dirichlet\sphinxhyphen{}distributed random vector \(X\) is
proportional to
\begin{equation*}
\begin{split}p(x) \propto \prod_{i=1}^{k}{x^{\alpha_i-1}_i},\end{split}
\end{equation*}
where \(\alpha\) is a vector containing the positive
concentration parameters.

The method uses the following property for computation: let \(Y\)
be a random vector which has components that follow a standard gamma
distribution, then \(X = \frac{1}{\sum_{i=1}^k{Y_i}} Y\)
is Dirichlet\sphinxhyphen{}distributed

Taking an example cited in Wikipedia, this distribution can be used if
one wanted to cut strings (each of initial length 1.0) into K pieces
with different lengths, where each piece had, on average, a designated
average length, but allowing some variation in the relative sizes of
the pieces.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{dirichlet}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{)}\PYG{o}{.}\PYG{n}{transpose}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{barh}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{,} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{barh}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{,} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{left}\PYG{o}{=}\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{barh}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{,} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{left}\PYG{o}{=}\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Lengths of Strings}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{exponential() (in module infrapy.utils.ref2sac)@\spxentry{exponential()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.exponential}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{exponential}}}{\emph{scale=1.0}, \emph{size=None}}{}
Draw samples from an exponential distribution.

Its probability density function is
\begin{equation*}
\begin{split}f(x; \frac{1}{\beta}) = \frac{1}{\beta} \exp(-\frac{x}{\beta}),\end{split}
\end{equation*}
for \sphinxcode{\sphinxupquote{x \textgreater{} 0}} and 0 elsewhere. \(\beta\) is the scale parameter,
which is the inverse of the rate parameter \(\lambda = 1/\beta\).
The rate parameter is an alternative, widely used parameterization
of the exponential distribution {\color{red}\bfseries{}{[}3{]}\_}.

The exponential distribution is a continuous analogue of the
geometric distribution.  It describes many common situations, such as
the size of raindrops measured over many rainstorms {\color{red}\bfseries{}{[}1{]}\_}, or the time
between page requests to Wikipedia {\color{red}\bfseries{}{[}2{]}\_}.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{exponential}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{scale}] \leavevmode{[}float or array\_like of floats{]}
The scale parameter, \(\beta = 1/\lambda\). Must be
non\sphinxhyphen{}negative.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{scale}} is a scalar.  Otherwise,
\sphinxcode{\sphinxupquote{np.array(scale).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized exponential distribution.

\end{description}

Generator.exponential: which should be used for new code.

\end{fulllineitems}

\index{f() (in module infrapy.utils.ref2sac)@\spxentry{f()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.f}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{f}}}{\emph{dfnum}, \emph{dfden}, \emph{size=None}}{}
Draw samples from an F distribution.

Samples are drawn from an F distribution with specified parameters,
\sphinxtitleref{dfnum} (degrees of freedom in numerator) and \sphinxtitleref{dfden} (degrees of
freedom in denominator), where both parameters must be greater than
zero.

The random variate of the F distribution (also known as the
Fisher distribution) is a continuous probability distribution
that arises in ANOVA tests, and is the ratio of two chi\sphinxhyphen{}square
variates.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{f}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{dfnum}] \leavevmode{[}float or array\_like of floats{]}
Degrees of freedom in numerator, must be \textgreater{} 0.

\item[{dfden}] \leavevmode{[}float or array\_like of float{]}
Degrees of freedom in denominator, must be \textgreater{} 0.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{dfnum}} and \sphinxcode{\sphinxupquote{dfden}} are both scalars.
Otherwise, \sphinxcode{\sphinxupquote{np.broadcast(dfnum, dfden).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized Fisher distribution.

\end{description}
\begin{description}
\item[{scipy.stats.f}] \leavevmode{[}probability density function, distribution or{]}
cumulative density function, etc.

\end{description}

Generator.f: which should be used for new code.

The F statistic is used to compare in\sphinxhyphen{}group variances to between\sphinxhyphen{}group
variances. Calculating the distribution depends on the sampling, and
so it is a function of the respective degrees of freedom in the
problem.  The variable \sphinxtitleref{dfnum} is the number of samples minus one, the
between\sphinxhyphen{}groups degrees of freedom, while \sphinxtitleref{dfden} is the within\sphinxhyphen{}groups
degrees of freedom, the sum of the number of samples in each group
minus the number of groups.

An example from Glantz{[}1{]}, pp 47\sphinxhyphen{}40:

Two groups, children of diabetics (25 people) and children from people
without diabetes (25 controls). Fasting blood glucose was measured,
case group had a mean value of 86.1, controls had a mean value of
82.2. Standard deviations were 2.09 and 2.49 respectively. Are these
data consistent with the null hypothesis that the parents diabetic
status does not affect their children’s blood glucose levels?
Calculating the F statistic from the data gives a value of 36.01.

Draw samples from the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dfnum} \PYG{o}{=} \PYG{l+m+mf}{1.} \PYG{c+c1}{\PYGZsh{} between group degrees of freedom}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dfden} \PYG{o}{=} \PYG{l+m+mf}{48.} \PYG{c+c1}{\PYGZsh{} within groups degrees of freedom}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{f}\PYG{p}{(}\PYG{n}{dfnum}\PYG{p}{,} \PYG{n}{dfden}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\end{sphinxVerbatim}

The lower bound for the top 1\% of the samples is :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{]}
\PYG{g+go}{7.61988120985 \PYGZsh{} random}
\end{sphinxVerbatim}

So there is about a 1\% chance that the F statistic will exceed 7.62,
the measured value is 36, so the null hypothesis is rejected at the 1\%
level.

\end{fulllineitems}

\index{gamma() (in module infrapy.utils.ref2sac)@\spxentry{gamma()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.gamma}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{gamma}}}{\emph{shape}, \emph{scale=1.0}, \emph{size=None}}{}
Draw samples from a Gamma distribution.

Samples are drawn from a Gamma distribution with specified parameters,
\sphinxtitleref{shape} (sometimes designated “k”) and \sphinxtitleref{scale} (sometimes designated
“theta”), where both parameters are \textgreater{} 0.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{gamma}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{shape}] \leavevmode{[}float or array\_like of floats{]}
The shape of the gamma distribution. Must be non\sphinxhyphen{}negative.

\item[{scale}] \leavevmode{[}float or array\_like of floats, optional{]}
The scale of the gamma distribution. Must be non\sphinxhyphen{}negative.
Default is equal to 1.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{shape}} and \sphinxcode{\sphinxupquote{scale}} are both scalars.
Otherwise, \sphinxcode{\sphinxupquote{np.broadcast(shape, scale).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized gamma distribution.

\end{description}
\begin{description}
\item[{scipy.stats.gamma}] \leavevmode{[}probability density function, distribution or{]}
cumulative density function, etc.

\end{description}

Generator.gamma: which should be used for new code.

The probability density for the Gamma distribution is
\begin{equation*}
\begin{split}p(x) = x^{k-1}\frac{e^{-x/\theta}}{\theta^k\Gamma(k)},\end{split}
\end{equation*}
where \(k\) is the shape and \(\theta\) the scale,
and \(\Gamma\) is the Gamma function.

The Gamma distribution is often used to model the times to failure of
electronic components, and arises naturally in processes for which the
waiting times between Poisson distributed events are relevant.

Draw samples from the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{shape}\PYG{p}{,} \PYG{n}{scale} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{,} \PYG{l+m+mf}{2.}  \PYG{c+c1}{\PYGZsh{} mean=4, std=2*sqrt(2)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{gamma}\PYG{p}{(}\PYG{n}{shape}\PYG{p}{,} \PYG{n}{scale}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\end{sphinxVerbatim}

Display the histogram of the samples, along with
the probability density function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{special} \PYG{k}{as} \PYG{n+nn}{sps}  
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{count}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignored} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y} \PYG{o}{=} \PYG{n}{bins}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{n}{shape}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{bins}\PYG{o}{/}\PYG{n}{scale}\PYG{p}{)} \PYG{o}{/}  
\PYG{g+gp}{... }                     \PYG{p}{(}\PYG{n}{sps}\PYG{o}{.}\PYG{n}{gamma}\PYG{p}{(}\PYG{n}{shape}\PYG{p}{)}\PYG{o}{*}\PYG{n}{scale}\PYG{o}{*}\PYG{o}{*}\PYG{n}{shape}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{geometric() (in module infrapy.utils.ref2sac)@\spxentry{geometric()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.geometric}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{geometric}}}{\emph{p}, \emph{size=None}}{}
Draw samples from the geometric distribution.

Bernoulli trials are experiments with one of two outcomes:
success or failure (an example of such an experiment is flipping
a coin).  The geometric distribution models the number of trials
that must be run in order to achieve success.  It is therefore
supported on the positive integers, \sphinxcode{\sphinxupquote{k = 1, 2, ...}}.

The probability mass function of the geometric distribution is
\begin{equation*}
\begin{split}f(k) = (1 - p)^{k - 1} p\end{split}
\end{equation*}
where \sphinxtitleref{p} is the probability of success of an individual trial.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{geometric}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{p}] \leavevmode{[}float or array\_like of floats{]}
The probability of success of an individual trial.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{p}} is a scalar.  Otherwise,
\sphinxcode{\sphinxupquote{np.array(p).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized geometric distribution.

\end{description}

Generator.geometric: which should be used for new code.

Draw ten thousand values from the geometric distribution,
with the probability of an individual success equal to 0.35:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{z} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{geometric}\PYG{p}{(}\PYG{n}{p}\PYG{o}{=}\PYG{l+m+mf}{0.35}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}
\end{sphinxVerbatim}

How many trials succeeded after a single run?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{(}\PYG{n}{z} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mf}{10000.}
\PYG{g+go}{0.34889999999999999 \PYGZsh{}random}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{get\_state() (in module infrapy.utils.ref2sac)@\spxentry{get\_state()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.get_state}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{get\_state}}}{}{}
Return a tuple representing the internal state of the generator.

For more details, see \sphinxtitleref{set\_state}.
\begin{description}
\item[{out}] \leavevmode{[}\{tuple(str, ndarray of 624 uints, int, int, float), dict\}{]}
The returned tuple has the following items:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
the string ‘MT19937’.

\item {} 
a 1\sphinxhyphen{}D array of 624 unsigned integer keys.

\item {} 
an integer \sphinxcode{\sphinxupquote{pos}}.

\item {} 
an integer \sphinxcode{\sphinxupquote{has\_gauss}}.

\item {} 
a float \sphinxcode{\sphinxupquote{cached\_gaussian}}.

\end{enumerate}

If \sphinxtitleref{legacy} is False, or the BitGenerator is not NT19937, then
state is returned as a dictionary.

\item[{legacy}] \leavevmode{[}bool{]}
Flag indicating the return a legacy tuple state when the BitGenerator
is MT19937.

\end{description}

set\_state

\sphinxtitleref{set\_state} and \sphinxtitleref{get\_state} are not needed to work with any of the
random distributions in NumPy. If the internal state is manually altered,
the user should know exactly what he/she is doing.

\end{fulllineitems}

\index{gumbel() (in module infrapy.utils.ref2sac)@\spxentry{gumbel()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.gumbel}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{gumbel}}}{\emph{loc=0.0}, \emph{scale=1.0}, \emph{size=None}}{}
Draw samples from a Gumbel distribution.

Draw samples from a Gumbel distribution with specified location and
scale.  For more information on the Gumbel distribution, see
Notes and References below.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{gumbel}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{loc}] \leavevmode{[}float or array\_like of floats, optional{]}
The location of the mode of the distribution. Default is 0.

\item[{scale}] \leavevmode{[}float or array\_like of floats, optional{]}
The scale parameter of the distribution. Default is 1. Must be non\sphinxhyphen{}
negative.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{loc}} and \sphinxcode{\sphinxupquote{scale}} are both scalars.
Otherwise, \sphinxcode{\sphinxupquote{np.broadcast(loc, scale).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized Gumbel distribution.

\end{description}

scipy.stats.gumbel\_l
scipy.stats.gumbel\_r
scipy.stats.genextreme
weibull
Generator.gumbel: which should be used for new code.

The Gumbel (or Smallest Extreme Value (SEV) or the Smallest Extreme
Value Type I) distribution is one of a class of Generalized Extreme
Value (GEV) distributions used in modeling extreme value problems.
The Gumbel is a special case of the Extreme Value Type I distribution
for maximums from distributions with “exponential\sphinxhyphen{}like” tails.

The probability density for the Gumbel distribution is
\begin{equation*}
\begin{split}p(x) = \frac{e^{-(x - \mu)/ \beta}}{\beta} e^{ -e^{-(x - \mu)/
\beta}},\end{split}
\end{equation*}
where \(\mu\) is the mode, a location parameter, and
\(\beta\) is the scale parameter.

The Gumbel (named for German mathematician Emil Julius Gumbel) was used
very early in the hydrology literature, for modeling the occurrence of
flood events. It is also used for modeling maximum wind speed and
rainfall rates.  It is a “fat\sphinxhyphen{}tailed” distribution \sphinxhyphen{} the probability of
an event in the tail of the distribution is larger than if one used a
Gaussian, hence the surprisingly frequent occurrence of 100\sphinxhyphen{}year
floods. Floods were initially modeled as a Gaussian process, which
underestimated the frequency of extreme events.

It is one of a class of extreme value distributions, the Generalized
Extreme Value (GEV) distributions, which also includes the Weibull and
Frechet.

The function has a mean of \(\mu + 0.57721\beta\) and a variance
of \(\frac{\pi^2}{6}\beta^2\).

Draw samples from the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mu}\PYG{p}{,} \PYG{n}{beta} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.1} \PYG{c+c1}{\PYGZsh{} location and scale}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{gumbel}\PYG{p}{(}\PYG{n}{mu}\PYG{p}{,} \PYG{n}{beta}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\end{sphinxVerbatim}

Display the histogram of the samples, along with
the probability density function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{count}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignored} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{beta}\PYG{p}{)}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{bins} \PYG{o}{\PYGZhy{}} \PYG{n}{mu}\PYG{p}{)}\PYG{o}{/}\PYG{n}{beta}\PYG{p}{)}
\PYG{g+gp}{... }         \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(} \PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(} \PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{bins} \PYG{o}{\PYGZhy{}} \PYG{n}{mu}\PYG{p}{)} \PYG{o}{/}\PYG{n}{beta}\PYG{p}{)} \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

Show how an extreme value distribution can arise from a Gaussian process
and compare to a Gaussian:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{means} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{maxima} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{)} \PYG{p}{:}
\PYG{g+gp}{... }   \PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{n}{mu}\PYG{p}{,} \PYG{n}{beta}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{g+gp}{... }   \PYG{n}{means}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{... }   \PYG{n}{maxima}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{count}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignored} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{maxima}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{beta} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{maxima}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mu} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{maxima}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.57721}\PYG{o}{*}\PYG{n}{beta}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{beta}\PYG{p}{)}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{bins} \PYG{o}{\PYGZhy{}} \PYG{n}{mu}\PYG{p}{)}\PYG{o}{/}\PYG{n}{beta}\PYG{p}{)}
\PYG{g+gp}{... }         \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{bins} \PYG{o}{\PYGZhy{}} \PYG{n}{mu}\PYG{p}{)}\PYG{o}{/}\PYG{n}{beta}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{n}{beta} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{... }         \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{bins} \PYG{o}{\PYGZhy{}} \PYG{n}{mu}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{beta}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{hypergeometric() (in module infrapy.utils.ref2sac)@\spxentry{hypergeometric()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.hypergeometric}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{hypergeometric}}}{\emph{ngood}, \emph{nbad}, \emph{nsample}, \emph{size=None}}{}
Draw samples from a Hypergeometric distribution.

Samples are drawn from a hypergeometric distribution with specified
parameters, \sphinxtitleref{ngood} (ways to make a good selection), \sphinxtitleref{nbad} (ways to make
a bad selection), and \sphinxtitleref{nsample} (number of items sampled, which is less
than or equal to the sum \sphinxcode{\sphinxupquote{ngood + nbad}}).

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{hypergeometric}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{ngood}] \leavevmode{[}int or array\_like of ints{]}
Number of ways to make a good selection.  Must be nonnegative.

\item[{nbad}] \leavevmode{[}int or array\_like of ints{]}
Number of ways to make a bad selection.  Must be nonnegative.

\item[{nsample}] \leavevmode{[}int or array\_like of ints{]}
Number of items sampled.  Must be at least 1 and at most
\sphinxcode{\sphinxupquote{ngood + nbad}}.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxtitleref{ngood}, \sphinxtitleref{nbad}, and \sphinxtitleref{nsample}
are all scalars.  Otherwise, \sphinxcode{\sphinxupquote{np.broadcast(ngood, nbad, nsample).size}}
samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized hypergeometric distribution. Each
sample is the number of good items within a randomly selected subset of
size \sphinxtitleref{nsample} taken from a set of \sphinxtitleref{ngood} good items and \sphinxtitleref{nbad} bad items.

\end{description}
\begin{description}
\item[{scipy.stats.hypergeom}] \leavevmode{[}probability density function, distribution or{]}
cumulative density function, etc.

\end{description}

Generator.hypergeometric: which should be used for new code.

The probability density for the Hypergeometric distribution is
\begin{equation*}
\begin{split}P(x) = \frac{\binom{g}{x}\binom{b}{n-x}}{\binom{g+b}{n}},\end{split}
\end{equation*}
where \(0 \le x \le n\) and \(n-b \le x \le g\)

for P(x) the probability of \sphinxcode{\sphinxupquote{x}} good results in the drawn sample,
g = \sphinxtitleref{ngood}, b = \sphinxtitleref{nbad}, and n = \sphinxtitleref{nsample}.

Consider an urn with black and white marbles in it, \sphinxtitleref{ngood} of them
are black and \sphinxtitleref{nbad} are white. If you draw \sphinxtitleref{nsample} balls without
replacement, then the hypergeometric distribution describes the
distribution of black balls in the drawn sample.

Note that this distribution is very similar to the binomial
distribution, except that in this case, samples are drawn without
replacement, whereas in the Binomial case samples are drawn with
replacement (or the sample space is infinite). As the sample space
becomes large, this distribution approaches the binomial.

Draw samples from the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ngood}\PYG{p}{,} \PYG{n}{nbad}\PYG{p}{,} \PYG{n}{nsamp} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{10}
\PYG{g+go}{\PYGZsh{} number of good, number of bad, and number of samples}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{hypergeometric}\PYG{p}{(}\PYG{n}{ngood}\PYG{p}{,} \PYG{n}{nbad}\PYG{p}{,} \PYG{n}{nsamp}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k+kn}{import} \PYG{n}{hist}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+go}{\PYGZsh{}   note that it is very unlikely to grab both bad items}
\end{sphinxVerbatim}

Suppose you have an urn with 15 white and 15 black marbles.
If you pull 15 marbles at random, how likely is it that
12 or more of them are one color?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{hypergeometric}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{100000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{s}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{100000.} \PYG{o}{+} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{s}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{100000.}
\PYG{g+go}{\PYGZsh{}   answer = 0.003 ... pretty unlikely!}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{laplace() (in module infrapy.utils.ref2sac)@\spxentry{laplace()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.laplace}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{laplace}}}{\emph{loc=0.0}, \emph{scale=1.0}, \emph{size=None}}{}
Draw samples from the Laplace or double exponential distribution with
specified location (or mean) and scale (decay).

The Laplace distribution is similar to the Gaussian/normal distribution,
but is sharper at the peak and has fatter tails. It represents the
difference between two independent, identically distributed exponential
random variables.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{laplace}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{loc}] \leavevmode{[}float or array\_like of floats, optional{]}
The position, \(\mu\), of the distribution peak. Default is 0.

\item[{scale}] \leavevmode{[}float or array\_like of floats, optional{]}
\(\lambda\), the exponential decay. Default is 1. Must be non\sphinxhyphen{}
negative.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{loc}} and \sphinxcode{\sphinxupquote{scale}} are both scalars.
Otherwise, \sphinxcode{\sphinxupquote{np.broadcast(loc, scale).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized Laplace distribution.

\end{description}

Generator.laplace: which should be used for new code.

It has the probability density function
\begin{equation*}
\begin{split}f(x; \mu, \lambda) = \frac{1}{2\lambda}
\exp\left(-\frac{|x - \mu|}{\lambda}\right).\end{split}
\end{equation*}
The first law of Laplace, from 1774, states that the frequency
of an error can be expressed as an exponential function of the
absolute magnitude of the error, which leads to the Laplace
distribution. For many problems in economics and health
sciences, this distribution seems to model the data better
than the standard Gaussian distribution.

Draw samples from the distribution

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{loc}\PYG{p}{,} \PYG{n}{scale} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{laplace}\PYG{p}{(}\PYG{n}{loc}\PYG{p}{,} \PYG{n}{scale}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\end{sphinxVerbatim}

Display the histogram of the samples, along with
the probability density function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{count}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignored} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.}\PYG{p}{,} \PYG{l+m+mf}{8.}\PYG{p}{,} \PYG{o}{.}\PYG{l+m+mi}{01}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdf} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{loc}\PYG{p}{)}\PYG{o}{/}\PYG{n}{scale}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{scale}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{pdf}\PYG{p}{)}
\end{sphinxVerbatim}

Plot Gaussian for comparison:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{g} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{n}{scale} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*}
\PYG{g+gp}{... }     \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{loc}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{scale}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{g}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{logistic() (in module infrapy.utils.ref2sac)@\spxentry{logistic()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.logistic}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{logistic}}}{\emph{loc=0.0}, \emph{scale=1.0}, \emph{size=None}}{}
Draw samples from a logistic distribution.

Samples are drawn from a logistic distribution with specified
parameters, loc (location or mean, also median), and scale (\textgreater{}0).

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{logistic}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{loc}] \leavevmode{[}float or array\_like of floats, optional{]}
Parameter of the distribution. Default is 0.

\item[{scale}] \leavevmode{[}float or array\_like of floats, optional{]}
Parameter of the distribution. Must be non\sphinxhyphen{}negative.
Default is 1.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{loc}} and \sphinxcode{\sphinxupquote{scale}} are both scalars.
Otherwise, \sphinxcode{\sphinxupquote{np.broadcast(loc, scale).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized logistic distribution.

\end{description}
\begin{description}
\item[{scipy.stats.logistic}] \leavevmode{[}probability density function, distribution or{]}
cumulative density function, etc.

\end{description}

Generator.logistic: which should be used for new code.

The probability density for the Logistic distribution is
\begin{equation*}
\begin{split}P(x) = P(x) = \frac{e^{-(x-\mu)/s}}{s(1+e^{-(x-\mu)/s})^2},\end{split}
\end{equation*}
where \(\mu\) = location and \(s\) = scale.

The Logistic distribution is used in Extreme Value problems where it
can act as a mixture of Gumbel distributions, in Epidemiology, and by
the World Chess Federation (FIDE) where it is used in the Elo ranking
system, assuming the performance of each player is a logistically
distributed random variable.

Draw samples from the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{loc}\PYG{p}{,} \PYG{n}{scale} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{logistic}\PYG{p}{(}\PYG{n}{loc}\PYG{p}{,} \PYG{n}{scale}\PYG{p}{,} \PYG{l+m+mi}{10000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{count}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignored} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{bins}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{)}
\end{sphinxVerbatim}

\#   plot against distribution

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{logist}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{loc}\PYG{p}{,} \PYG{n}{scale}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{)}\PYG{o}{/}\PYG{n}{scale}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{scale}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{)}\PYG{o}{/}\PYG{n}{scale}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{lgst\PYGZus{}val} \PYG{o}{=} \PYG{n}{logist}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{,} \PYG{n}{loc}\PYG{p}{,} \PYG{n}{scale}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{,} \PYG{n}{lgst\PYGZus{}val} \PYG{o}{*} \PYG{n}{count}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)} \PYG{o}{/} \PYG{n}{lgst\PYGZus{}val}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{lognormal() (in module infrapy.utils.ref2sac)@\spxentry{lognormal()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.lognormal}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{lognormal}}}{\emph{mean=0.0}, \emph{sigma=1.0}, \emph{size=None}}{}
Draw samples from a log\sphinxhyphen{}normal distribution.

Draw samples from a log\sphinxhyphen{}normal distribution with specified mean,
standard deviation, and array shape.  Note that the mean and standard
deviation are not the values for the distribution itself, but of the
underlying normal distribution it is derived from.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{lognormal}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{mean}] \leavevmode{[}float or array\_like of floats, optional{]}
Mean value of the underlying normal distribution. Default is 0.

\item[{sigma}] \leavevmode{[}float or array\_like of floats, optional{]}
Standard deviation of the underlying normal distribution. Must be
non\sphinxhyphen{}negative. Default is 1.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{mean}} and \sphinxcode{\sphinxupquote{sigma}} are both scalars.
Otherwise, \sphinxcode{\sphinxupquote{np.broadcast(mean, sigma).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized log\sphinxhyphen{}normal distribution.

\end{description}
\begin{description}
\item[{scipy.stats.lognorm}] \leavevmode{[}probability density function, distribution,{]}
cumulative density function, etc.

\end{description}

Generator.lognormal: which should be used for new code.

A variable \sphinxtitleref{x} has a log\sphinxhyphen{}normal distribution if \sphinxtitleref{log(x)} is normally
distributed.  The probability density function for the log\sphinxhyphen{}normal
distribution is:
\begin{equation*}
\begin{split}p(x) = \frac{1}{\sigma x \sqrt{2\pi}}
e^{(-\frac{(ln(x)-\mu)^2}{2\sigma^2})}\end{split}
\end{equation*}
where \(\mu\) is the mean and \(\sigma\) is the standard
deviation of the normally distributed logarithm of the variable.
A log\sphinxhyphen{}normal distribution results if a random variable is the \sphinxstyleemphasis{product}
of a large number of independent, identically\sphinxhyphen{}distributed variables in
the same way that a normal distribution results if the variable is the
\sphinxstyleemphasis{sum} of a large number of independent, identically\sphinxhyphen{}distributed
variables.

Draw samples from the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mu}\PYG{p}{,} \PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mf}{3.}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{c+c1}{\PYGZsh{} mean and standard deviation}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{lognormal}\PYG{p}{(}\PYG{n}{mu}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\end{sphinxVerbatim}

Display the histogram of the samples, along with
the probability density function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{count}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignored} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{align}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{10000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdf} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{mu}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{sigma}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{... }       \PYG{o}{/} \PYG{p}{(}\PYG{n}{x} \PYG{o}{*} \PYG{n}{sigma} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{pdf}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tight}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

Demonstrate that taking the products of random samples from a uniform
distribution can be fit well by a log\sphinxhyphen{}normal probability density
function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Generate a thousand samples: each is the product of 100 random}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} values, drawn from a normal distribution.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }   \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{10.} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{standard\PYGZus{}normal}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+gp}{... }   \PYG{n}{b}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{product}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} scale values to be positive}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{count}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignored} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{align}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sigma} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mu} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{10000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pdf} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{mu}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{sigma}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{... }       \PYG{o}{/} \PYG{p}{(}\PYG{n}{x} \PYG{o}{*} \PYG{n}{sigma} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{pdf}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{logseries() (in module infrapy.utils.ref2sac)@\spxentry{logseries()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.logseries}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{logseries}}}{\emph{p}, \emph{size=None}}{}
Draw samples from a logarithmic series distribution.

Samples are drawn from a log series distribution with specified
shape parameter, 0 \textless{} \sphinxcode{\sphinxupquote{p}} \textless{} 1.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{logseries}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{p}] \leavevmode{[}float or array\_like of floats{]}
Shape parameter for the distribution.  Must be in the range (0, 1).

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{p}} is a scalar.  Otherwise,
\sphinxcode{\sphinxupquote{np.array(p).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized logarithmic series distribution.

\end{description}
\begin{description}
\item[{scipy.stats.logser}] \leavevmode{[}probability density function, distribution or{]}
cumulative density function, etc.

\end{description}

Generator.logseries: which should be used for new code.

The probability density for the Log Series distribution is
\begin{equation*}
\begin{split}P(k) = \frac{-p^k}{k \ln(1-p)},\end{split}
\end{equation*}
where p = probability.

The log series distribution is frequently used to represent species
richness and occurrence, first proposed by Fisher, Corbet, and
Williams in 1943 {[}2{]}.  It may also be used to model the numbers of
occupants seen in cars {[}3{]}.

Draw samples from the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{o}{.}\PYG{l+m+mi}{6}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{logseries}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{l+m+mi}{10000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{count}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignored} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\end{sphinxVerbatim}

\#   plot against distribution

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{logseries}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{n}{p}\PYG{o}{*}\PYG{o}{*}\PYG{n}{k}\PYG{o}{/}\PYG{p}{(}\PYG{n}{k}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{p}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{,} \PYG{n}{logseries}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{o}{*}\PYG{n}{count}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{o}{/}
\PYG{g+gp}{... }         \PYG{n}{logseries}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{multinomial() (in module infrapy.utils.ref2sac)@\spxentry{multinomial()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.multinomial}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{multinomial}}}{\emph{n}, \emph{pvals}, \emph{size=None}}{}
Draw samples from a multinomial distribution.

The multinomial distribution is a multivariate generalization of the
binomial distribution.  Take an experiment with one of \sphinxcode{\sphinxupquote{p}}
possible outcomes.  An example of such an experiment is throwing a dice,
where the outcome can be 1 through 6.  Each sample drawn from the
distribution represents \sphinxtitleref{n} such experiments.  Its values,
\sphinxcode{\sphinxupquote{X\_i = {[}X\_0, X\_1, ..., X\_p{]}}}, represent the number of times the
outcome was \sphinxcode{\sphinxupquote{i}}.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{multinomial}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{n}] \leavevmode{[}int{]}
Number of experiments.

\item[{pvals}] \leavevmode{[}sequence of floats, length p{]}
Probabilities of each of the \sphinxcode{\sphinxupquote{p}} different outcomes.  These
must sum to 1 (however, the last element is always assumed to
account for the remaining probability, as long as
\sphinxcode{\sphinxupquote{sum(pvals{[}:\sphinxhyphen{}1{]}) \textless{}= 1)}}.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  Default is None, in which case a
single value is returned.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray{]}
The drawn samples, of shape \sphinxstyleemphasis{size}, if that was provided.  If not,
the shape is \sphinxcode{\sphinxupquote{(N,)}}.

In other words, each entry \sphinxcode{\sphinxupquote{out{[}i,j,...,:{]}}} is an N\sphinxhyphen{}dimensional
value drawn from the distribution.

\end{description}

Generator.multinomial: which should be used for new code.

Throw a dice 20 times:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{multinomial}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{array([[4, 1, 7, 5, 2, 1]]) \PYGZsh{} random}
\end{sphinxVerbatim}

It landed 4 times on 1, once on 2, etc.

Now, throw the dice 20 times, and 20 times again:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{multinomial}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{array([[3, 4, 3, 3, 4, 3], \PYGZsh{} random}
\PYG{g+go}{       [2, 4, 3, 4, 0, 7]])}
\end{sphinxVerbatim}

For the first run, we threw 3 times 1, 4 times 2, etc.  For the second,
we threw 2 times 1, 4 times 2, etc.

A loaded die is more likely to land on number 6:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{multinomial}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mf}{7.}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{5} \PYG{o}{+} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mf}{7.}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{array([11, 16, 14, 17, 16, 26]) \PYGZsh{} random}
\end{sphinxVerbatim}

The probability inputs should be normalized. As an implementation
detail, the value of the last entry is ignored and assumed to take
up any leftover probability mass, but this should not be relied on.
A biased coin which has twice as much weight on one side as on the
other should be sampled like so:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{multinomial}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{1.0} \PYG{o}{/} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mf}{2.0} \PYG{o}{/} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} RIGHT}
\PYG{g+go}{array([38, 62]) \PYGZsh{} random}
\end{sphinxVerbatim}

not like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{multinomial}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{2.0}\PYG{p}{]}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} WRONG}
\PYG{g+gt}{Traceback (most recent call last):}
\PYG{g+gr}{ValueError}: \PYG{n}{pvals \PYGZlt{} 0, pvals \PYGZgt{} 1 or pvals contains NaNs}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{multivariate\_normal() (in module infrapy.utils.ref2sac)@\spxentry{multivariate\_normal()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.multivariate_normal}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{multivariate\_normal}}}{\emph{mean}, \emph{cov}, \emph{size=None}, \emph{check\_valid=\textquotesingle{}warn\textquotesingle{}}, \emph{tol=1e\sphinxhyphen{}8}}{}
Draw random samples from a multivariate normal distribution.

The multivariate normal, multinormal or Gaussian distribution is a
generalization of the one\sphinxhyphen{}dimensional normal distribution to higher
dimensions.  Such a distribution is specified by its mean and
covariance matrix.  These parameters are analogous to the mean
(average or “center”) and variance (standard deviation, or “width,”
squared) of the one\sphinxhyphen{}dimensional normal distribution.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{multivariate\_normal}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{mean}] \leavevmode{[}1\sphinxhyphen{}D array\_like, of length N{]}
Mean of the N\sphinxhyphen{}dimensional distribution.

\item[{cov}] \leavevmode{[}2\sphinxhyphen{}D array\_like, of shape (N, N){]}
Covariance matrix of the distribution. It must be symmetric and
positive\sphinxhyphen{}semidefinite for proper sampling.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Given a shape of, for example, \sphinxcode{\sphinxupquote{(m,n,k)}}, \sphinxcode{\sphinxupquote{m*n*k}} samples are
generated, and packed in an \sphinxtitleref{m}\sphinxhyphen{}by\sphinxhyphen{}\sphinxtitleref{n}\sphinxhyphen{}by\sphinxhyphen{}\sphinxtitleref{k} arrangement.  Because
each sample is \sphinxtitleref{N}\sphinxhyphen{}dimensional, the output shape is \sphinxcode{\sphinxupquote{(m,n,k,N)}}.
If no shape is specified, a single (\sphinxtitleref{N}\sphinxhyphen{}D) sample is returned.

\item[{check\_valid}] \leavevmode{[}\{ ‘warn’, ‘raise’, ‘ignore’ \}, optional{]}
Behavior when the covariance matrix is not positive semidefinite.

\item[{tol}] \leavevmode{[}float, optional{]}
Tolerance when checking the singular values in covariance matrix.
cov is cast to double before the check.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray{]}
The drawn samples, of shape \sphinxstyleemphasis{size}, if that was provided.  If not,
the shape is \sphinxcode{\sphinxupquote{(N,)}}.

In other words, each entry \sphinxcode{\sphinxupquote{out{[}i,j,...,:{]}}} is an N\sphinxhyphen{}dimensional
value drawn from the distribution.

\end{description}

Generator.multivariate\_normal: which should be used for new code.

The mean is a coordinate in N\sphinxhyphen{}dimensional space, which represents the
location where samples are most likely to be generated.  This is
analogous to the peak of the bell curve for the one\sphinxhyphen{}dimensional or
univariate normal distribution.

Covariance indicates the level to which two variables vary together.
From the multivariate normal distribution, we draw N\sphinxhyphen{}dimensional
samples, \(X = [x_1, x_2, ... x_N]\).  The covariance matrix
element \(C_{ij}\) is the covariance of \(x_i\) and \(x_j\).
The element \(C_{ii}\) is the variance of \(x_i\) (i.e. its
“spread”).

Instead of specifying the full covariance matrix, popular
approximations include:
\begin{itemize}
\item {} 
Spherical covariance (\sphinxtitleref{cov} is a multiple of the identity matrix)

\item {} 
Diagonal covariance (\sphinxtitleref{cov} has non\sphinxhyphen{}negative elements, and only on
the diagonal)

\end{itemize}

This geometrical property can be seen in two dimensions by plotting
generated data\sphinxhyphen{}points:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mean} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cov} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} diagonal covariance}
\end{sphinxVerbatim}

Diagonal covariance means that points are oriented along x or y\sphinxhyphen{}axis:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{multivariate\PYGZus{}normal}\PYG{p}{(}\PYG{n}{mean}\PYG{p}{,} \PYG{n}{cov}\PYG{p}{,} \PYG{l+m+mi}{5000}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{equal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

Note that the covariance matrix must be positive semidefinite (a.k.a.
nonnegative\sphinxhyphen{}definite). Otherwise, the behavior of this method is
undefined and backwards compatibility is not guaranteed.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mean} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cov} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{multivariate\PYGZus{}normal}\PYG{p}{(}\PYG{n}{mean}\PYG{p}{,} \PYG{n}{cov}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(3, 3, 2)}
\end{sphinxVerbatim}

The following is probably true, given that 0.6 is roughly twice the
standard deviation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{mean}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.6}\PYG{p}{)}
\PYG{g+go}{[True, True] \PYGZsh{} random}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{negative\_binomial() (in module infrapy.utils.ref2sac)@\spxentry{negative\_binomial()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.negative_binomial}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{negative\_binomial}}}{\emph{n}, \emph{p}, \emph{size=None}}{}
Draw samples from a negative binomial distribution.

Samples are drawn from a negative binomial distribution with specified
parameters, \sphinxtitleref{n} successes and \sphinxtitleref{p} probability of success where \sphinxtitleref{n}
is \textgreater{} 0 and \sphinxtitleref{p} is in the interval {[}0, 1{]}.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{negative\_binomial}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{n}] \leavevmode{[}float or array\_like of floats{]}
Parameter of the distribution, \textgreater{} 0.

\item[{p}] \leavevmode{[}float or array\_like of floats{]}
Parameter of the distribution, \textgreater{}= 0 and \textless{}=1.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{n}} and \sphinxcode{\sphinxupquote{p}} are both scalars.
Otherwise, \sphinxcode{\sphinxupquote{np.broadcast(n, p).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized negative binomial distribution,
where each sample is equal to N, the number of failures that
occurred before a total of n successes was reached.

\end{description}

Generator.negative\_binomial: which should be used for new code.

The probability mass function of the negative binomial distribution is
\begin{equation*}
\begin{split}P(N;n,p) = \frac{\Gamma(N+n)}{N!\Gamma(n)}p^{n}(1-p)^{N},\end{split}
\end{equation*}
where \(n\) is the number of successes, \(p\) is the
probability of success, \(N+n\) is the number of trials, and
\(\Gamma\) is the gamma function. When \(n\) is an integer,
\(\frac{\Gamma(N+n)}{N!\Gamma(n)} = \binom{N+n-1}{N}\), which is
the more common form of this term in the the pmf. The negative
binomial distribution gives the probability of N failures given n
successes, with a success on the last trial.

If one throws a die repeatedly until the third time a “1” appears,
then the probability distribution of the number of non\sphinxhyphen{}“1”s that
appear before the third “1” is a negative binomial distribution.

Draw samples from the distribution:

A real world example. A company drills wild\sphinxhyphen{}cat oil
exploration wells, each with an estimated probability of
success of 0.1.  What is the probability of having one success
for each successive well, that is what is the probability of a
single success after drilling 5 wells, after 6 wells, etc.?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{negative\PYGZus{}binomial}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mi}{100000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{:} 
\PYG{g+gp}{... }   \PYG{n}{probability} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{s}\PYG{o}{\PYGZlt{}}\PYG{n}{i}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mf}{100000.}
\PYG{g+gp}{... }   \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{wells drilled, probability of one success =}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{probability}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{noncentral\_chisquare() (in module infrapy.utils.ref2sac)@\spxentry{noncentral\_chisquare()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.noncentral_chisquare}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{noncentral\_chisquare}}}{\emph{df}, \emph{nonc}, \emph{size=None}}{}
Draw samples from a noncentral chi\sphinxhyphen{}square distribution.

The noncentral \(\chi^2\) distribution is a generalization of
the \(\chi^2\) distribution.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{noncentral\_chisquare}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{df}] \leavevmode{[}float or array\_like of floats{]}
Degrees of freedom, must be \textgreater{} 0.

\DUrole{versionmodified,changed}{Changed in version 1.10.0: }Earlier NumPy versions required dfnum \textgreater{} 1.

\item[{nonc}] \leavevmode{[}float or array\_like of floats{]}
Non\sphinxhyphen{}centrality, must be non\sphinxhyphen{}negative.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{df}} and \sphinxcode{\sphinxupquote{nonc}} are both scalars.
Otherwise, \sphinxcode{\sphinxupquote{np.broadcast(df, nonc).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized noncentral chi\sphinxhyphen{}square distribution.

\end{description}

Generator.noncentral\_chisquare: which should be used for new code.

The probability density function for the noncentral Chi\sphinxhyphen{}square
distribution is
\begin{equation*}
\begin{split}P(x;df,nonc) = \sum^{\infty}_{i=0}
\frac{e^{-nonc/2}(nonc/2)^{i}}{i!}
P_{Y_{df+2i}}(x),\end{split}
\end{equation*}
where \(Y_{q}\) is the Chi\sphinxhyphen{}square with q degrees of freedom.

Draw values from the distribution and plot the histogram

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{values} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{noncentral\PYGZus{}chisquare}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{100000}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }                  \PYG{n}{bins}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

Draw values from a noncentral chisquare with very small noncentrality,
and compare to a chisquare.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{values} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{noncentral\PYGZus{}chisquare}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{.}\PYG{l+m+mi}{0000001}\PYG{p}{,} \PYG{l+m+mi}{100000}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }                  \PYG{n}{bins}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{,} \PYG{o}{.}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{values2} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{chisquare}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{100000}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }                   \PYG{n}{bins}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{,} \PYG{o}{.}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{values}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{values}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{values2}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ob}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

Demonstrate how large values of non\sphinxhyphen{}centrality lead to a more symmetric
distribution.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{values} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{noncentral\PYGZus{}chisquare}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{100000}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }                  \PYG{n}{bins}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{noncentral\_f() (in module infrapy.utils.ref2sac)@\spxentry{noncentral\_f()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.noncentral_f}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{noncentral\_f}}}{\emph{dfnum}, \emph{dfden}, \emph{nonc}, \emph{size=None}}{}
Draw samples from the noncentral F distribution.

Samples are drawn from an F distribution with specified parameters,
\sphinxtitleref{dfnum} (degrees of freedom in numerator) and \sphinxtitleref{dfden} (degrees of
freedom in denominator), where both parameters \textgreater{} 1.
\sphinxtitleref{nonc} is the non\sphinxhyphen{}centrality parameter.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{noncentral\_f}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{dfnum}] \leavevmode{[}float or array\_like of floats{]}
Numerator degrees of freedom, must be \textgreater{} 0.

\DUrole{versionmodified,changed}{Changed in version 1.14.0: }Earlier NumPy versions required dfnum \textgreater{} 1.

\item[{dfden}] \leavevmode{[}float or array\_like of floats{]}
Denominator degrees of freedom, must be \textgreater{} 0.

\item[{nonc}] \leavevmode{[}float or array\_like of floats{]}
Non\sphinxhyphen{}centrality parameter, the sum of the squares of the numerator
means, must be \textgreater{}= 0.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{dfnum}}, \sphinxcode{\sphinxupquote{dfden}}, and \sphinxcode{\sphinxupquote{nonc}}
are all scalars.  Otherwise, \sphinxcode{\sphinxupquote{np.broadcast(dfnum, dfden, nonc).size}}
samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized noncentral Fisher distribution.

\end{description}

Generator.noncentral\_f: which should be used for new code.

When calculating the power of an experiment (power = probability of
rejecting the null hypothesis when a specific alternative is true) the
non\sphinxhyphen{}central F statistic becomes important.  When the null hypothesis is
true, the F statistic follows a central F distribution. When the null
hypothesis is not true, then it follows a non\sphinxhyphen{}central F statistic.

In a study, testing for a specific alternative to the null hypothesis
requires use of the Noncentral F distribution. We need to calculate the
area in the tail of the distribution that exceeds the value of the F
distribution for the null hypothesis.  We’ll plot the two probability
distributions for comparison.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dfnum} \PYG{o}{=} \PYG{l+m+mi}{3} \PYG{c+c1}{\PYGZsh{} between group deg of freedom}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dfden} \PYG{o}{=} \PYG{l+m+mi}{20} \PYG{c+c1}{\PYGZsh{} within groups degrees of freedom}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{nonc} \PYG{o}{=} \PYG{l+m+mf}{3.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{nc\PYGZus{}vals} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{noncentral\PYGZus{}f}\PYG{p}{(}\PYG{n}{dfnum}\PYG{p}{,} \PYG{n}{dfden}\PYG{p}{,} \PYG{n}{nonc}\PYG{p}{,} \PYG{l+m+mi}{1000000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{NF} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{histogram}\PYG{p}{(}\PYG{n}{nc\PYGZus{}vals}\PYG{p}{,} \PYG{n}{bins}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c\PYGZus{}vals} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{f}\PYG{p}{(}\PYG{n}{dfnum}\PYG{p}{,} \PYG{n}{dfden}\PYG{p}{,} \PYG{l+m+mi}{1000000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{histogram}\PYG{p}{(}\PYG{n}{c\PYGZus{}vals}\PYG{p}{,} \PYG{n}{bins}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{F}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}\PYG{p}{,} \PYG{n}{F}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{NF}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}\PYG{p}{,} \PYG{n}{NF}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{normal() (in module infrapy.utils.ref2sac)@\spxentry{normal()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.normal}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{normal}}}{\emph{loc=0.0}, \emph{scale=1.0}, \emph{size=None}}{}
Draw random samples from a normal (Gaussian) distribution.

The probability density function of the normal distribution, first
derived by De Moivre and 200 years later by both Gauss and Laplace
independently {\color{red}\bfseries{}{[}2{]}\_}, is often called the bell curve because of
its characteristic shape (see the example below).

The normal distributions occurs often in nature.  For example, it
describes the commonly occurring distribution of samples influenced
by a large number of tiny, random disturbances, each with its own
unique distribution {\color{red}\bfseries{}{[}2{]}\_}.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{normal}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{loc}] \leavevmode{[}float or array\_like of floats{]}
Mean (“centre”) of the distribution.

\item[{scale}] \leavevmode{[}float or array\_like of floats{]}
Standard deviation (spread or “width”) of the distribution. Must be
non\sphinxhyphen{}negative.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{loc}} and \sphinxcode{\sphinxupquote{scale}} are both scalars.
Otherwise, \sphinxcode{\sphinxupquote{np.broadcast(loc, scale).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized normal distribution.

\end{description}
\begin{description}
\item[{scipy.stats.norm}] \leavevmode{[}probability density function, distribution or{]}
cumulative density function, etc.

\end{description}

Generator.normal: which should be used for new code.

The probability density for the Gaussian distribution is
\begin{equation*}
\begin{split}p(x) = \frac{1}{\sqrt{ 2 \pi \sigma^2 }}
e^{ - \frac{ (x - \mu)^2 } {2 \sigma^2} },\end{split}
\end{equation*}
where \(\mu\) is the mean and \(\sigma\) the standard
deviation. The square of the standard deviation, \(\sigma^2\),
is called the variance.

The function has its peak at the mean, and its “spread” increases with
the standard deviation (the function reaches 0.607 times its maximum at
\(x + \sigma\) and \(x - \sigma\) {\color{red}\bfseries{}{[}2{]}\_}).  This implies that
normal is more likely to return samples lying close to the mean, rather
than those far away.

Draw samples from the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mu}\PYG{p}{,} \PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.1} \PYG{c+c1}{\PYGZsh{} mean and standard deviation}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{n}{mu}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\end{sphinxVerbatim}

Verify the mean and the variance:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{mu} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{0.0  \PYGZsh{} may vary}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{sigma} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{ddof}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{0.1  \PYGZsh{} may vary}
\end{sphinxVerbatim}

Display the histogram of the samples, along with
the probability density function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{count}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignored} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{n}{sigma} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*}
\PYG{g+gp}{... }               \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{bins} \PYG{o}{\PYGZhy{}} \PYG{n}{mu}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{sigma}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

Two\sphinxhyphen{}by\sphinxhyphen{}four array of samples from N(3, 6.25):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{array([[\PYGZhy{}4.49401501,  4.00950034, \PYGZhy{}1.81814867,  7.29718677],   \PYGZsh{} random}
\PYG{g+go}{       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  \PYGZsh{} random}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{pareto() (in module infrapy.utils.ref2sac)@\spxentry{pareto()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.pareto}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{pareto}}}{\emph{a}, \emph{size=None}}{}
Draw samples from a Pareto II or Lomax distribution with
specified shape.

The Lomax or Pareto II distribution is a shifted Pareto
distribution. The classical Pareto distribution can be
obtained from the Lomax distribution by adding 1 and
multiplying by the scale parameter \sphinxcode{\sphinxupquote{m}} (see Notes).  The
smallest value of the Lomax distribution is zero while for the
classical Pareto distribution it is \sphinxcode{\sphinxupquote{mu}}, where the standard
Pareto distribution has location \sphinxcode{\sphinxupquote{mu = 1}}.  Lomax can also
be considered as a simplified version of the Generalized
Pareto distribution (available in SciPy), with the scale set
to one and the location set to zero.

The Pareto distribution must be greater than zero, and is
unbounded above.  It is also known as the “80\sphinxhyphen{}20 rule”.  In
this distribution, 80 percent of the weights are in the lowest
20 percent of the range, while the other 20 percent fill the
remaining 80 percent of the range.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{pareto}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{a}] \leavevmode{[}float or array\_like of floats{]}
Shape of the distribution. Must be positive.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{a}} is a scalar.  Otherwise,
\sphinxcode{\sphinxupquote{np.array(a).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized Pareto distribution.

\end{description}
\begin{description}
\item[{scipy.stats.lomax}] \leavevmode{[}probability density function, distribution or{]}
cumulative density function, etc.

\item[{scipy.stats.genpareto}] \leavevmode{[}probability density function, distribution or{]}
cumulative density function, etc.

\end{description}

Generator.pareto: which should be used for new code.

The probability density for the Pareto distribution is
\begin{equation*}
\begin{split}p(x) = \frac{am^a}{x^{a+1}}\end{split}
\end{equation*}
where \(a\) is the shape and \(m\) the scale.

The Pareto distribution, named after the Italian economist
Vilfredo Pareto, is a power law probability distribution
useful in many real world problems.  Outside the field of
economics it is generally referred to as the Bradford
distribution. Pareto developed the distribution to describe
the distribution of wealth in an economy.  It has also found
use in insurance, web page access statistics, oil field sizes,
and many other problems, including the download frequency for
projects in Sourceforge {\color{red}\bfseries{}{[}1{]}\_}.  It is one of the so\sphinxhyphen{}called
“fat\sphinxhyphen{}tailed” distributions.

Draw samples from the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{,} \PYG{n}{m} \PYG{o}{=} \PYG{l+m+mf}{3.}\PYG{p}{,} \PYG{l+m+mf}{2.}  \PYG{c+c1}{\PYGZsh{} shape and mode}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{pareto}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{m}
\end{sphinxVerbatim}

Display the histogram of the samples, along with the probability
density function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{count}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fit} \PYG{o}{=} \PYG{n}{a}\PYG{o}{*}\PYG{n}{m}\PYG{o}{*}\PYG{o}{*}\PYG{n}{a} \PYG{o}{/} \PYG{n}{bins}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{,} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{count}\PYG{p}{)}\PYG{o}{*}\PYG{n}{fit}\PYG{o}{/}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{fit}\PYG{p}{)}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{permutation() (in module infrapy.utils.ref2sac)@\spxentry{permutation()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.permutation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{permutation}}}{\emph{x}}{}
Randomly permute a sequence, or return a permuted range.

If \sphinxtitleref{x} is a multi\sphinxhyphen{}dimensional array, it is only shuffled along its
first index.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{permutation}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{x}] \leavevmode{[}int or array\_like{]}
If \sphinxtitleref{x} is an integer, randomly permute \sphinxcode{\sphinxupquote{np.arange(x)}}.
If \sphinxtitleref{x} is an array, make a copy and shuffle the elements
randomly.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray{]}
Permuted sequence or array range.

\end{description}

Generator.permutation: which should be used for new code.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{permutation}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{g+go}{array([1, 7, 4, 3, 0, 9, 2, 5, 8, 6]) \PYGZsh{} random}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{permutation}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{array([15,  1,  9,  4, 12]) \PYGZsh{} random}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{permutation}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)}
\PYG{g+go}{array([[6, 7, 8], \PYGZsh{} random}
\PYG{g+go}{       [0, 1, 2],}
\PYG{g+go}{       [3, 4, 5]])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{poisson() (in module infrapy.utils.ref2sac)@\spxentry{poisson()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.poisson}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{poisson}}}{\emph{lam=1.0}, \emph{size=None}}{}
Draw samples from a Poisson distribution.

The Poisson distribution is the limit of the binomial distribution
for large N.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{poisson}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{lam}] \leavevmode{[}float or array\_like of floats{]}
Expectation of interval, must be \textgreater{}= 0. A sequence of expectation
intervals must be broadcastable over the requested size.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{lam}} is a scalar. Otherwise,
\sphinxcode{\sphinxupquote{np.array(lam).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized Poisson distribution.

\end{description}

Generator.poisson: which should be used for new code.

The Poisson distribution
\begin{equation*}
\begin{split}f(k; \lambda)=\frac{\lambda^k e^{-\lambda}}{k!}\end{split}
\end{equation*}
For events with an expected separation \(\lambda\) the Poisson
distribution \(f(k; \lambda)\) describes the probability of
\(k\) events occurring within the observed
interval \(\lambda\).

Because the output is limited to the range of the C int64 type, a
ValueError is raised when \sphinxtitleref{lam} is within 10 sigma of the maximum
representable value.

Draw samples from the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{poisson}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{10000}\PYG{p}{)}
\end{sphinxVerbatim}

Display histogram of the sample:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{count}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignored} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{l+m+mi}{14}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

Draw each 100 values for lambda 100 and 500:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{poisson}\PYG{p}{(}\PYG{n}{lam}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{100.}\PYG{p}{,} \PYG{l+m+mf}{500.}\PYG{p}{)}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{power() (in module infrapy.utils.ref2sac)@\spxentry{power()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.power}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{power}}}{\emph{a}, \emph{size=None}}{}
Draws samples in {[}0, 1{]} from a power distribution with positive
exponent a \sphinxhyphen{} 1.

Also known as the power function distribution.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{power}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{a}] \leavevmode{[}float or array\_like of floats{]}
Parameter of the distribution. Must be non\sphinxhyphen{}negative.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{a}} is a scalar.  Otherwise,
\sphinxcode{\sphinxupquote{np.array(a).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized power distribution.

\end{description}
\begin{description}
\item[{ValueError}] \leavevmode
If a \textless{} 1.

\end{description}

Generator.power: which should be used for new code.

The probability density function is
\begin{equation*}
\begin{split}P(x; a) = ax^{a-1}, 0 \le x \le 1, a>0.\end{split}
\end{equation*}
The power function distribution is just the inverse of the Pareto
distribution. It may also be seen as a special case of the Beta
distribution.

It is used, for example, in modeling the over\sphinxhyphen{}reporting of insurance
claims.

Draw samples from the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{5.} \PYG{c+c1}{\PYGZsh{} shape}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{samples} \PYG{o}{=} \PYG{l+m+mi}{1000}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{samples}\PYG{p}{)}
\end{sphinxVerbatim}

Display the histogram of the samples, along with
the probability density function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{count}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignored} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{bins}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y} \PYG{o}{=} \PYG{n}{a}\PYG{o}{*}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{normed\PYGZus{}y} \PYG{o}{=} \PYG{n}{samples}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{diff}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{y}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{normed\PYGZus{}y}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

Compare the power function distribution to the inverse of the Pareto.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{scipy} \PYG{k+kn}{import} \PYG{n}{stats} 
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rvs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{1000000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rvsp} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{pareto}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{1000000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{xx} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{powpdf} \PYG{o}{=} \PYG{n}{stats}\PYG{o}{.}\PYG{n}{powerlaw}\PYG{o}{.}\PYG{n}{pdf}\PYG{p}{(}\PYG{n}{xx}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}  
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{rvs}\PYG{p}{,} \PYG{n}{bins}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xx}\PYG{p}{,}\PYG{n}{powpdf}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{np.random.power(5)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{n}{rvsp}\PYG{p}{)}\PYG{p}{,} \PYG{n}{bins}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xx}\PYG{p}{,}\PYG{n}{powpdf}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{inverse of 1 + np.random.pareto(5)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{n}{rvsp}\PYG{p}{)}\PYG{p}{,} \PYG{n}{bins}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xx}\PYG{p}{,}\PYG{n}{powpdf}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{inverse of stats.pareto(5)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{rand() (in module infrapy.utils.ref2sac)@\spxentry{rand()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.rand}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{rand}}}{\emph{d0}, \emph{d1}, \emph{...}, \emph{dn}}{}
Random values in a given shape.

\begin{sphinxadmonition}{note}{Note:}
This is a convenience function for users porting code from Matlab,
and wraps \sphinxtitleref{random\_sample}. That function takes a
tuple to specify the size of the output, which is consistent with
other NumPy functions like \sphinxtitleref{numpy.zeros} and \sphinxtitleref{numpy.ones}.
\end{sphinxadmonition}

Create an array of the given shape and populate it with
random samples from a uniform distribution
over \sphinxcode{\sphinxupquote{{[}0, 1)}}.
\begin{description}
\item[{d0, d1, …, dn}] \leavevmode{[}int, optional{]}
The dimensions of the returned array, must be non\sphinxhyphen{}negative.
If no argument is given a single Python float is returned.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray, shape \sphinxcode{\sphinxupquote{(d0, d1, ..., dn)}}{]}
Random values.

\end{description}

random

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{array([[ 0.14022471,  0.96360618],  \PYGZsh{}random}
\PYG{g+go}{       [ 0.37601032,  0.25528411],  \PYGZsh{}random}
\PYG{g+go}{       [ 0.49313049,  0.94909878]]) \PYGZsh{}random}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{randint() (in module infrapy.utils.ref2sac)@\spxentry{randint()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.randint}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{randint}}}{\emph{low}, \emph{high=None}, \emph{size=None}, \emph{dtype=\textquotesingle{}l\textquotesingle{}}}{}
Return random integers from \sphinxtitleref{low} (inclusive) to \sphinxtitleref{high} (exclusive).

Return random integers from the “discrete uniform” distribution of
the specified dtype in the “half\sphinxhyphen{}open” interval {[}\sphinxtitleref{low}, \sphinxtitleref{high}). If
\sphinxtitleref{high} is None (the default), then results are from {[}0, \sphinxtitleref{low}).

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{integers}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{low}] \leavevmode{[}int or array\sphinxhyphen{}like of ints{]}
Lowest (signed) integers to be drawn from the distribution (unless
\sphinxcode{\sphinxupquote{high=None}}, in which case this parameter is one above the
\sphinxstyleemphasis{highest} such integer).

\item[{high}] \leavevmode{[}int or array\sphinxhyphen{}like of ints, optional{]}
If provided, one above the largest (signed) integer to be drawn
from the distribution (see above for behavior if \sphinxcode{\sphinxupquote{high=None}}).
If array\sphinxhyphen{}like, must contain integer values

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  Default is None, in which case a
single value is returned.

\item[{dtype}] \leavevmode{[}dtype, optional{]}
Desired dtype of the result. All dtypes are determined by their
name, i.e., ‘int64’, ‘int’, etc, so byteorder is not available
and a specific precision may have different C types depending
on the platform. The default value is \sphinxtitleref{np.int\_}.

\DUrole{versionmodified,added}{New in version 1.11.0.}

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}int or ndarray of ints{]}
\sphinxtitleref{size}\sphinxhyphen{}shaped array of random integers from the appropriate
distribution, or a single such random int if \sphinxtitleref{size} not provided.

\end{description}
\begin{description}
\item[{random\_integers}] \leavevmode{[}similar to \sphinxtitleref{randint}, only for the closed{]}
interval {[}\sphinxtitleref{low}, \sphinxtitleref{high}{]}, and 1 is the lowest value if \sphinxtitleref{high} is
omitted.

\end{description}

Generator.integers: which should be used for new code.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{g+go}{array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) \PYGZsh{} random}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{g+go}{array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])}
\end{sphinxVerbatim}

Generate a 2 x 4 array of ints between 0 and 4, inclusive:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{array([[4, 0, 2, 1], \PYGZsh{} random}
\PYG{g+go}{       [3, 2, 2, 0]])}
\end{sphinxVerbatim}

Generate a 1 x 3 array with 3 different upper bounds

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{array([2, 2, 9]) \PYGZsh{} random}
\end{sphinxVerbatim}

Generate a 1 by 3 array with 3 different lower bounds

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{g+go}{array([9, 8, 7]) \PYGZsh{} random}
\end{sphinxVerbatim}

Generate a 2 by 4 array using broadcasting with dtype of uint8

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{uint8}\PYG{p}{)}
\PYG{g+go}{array([[ 8,  6,  9,  7], \PYGZsh{} random}
\PYG{g+go}{       [ 1, 16,  9, 12]], dtype=uint8)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{randn() (in module infrapy.utils.ref2sac)@\spxentry{randn()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.randn}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{randn}}}{\emph{d0}, \emph{d1}, \emph{...}, \emph{dn}}{}
Return a sample (or samples) from the “standard normal” distribution.

\begin{sphinxadmonition}{note}{Note:}
This is a convenience function for users porting code from Matlab,
and wraps \sphinxtitleref{standard\_normal}. That function takes a
tuple to specify the size of the output, which is consistent with
other NumPy functions like \sphinxtitleref{numpy.zeros} and \sphinxtitleref{numpy.ones}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{standard\_normal}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}

If positive int\_like arguments are provided, \sphinxtitleref{randn} generates an array
of shape \sphinxcode{\sphinxupquote{(d0, d1, ..., dn)}}, filled
with random floats sampled from a univariate “normal” (Gaussian)
distribution of mean 0 and variance 1. A single float randomly sampled
from the distribution is returned if no argument is provided.
\begin{description}
\item[{d0, d1, …, dn}] \leavevmode{[}int, optional{]}
The dimensions of the returned array, must be non\sphinxhyphen{}negative.
If no argument is given a single Python float is returned.

\end{description}
\begin{description}
\item[{Z}] \leavevmode{[}ndarray or float{]}
A \sphinxcode{\sphinxupquote{(d0, d1, ..., dn)}}\sphinxhyphen{}shaped array of floating\sphinxhyphen{}point samples from
the standard normal distribution, or a single such float if
no parameters were supplied.

\end{description}

standard\_normal : Similar, but takes a tuple as its argument.
normal : Also accepts mu and sigma arguments.
Generator.standard\_normal: which should be used for new code.

For random samples from \(N(\mu, \sigma^2)\), use:

\sphinxcode{\sphinxupquote{sigma * np.random.randn(...) + mu}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{2.1923875335537315  \PYGZsh{} random}
\end{sphinxVerbatim}

Two\sphinxhyphen{}by\sphinxhyphen{}four array of samples from N(3, 6.25):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{l+m+mf}{2.5} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+go}{array([[\PYGZhy{}4.49401501,  4.00950034, \PYGZhy{}1.81814867,  7.29718677],   \PYGZsh{} random}
\PYG{g+go}{       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  \PYGZsh{} random}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{random() (in module infrapy.utils.ref2sac)@\spxentry{random()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.random}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{random}}}{\emph{size=None}}{}
Return random floats in the half\sphinxhyphen{}open interval {[}0.0, 1.0). Alias for
\sphinxtitleref{random\_sample} to ease forward\sphinxhyphen{}porting to the new random API.

\end{fulllineitems}

\index{random\_integers() (in module infrapy.utils.ref2sac)@\spxentry{random\_integers()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.random_integers}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{random\_integers}}}{\emph{low}, \emph{high=None}, \emph{size=None}}{}
Random integers of type \sphinxtitleref{np.int\_} between \sphinxtitleref{low} and \sphinxtitleref{high}, inclusive.

Return random integers of type \sphinxtitleref{np.int\_} from the “discrete uniform”
distribution in the closed interval {[}\sphinxtitleref{low}, \sphinxtitleref{high}{]}.  If \sphinxtitleref{high} is
None (the default), then results are from {[}1, \sphinxtitleref{low}{]}. The \sphinxtitleref{np.int\_}
type translates to the C long integer type and its precision
is platform dependent.

This function has been deprecated. Use randint instead.

\DUrole{versionmodified,deprecated}{Deprecated since version 1.11.0.}
\begin{description}
\item[{low}] \leavevmode{[}int{]}
Lowest (signed) integer to be drawn from the distribution (unless
\sphinxcode{\sphinxupquote{high=None}}, in which case this parameter is the \sphinxstyleemphasis{highest} such
integer).

\item[{high}] \leavevmode{[}int, optional{]}
If provided, the largest (signed) integer to be drawn from the
distribution (see above for behavior if \sphinxcode{\sphinxupquote{high=None}}).

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  Default is None, in which case a
single value is returned.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}int or ndarray of ints{]}
\sphinxtitleref{size}\sphinxhyphen{}shaped array of random integers from the appropriate
distribution, or a single such random int if \sphinxtitleref{size} not provided.

\end{description}
\begin{description}
\item[{randint}] \leavevmode{[}Similar to \sphinxtitleref{random\_integers}, only for the half\sphinxhyphen{}open{]}
interval {[}\sphinxtitleref{low}, \sphinxtitleref{high}), and 0 is the lowest value if \sphinxtitleref{high} is
omitted.

\end{description}

To sample from N evenly spaced floating\sphinxhyphen{}point numbers between a and b,
use:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{+} \PYG{p}{(}\PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{a}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random\PYGZus{}integers}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{n}{N} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1.}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random\PYGZus{}integers}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+go}{4 \PYGZsh{} random}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random\PYGZus{}integers}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}class \PYGZsq{}numpy.int64\PYGZsq{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random\PYGZus{}integers}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{array([[5, 4], \PYGZsh{} random}
\PYG{g+go}{       [3, 3],}
\PYG{g+go}{       [4, 5]])}
\end{sphinxVerbatim}

Choose five random numbers from the set of five evenly\sphinxhyphen{}spaced
numbers between 0 and 2.5, inclusive (\sphinxstyleemphasis{i.e.}, from the set
\({0, 5/8, 10/8, 15/8, 20/8}\)):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mf}{2.5} \PYG{o}{*} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random\PYGZus{}integers}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mf}{4.}
\PYG{g+go}{array([ 0.625,  1.25 ,  0.625,  0.625,  2.5  ]) \PYGZsh{} random}
\end{sphinxVerbatim}

Roll two six sided dice 1000 times and sum the results:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{d1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random\PYGZus{}integers}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{d2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random\PYGZus{}integers}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dsums} \PYG{o}{=} \PYG{n}{d1} \PYG{o}{+} \PYG{n}{d2}
\end{sphinxVerbatim}

Display results as a histogram:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{count}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignored} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{dsums}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{random\_sample() (in module infrapy.utils.ref2sac)@\spxentry{random\_sample()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.random_sample}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{random\_sample}}}{\emph{size=None}}{}
Return random floats in the half\sphinxhyphen{}open interval {[}0.0, 1.0).

Results are from the “continuous uniform” distribution over the
stated interval.  To sample \(Unif[a, b), b > a\) multiply
the output of \sphinxtitleref{random\_sample} by \sphinxtitleref{(b\sphinxhyphen{}a)} and add \sphinxtitleref{a}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{a}\PYG{p}{)} \PYG{o}{*} \PYG{n}{random\PYGZus{}sample}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{random}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  Default is None, in which case a
single value is returned.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}float or ndarray of floats{]}
Array of random floats of shape \sphinxtitleref{size} (unless \sphinxcode{\sphinxupquote{size=None}}, in which
case a single float is returned).

\end{description}

Generator.random: which should be used for new code.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random\PYGZus{}sample}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{0.47108547995356098 \PYGZsh{} random}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random\PYGZus{}sample}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}class \PYGZsq{}float\PYGZsq{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random\PYGZus{}sample}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428]) \PYGZsh{} random}
\end{sphinxVerbatim}

Three\sphinxhyphen{}by\sphinxhyphen{}two array of random numbers from {[}\sphinxhyphen{}5, 0):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random\PYGZus{}sample}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{5}
\PYG{g+go}{array([[\PYGZhy{}3.99149989, \PYGZhy{}0.52338984], \PYGZsh{} random}
\PYG{g+go}{       [\PYGZhy{}2.99091858, \PYGZhy{}0.79479508],}
\PYG{g+go}{       [\PYGZhy{}1.23204345, \PYGZhy{}1.75224494]])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{rayleigh() (in module infrapy.utils.ref2sac)@\spxentry{rayleigh()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.rayleigh}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{rayleigh}}}{\emph{scale=1.0}, \emph{size=None}}{}
Draw samples from a Rayleigh distribution.

The \(\chi\) and Weibull distributions are generalizations of the
Rayleigh.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{rayleigh}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{scale}] \leavevmode{[}float or array\_like of floats, optional{]}
Scale, also equals the mode. Must be non\sphinxhyphen{}negative. Default is 1.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{scale}} is a scalar.  Otherwise,
\sphinxcode{\sphinxupquote{np.array(scale).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized Rayleigh distribution.

\end{description}

Generator.rayleigh: which should be used for new code.

The probability density function for the Rayleigh distribution is
\begin{equation*}
\begin{split}P(x;scale) = \frac{x}{scale^2}e^{\frac{-x^2}{2 \cdotp scale^2}}\end{split}
\end{equation*}
The Rayleigh distribution would arise, for example, if the East
and North components of the wind velocity had identical zero\sphinxhyphen{}mean
Gaussian distributions.  Then the wind speed would have a Rayleigh
distribution.

Draw values from the distribution and plot the histogram

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k+kn}{import} \PYG{n}{hist}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{values} \PYG{o}{=} \PYG{n}{hist}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rayleigh}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{100000}\PYG{p}{)}\PYG{p}{,} \PYG{n}{bins}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

Wave heights tend to follow a Rayleigh distribution. If the mean wave
height is 1 meter, what fraction of waves are likely to be larger than 3
meters?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{meanvalue} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{modevalue} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)} \PYG{o}{*} \PYG{n}{meanvalue}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rayleigh}\PYG{p}{(}\PYG{n}{modevalue}\PYG{p}{,} \PYG{l+m+mi}{1000000}\PYG{p}{)}
\end{sphinxVerbatim}

The percentage of waves larger than 3 meters is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mf}{100.}\PYG{o}{*}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{s}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{1000000.}
\PYG{g+go}{0.087300000000000003 \PYGZsh{} random}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{seed() (in module infrapy.utils.ref2sac)@\spxentry{seed()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.seed}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{seed}}}{\emph{self}, \emph{seed=None}}{}
Reseed a legacy MT19937 BitGenerator

This is a convenience, legacy function.

The best practice is to \sphinxstylestrong{not} reseed a BitGenerator, rather to
recreate a new one. This method is here for legacy reasons.
This example demonstrates best practice.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{numpy}\PYG{n+nn}{.}\PYG{n+nn}{random} \PYG{k+kn}{import} \PYG{n}{MT19937}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{numpy}\PYG{n+nn}{.}\PYG{n+nn}{random} \PYG{k+kn}{import} \PYG{n}{RandomState}\PYG{p}{,} \PYG{n}{SeedSequence}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rs} \PYG{o}{=} \PYG{n}{RandomState}\PYG{p}{(}\PYG{n}{MT19937}\PYG{p}{(}\PYG{n}{SeedSequence}\PYG{p}{(}\PYG{l+m+mi}{123456789}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{\PYGZsh{} Later, you want to restart the stream}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rs} \PYG{o}{=} \PYG{n}{RandomState}\PYG{p}{(}\PYG{n}{MT19937}\PYG{p}{(}\PYG{n}{SeedSequence}\PYG{p}{(}\PYG{l+m+mi}{987654321}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{set\_state() (in module infrapy.utils.ref2sac)@\spxentry{set\_state()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.set_state}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{set\_state}}}{\emph{state}}{}
Set the internal state of the generator from a tuple.

For use if one has reason to manually (re\sphinxhyphen{})set the internal state of
the bit generator used by the RandomState instance. By default,
RandomState uses the “Mersenne Twister”{\color{red}\bfseries{}{[}1{]}\_} pseudo\sphinxhyphen{}random number
generating algorithm.
\begin{description}
\item[{state}] \leavevmode{[}\{tuple(str, ndarray of 624 uints, int, int, float), dict\}{]}
The \sphinxtitleref{state} tuple has the following items:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
the string ‘MT19937’, specifying the Mersenne Twister algorithm.

\item {} 
a 1\sphinxhyphen{}D array of 624 unsigned integers \sphinxcode{\sphinxupquote{keys}}.

\item {} 
an integer \sphinxcode{\sphinxupquote{pos}}.

\item {} 
an integer \sphinxcode{\sphinxupquote{has\_gauss}}.

\item {} 
a float \sphinxcode{\sphinxupquote{cached\_gaussian}}.

\end{enumerate}

If state is a dictionary, it is directly set using the BitGenerators
\sphinxtitleref{state} property.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}None{]}
Returns ‘None’ on success.

\end{description}

get\_state

\sphinxtitleref{set\_state} and \sphinxtitleref{get\_state} are not needed to work with any of the
random distributions in NumPy. If the internal state is manually altered,
the user should know exactly what he/she is doing.

For backwards compatibility, the form (str, array of 624 uints, int) is
also accepted although it is missing some information about the cached
Gaussian value: \sphinxcode{\sphinxupquote{state = (\textquotesingle{}MT19937\textquotesingle{}, keys, pos)}}.

\end{fulllineitems}

\index{shuffle() (in module infrapy.utils.ref2sac)@\spxentry{shuffle()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.shuffle}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{shuffle}}}{\emph{x}}{}
Modify a sequence in\sphinxhyphen{}place by shuffling its contents.

This function only shuffles the array along the first axis of a
multi\sphinxhyphen{}dimensional array. The order of sub\sphinxhyphen{}arrays is changed but
their contents remains the same.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{shuffle}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{x}] \leavevmode{[}array\_like{]}
The array or list to be shuffled.

\end{description}

None

Generator.shuffle: which should be used for new code.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{shuffle}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{arr}
\PYG{g+go}{[1 7 5 2 9 4 3 6 0 8] \PYGZsh{} random}
\end{sphinxVerbatim}

Multi\sphinxhyphen{}dimensional arrays are only shuffled along the first axis:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{shuffle}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{arr}
\PYG{g+go}{array([[3, 4, 5], \PYGZsh{} random}
\PYG{g+go}{       [6, 7, 8],}
\PYG{g+go}{       [0, 1, 2]])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{standard\_cauchy() (in module infrapy.utils.ref2sac)@\spxentry{standard\_cauchy()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.standard_cauchy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{standard\_cauchy}}}{\emph{size=None}}{}
Draw samples from a standard Cauchy distribution with mode = 0.

Also known as the Lorentz distribution.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{standard\_cauchy}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  Default is None, in which case a
single value is returned.

\end{description}
\begin{description}
\item[{samples}] \leavevmode{[}ndarray or scalar{]}
The drawn samples.

\end{description}

Generator.standard\_cauchy: which should be used for new code.

The probability density function for the full Cauchy distribution is
\begin{equation*}
\begin{split}P(x; x_0, \gamma) = \frac{1}{\pi \gamma \bigl[ 1+
(\frac{x-x_0}{\gamma})^2 \bigr] }\end{split}
\end{equation*}
and the Standard Cauchy distribution just sets \(x_0=0\) and
\(\gamma=1\)

The Cauchy distribution arises in the solution to the driven harmonic
oscillator problem, and also describes spectral line broadening. It
also describes the distribution of values at which a line tilted at
a random angle will cut the x axis.

When studying hypothesis tests that assume normality, seeing how the
tests perform on data from a Cauchy distribution is a good indicator of
their sensitivity to a heavy\sphinxhyphen{}tailed distribution, since the Cauchy looks
very much like a Gaussian distribution, but with heavier tails.

Draw samples and plot the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{standard\PYGZus{}cauchy}\PYG{p}{(}\PYG{l+m+mi}{1000000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{s}\PYG{p}{[}\PYG{p}{(}\PYG{n}{s}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{25}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{s}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{25}\PYG{p}{)}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} truncate distribution so it plots well}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{bins}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{standard\_exponential() (in module infrapy.utils.ref2sac)@\spxentry{standard\_exponential()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.standard_exponential}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{standard\_exponential}}}{\emph{size=None}}{}
Draw samples from the standard exponential distribution.

\sphinxtitleref{standard\_exponential} is identical to the exponential distribution
with a scale parameter of 1.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{standard\_exponential}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  Default is None, in which case a
single value is returned.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}float or ndarray{]}
Drawn samples.

\end{description}

Generator.standard\_exponential: which should be used for new code.

Output a 3x8000 array:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{n} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{standard\PYGZus{}exponential}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{8000}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{standard\_gamma() (in module infrapy.utils.ref2sac)@\spxentry{standard\_gamma()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.standard_gamma}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{standard\_gamma}}}{\emph{shape}, \emph{size=None}}{}
Draw samples from a standard Gamma distribution.

Samples are drawn from a Gamma distribution with specified parameters,
shape (sometimes designated “k”) and scale=1.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{standard\_gamma}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{shape}] \leavevmode{[}float or array\_like of floats{]}
Parameter, must be non\sphinxhyphen{}negative.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{shape}} is a scalar.  Otherwise,
\sphinxcode{\sphinxupquote{np.array(shape).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized standard gamma distribution.

\end{description}
\begin{description}
\item[{scipy.stats.gamma}] \leavevmode{[}probability density function, distribution or{]}
cumulative density function, etc.

\end{description}

Generator.standard\_gamma: which should be used for new code.

The probability density for the Gamma distribution is
\begin{equation*}
\begin{split}p(x) = x^{k-1}\frac{e^{-x/\theta}}{\theta^k\Gamma(k)},\end{split}
\end{equation*}
where \(k\) is the shape and \(\theta\) the scale,
and \(\Gamma\) is the Gamma function.

The Gamma distribution is often used to model the times to failure of
electronic components, and arises naturally in processes for which the
waiting times between Poisson distributed events are relevant.

Draw samples from the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{shape}\PYG{p}{,} \PYG{n}{scale} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{c+c1}{\PYGZsh{} mean and width}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{standard\PYGZus{}gamma}\PYG{p}{(}\PYG{n}{shape}\PYG{p}{,} \PYG{l+m+mi}{1000000}\PYG{p}{)}
\end{sphinxVerbatim}

Display the histogram of the samples, along with
the probability density function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{special} \PYG{k}{as} \PYG{n+nn}{sps}  
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{count}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignored} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y} \PYG{o}{=} \PYG{n}{bins}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{n}{shape}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{bins}\PYG{o}{/}\PYG{n}{scale}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}  
\PYG{g+gp}{... }                      \PYG{p}{(}\PYG{n}{sps}\PYG{o}{.}\PYG{n}{gamma}\PYG{p}{(}\PYG{n}{shape}\PYG{p}{)} \PYG{o}{*} \PYG{n}{scale}\PYG{o}{*}\PYG{o}{*}\PYG{n}{shape}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{standard\_normal() (in module infrapy.utils.ref2sac)@\spxentry{standard\_normal()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.standard_normal}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{standard\_normal}}}{\emph{size=None}}{}
Draw samples from a standard Normal distribution (mean=0, stdev=1).

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{standard\_normal}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  Default is None, in which case a
single value is returned.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}float or ndarray{]}
A floating\sphinxhyphen{}point array of shape \sphinxcode{\sphinxupquote{size}} of drawn samples, or a
single sample if \sphinxcode{\sphinxupquote{size}} was not specified.

\end{description}
\begin{description}
\item[{normal :}] \leavevmode
Equivalent function with additional \sphinxcode{\sphinxupquote{loc}} and \sphinxcode{\sphinxupquote{scale}} arguments
for setting the mean and standard deviation.

\end{description}

Generator.standard\_normal: which should be used for new code.

For random samples from \(N(\mu, \sigma^2)\), use one of:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mu} \PYG{o}{+} \PYG{n}{sigma} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{standard\PYGZus{}normal}\PYG{p}{(}\PYG{n}{size}\PYG{o}{=}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{n}{mu}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{standard\PYGZus{}normal}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{2.1923875335537315 \PYGZsh{}random}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{standard\PYGZus{}normal}\PYG{p}{(}\PYG{l+m+mi}{8000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}
\PYG{g+go}{array([ 0.6888893 ,  0.78096262, \PYGZhy{}0.89086505, ...,  0.49876311,  \PYGZsh{} random}
\PYG{g+go}{       \PYGZhy{}0.38672696, \PYGZhy{}0.4685006 ])                                \PYGZsh{} random}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(8000,)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{standard\PYGZus{}normal}\PYG{p}{(}\PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(3, 4, 2)}
\end{sphinxVerbatim}

Two\sphinxhyphen{}by\sphinxhyphen{}four array of samples from \(N(3, 6.25)\):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{l+m+mf}{2.5} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{standard\PYGZus{}normal}\PYG{p}{(}\PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{array([[\PYGZhy{}4.49401501,  4.00950034, \PYGZhy{}1.81814867,  7.29718677],   \PYGZsh{} random}
\PYG{g+go}{       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  \PYGZsh{} random}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{standard\_t() (in module infrapy.utils.ref2sac)@\spxentry{standard\_t()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.standard_t}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{standard\_t}}}{\emph{df}, \emph{size=None}}{}
Draw samples from a standard Student’s t distribution with \sphinxtitleref{df} degrees
of freedom.

A special case of the hyperbolic distribution.  As \sphinxtitleref{df} gets
large, the result resembles that of the standard normal
distribution (\sphinxtitleref{standard\_normal}).

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{standard\_t}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{df}] \leavevmode{[}float or array\_like of floats{]}
Degrees of freedom, must be \textgreater{} 0.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{df}} is a scalar.  Otherwise,
\sphinxcode{\sphinxupquote{np.array(df).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized standard Student’s t distribution.

\end{description}

Generator.standard\_t: which should be used for new code.

The probability density function for the t distribution is
\begin{equation*}
\begin{split}P(x, df) = \frac{\Gamma(\frac{df+1}{2})}{\sqrt{\pi df}
\Gamma(\frac{df}{2})}\Bigl( 1+\frac{x^2}{df} \Bigr)^{-(df+1)/2}\end{split}
\end{equation*}
The t test is based on an assumption that the data come from a
Normal distribution. The t test provides a way to test whether
the sample mean (that is the mean calculated from the data) is
a good estimate of the true mean.

The derivation of the t\sphinxhyphen{}distribution was first published in
1908 by William Gosset while working for the Guinness Brewery
in Dublin. Due to proprietary issues, he had to publish under
a pseudonym, and so he used the name Student.

From Dalgaard page 83 {\color{red}\bfseries{}{[}1{]}\_}, suppose the daily energy intake for 11
women in kilojoules (kJ) is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{intake} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{5260.}\PYG{p}{,} \PYG{l+m+mi}{5470}\PYG{p}{,} \PYG{l+m+mi}{5640}\PYG{p}{,} \PYG{l+m+mi}{6180}\PYG{p}{,} \PYG{l+m+mi}{6390}\PYG{p}{,} \PYG{l+m+mi}{6515}\PYG{p}{,} \PYG{l+m+mi}{6805}\PYG{p}{,} \PYG{l+m+mi}{7515}\PYG{p}{,} \PYGZbs{}
\PYG{g+gp}{... }                   \PYG{l+m+mi}{7515}\PYG{p}{,} \PYG{l+m+mi}{8230}\PYG{p}{,} \PYG{l+m+mi}{8770}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Does their energy intake deviate systematically from the recommended
value of 7725 kJ?

We have 10 degrees of freedom, so is the sample mean within 95\% of the
recommended value?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{standard\PYGZus{}t}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{l+m+mi}{100000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{intake}\PYG{p}{)}
\PYG{g+go}{6753.636363636364}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{intake}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{ddof}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{1142.1232221373727}
\end{sphinxVerbatim}

Calculate the t statistic, setting the ddof parameter to the unbiased
value so the divisor in the standard deviation will be degrees of
freedom, N\sphinxhyphen{}1.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{intake}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7725}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{intake}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{ddof}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{intake}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{bins}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

For a one\sphinxhyphen{}sided t\sphinxhyphen{}test, how far out in the distribution does the t
statistic appear?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{s}\PYG{o}{\PYGZlt{}}\PYG{n}{t}\PYG{p}{)} \PYG{o}{/} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{0.0090699999999999999  \PYGZsh{}random}
\end{sphinxVerbatim}

So the p\sphinxhyphen{}value is about 0.009, which says the null hypothesis has a
probability of about 99\% of being true.

\end{fulllineitems}

\index{triangular() (in module infrapy.utils.ref2sac)@\spxentry{triangular()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.triangular}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{triangular}}}{\emph{left}, \emph{mode}, \emph{right}, \emph{size=None}}{}
Draw samples from the triangular distribution over the
interval \sphinxcode{\sphinxupquote{{[}left, right{]}}}.

The triangular distribution is a continuous probability
distribution with lower limit left, peak at mode, and upper
limit right. Unlike the other distributions, these parameters
directly define the shape of the pdf.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{triangular}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{left}] \leavevmode{[}float or array\_like of floats{]}
Lower limit.

\item[{mode}] \leavevmode{[}float or array\_like of floats{]}
The value where the peak of the distribution occurs.
The value must fulfill the condition \sphinxcode{\sphinxupquote{left \textless{}= mode \textless{}= right}}.

\item[{right}] \leavevmode{[}float or array\_like of floats{]}
Upper limit, must be larger than \sphinxtitleref{left}.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{left}}, \sphinxcode{\sphinxupquote{mode}}, and \sphinxcode{\sphinxupquote{right}}
are all scalars.  Otherwise, \sphinxcode{\sphinxupquote{np.broadcast(left, mode, right).size}}
samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized triangular distribution.

\end{description}

Generator.triangular: which should be used for new code.

The probability density function for the triangular distribution is
\begin{equation*}
\begin{split}P(x;l, m, r) = \begin{cases}
\frac{2(x-l)}{(r-l)(m-l)}& \text{for $l \leq x \leq m$},\\
\frac{2(r-x)}{(r-l)(r-m)}& \text{for $m \leq x \leq r$},\\
0& \text{otherwise}.
\end{cases}\end{split}
\end{equation*}
The triangular distribution is often used in ill\sphinxhyphen{}defined
problems where the underlying distribution is not known, but
some knowledge of the limits and mode exists. Often it is used
in simulations.

Draw values from the distribution and plot the histogram:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{triangular}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{100000}\PYG{p}{)}\PYG{p}{,} \PYG{n}{bins}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{,}
\PYG{g+gp}{... }             \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{uniform() (in module infrapy.utils.ref2sac)@\spxentry{uniform()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.uniform}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{uniform}}}{\emph{low=0.0}, \emph{high=1.0}, \emph{size=None}}{}
Draw samples from a uniform distribution.

Samples are uniformly distributed over the half\sphinxhyphen{}open interval
\sphinxcode{\sphinxupquote{{[}low, high)}} (includes low, but excludes high).  In other words,
any value within the given interval is equally likely to be drawn
by \sphinxtitleref{uniform}.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{uniform}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{low}] \leavevmode{[}float or array\_like of floats, optional{]}
Lower boundary of the output interval.  All values generated will be
greater than or equal to low.  The default value is 0.

\item[{high}] \leavevmode{[}float or array\_like of floats{]}
Upper boundary of the output interval.  All values generated will be
less than high.  The default value is 1.0.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{low}} and \sphinxcode{\sphinxupquote{high}} are both scalars.
Otherwise, \sphinxcode{\sphinxupquote{np.broadcast(low, high).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized uniform distribution.

\end{description}

randint : Discrete uniform distribution, yielding integers.
random\_integers : Discrete uniform distribution over the closed
\begin{quote}

interval \sphinxcode{\sphinxupquote{{[}low, high{]}}}.
\end{quote}

random\_sample : Floats uniformly distributed over \sphinxcode{\sphinxupquote{{[}0, 1)}}.
random : Alias for \sphinxtitleref{random\_sample}.
rand : Convenience function that accepts dimensions as input, e.g.,
\begin{quote}

\sphinxcode{\sphinxupquote{rand(2,2)}} would generate a 2\sphinxhyphen{}by\sphinxhyphen{}2 array of floats,
uniformly distributed over \sphinxcode{\sphinxupquote{{[}0, 1)}}.
\end{quote}

Generator.uniform: which should be used for new code.

The probability density function of the uniform distribution is
\begin{equation*}
\begin{split}p(x) = \frac{1}{b - a}\end{split}
\end{equation*}
anywhere within the interval \sphinxcode{\sphinxupquote{{[}a, b)}}, and zero elsewhere.

When \sphinxcode{\sphinxupquote{high}} == \sphinxcode{\sphinxupquote{low}}, values of \sphinxcode{\sphinxupquote{low}} will be returned.
If \sphinxcode{\sphinxupquote{high}} \textless{} \sphinxcode{\sphinxupquote{low}}, the results are officially undefined
and may eventually raise an error, i.e. do not rely on this
function to behave when passed arguments satisfying that
inequality condition.

Draw samples from the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{uniform}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{)}
\end{sphinxVerbatim}

All values are within the given interval:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{all}\PYG{p}{(}\PYG{n}{s} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{all}\PYG{p}{(}\PYG{n}{s} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{True}
\end{sphinxVerbatim}

Display the histogram of the samples, along with the
probability density function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{count}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignored} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones\PYGZus{}like}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{)}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{vonmises() (in module infrapy.utils.ref2sac)@\spxentry{vonmises()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.vonmises}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{vonmises}}}{\emph{mu}, \emph{kappa}, \emph{size=None}}{}
Draw samples from a von Mises distribution.

Samples are drawn from a von Mises distribution with specified mode
(mu) and dispersion (kappa), on the interval {[}\sphinxhyphen{}pi, pi{]}.

The von Mises distribution (also known as the circular normal
distribution) is a continuous probability distribution on the unit
circle.  It may be thought of as the circular analogue of the normal
distribution.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{vonmises}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{mu}] \leavevmode{[}float or array\_like of floats{]}
Mode (“center”) of the distribution.

\item[{kappa}] \leavevmode{[}float or array\_like of floats{]}
Dispersion of the distribution, has to be \textgreater{}=0.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{mu}} and \sphinxcode{\sphinxupquote{kappa}} are both scalars.
Otherwise, \sphinxcode{\sphinxupquote{np.broadcast(mu, kappa).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized von Mises distribution.

\end{description}
\begin{description}
\item[{scipy.stats.vonmises}] \leavevmode{[}probability density function, distribution, or{]}
cumulative density function, etc.

\end{description}

Generator.vonmises: which should be used for new code.

The probability density for the von Mises distribution is
\begin{equation*}
\begin{split}p(x) = \frac{e^{\kappa cos(x-\mu)}}{2\pi I_0(\kappa)},\end{split}
\end{equation*}
where \(\mu\) is the mode and \(\kappa\) the dispersion,
and \(I_0(\kappa)\) is the modified Bessel function of order 0.

The von Mises is named for Richard Edler von Mises, who was born in
Austria\sphinxhyphen{}Hungary, in what is now the Ukraine.  He fled to the United
States in 1939 and became a professor at Harvard.  He worked in
probability theory, aerodynamics, fluid mechanics, and philosophy of
science.

Draw samples from the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mu}\PYG{p}{,} \PYG{n}{kappa} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{4.0} \PYG{c+c1}{\PYGZsh{} mean and dispersion}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{vonmises}\PYG{p}{(}\PYG{n}{mu}\PYG{p}{,} \PYG{n}{kappa}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\end{sphinxVerbatim}

Display the histogram of the samples, along with
the probability density function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{special} \PYG{k+kn}{import} \PYG{n}{i0}  
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{num}\PYG{o}{=}\PYG{l+m+mi}{51}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{kappa}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{mu}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{n}{i0}\PYG{p}{(}\PYG{n}{kappa}\PYG{p}{)}\PYG{p}{)}  
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{wald() (in module infrapy.utils.ref2sac)@\spxentry{wald()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.wald}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{wald}}}{\emph{mean}, \emph{scale}, \emph{size=None}}{}
Draw samples from a Wald, or inverse Gaussian, distribution.

As the scale approaches infinity, the distribution becomes more like a
Gaussian. Some references claim that the Wald is an inverse Gaussian
with mean equal to 1, but this is by no means universal.

The inverse Gaussian distribution was first studied in relationship to
Brownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian
because there is an inverse relationship between the time to cover a
unit distance and distance covered in unit time.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{wald}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{mean}] \leavevmode{[}float or array\_like of floats{]}
Distribution mean, must be \textgreater{} 0.

\item[{scale}] \leavevmode{[}float or array\_like of floats{]}
Scale parameter, must be \textgreater{} 0.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{mean}} and \sphinxcode{\sphinxupquote{scale}} are both scalars.
Otherwise, \sphinxcode{\sphinxupquote{np.broadcast(mean, scale).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized Wald distribution.

\end{description}

Generator.wald: which should be used for new code.

The probability density function for the Wald distribution is
\begin{equation*}
\begin{split}P(x;mean,scale) = \sqrt{\frac{scale}{2\pi x^3}}e^
\frac{-scale(x-mean)^2}{2\cdotp mean^2x}\end{split}
\end{equation*}
As noted above the inverse Gaussian distribution first arise
from attempts to model Brownian motion. It is also a
competitor to the Weibull for use in reliability modeling and
modeling stock returns and interest rate processes.

Draw values from the distribution and plot the histogram:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{wald}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{100000}\PYG{p}{)}\PYG{p}{,} \PYG{n}{bins}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{weibull() (in module infrapy.utils.ref2sac)@\spxentry{weibull()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.weibull}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{weibull}}}{\emph{a}, \emph{size=None}}{}
Draw samples from a Weibull distribution.

Draw samples from a 1\sphinxhyphen{}parameter Weibull distribution with the given
shape parameter \sphinxtitleref{a}.
\begin{equation*}
\begin{split}X = (-ln(U))^{1/a}\end{split}
\end{equation*}
Here, U is drawn from the uniform distribution over (0,1{]}.

The more common 2\sphinxhyphen{}parameter Weibull, including a scale parameter
\(\lambda\) is just \(X = \lambda(-ln(U))^{1/a}\).

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{weibull}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{a}] \leavevmode{[}float or array\_like of floats{]}
Shape parameter of the distribution.  Must be nonnegative.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{a}} is a scalar.  Otherwise,
\sphinxcode{\sphinxupquote{np.array(a).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized Weibull distribution.

\end{description}

scipy.stats.weibull\_max
scipy.stats.weibull\_min
scipy.stats.genextreme
gumbel
Generator.weibull: which should be used for new code.

The Weibull (or Type III asymptotic extreme value distribution
for smallest values, SEV Type III, or Rosin\sphinxhyphen{}Rammler
distribution) is one of a class of Generalized Extreme Value
(GEV) distributions used in modeling extreme value problems.
This class includes the Gumbel and Frechet distributions.

The probability density for the Weibull distribution is
\begin{equation*}
\begin{split}p(x) = \frac{a}
{\lambda}(\frac{x}{\lambda})^{a-1}e^{-(x/\lambda)^a},\end{split}
\end{equation*}
where \(a\) is the shape and \(\lambda\) the scale.

The function has its peak (the mode) at
\(\lambda(\frac{a-1}{a})^{1/a}\).

When \sphinxcode{\sphinxupquote{a = 1}}, the Weibull distribution reduces to the exponential
distribution.

Draw samples from the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{5.} \PYG{c+c1}{\PYGZsh{} shape}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{weibull}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\end{sphinxVerbatim}

Display the histogram of the samples, along with
the probability density function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mf}{100.}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{50.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{weib}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{n}\PYG{p}{,}\PYG{n}{a}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{p}{(}\PYG{n}{a} \PYG{o}{/} \PYG{n}{n}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{x} \PYG{o}{/} \PYG{n}{n}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{x} \PYG{o}{/} \PYG{n}{n}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{count}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignored} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{weibull}\PYG{p}{(}\PYG{l+m+mf}{5.}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mf}{100.}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{50.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{scale} \PYG{o}{=} \PYG{n}{count}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{o}{/}\PYG{n}{weib}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{5.}\PYG{p}{)}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{weib}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{5.}\PYG{p}{)}\PYG{o}{*}\PYG{n}{scale}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{zipf() (in module infrapy.utils.ref2sac)@\spxentry{zipf()}\spxextra{in module infrapy.utils.ref2sac}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.ref2sac.zipf}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.ref2sac.}}\sphinxbfcode{\sphinxupquote{zipf}}}{\emph{a}, \emph{size=None}}{}
Draw samples from a Zipf distribution.

Samples are drawn from a Zipf distribution with specified parameter
\sphinxtitleref{a} \textgreater{} 1.

The Zipf distribution (also known as the zeta distribution) is a
continuous probability distribution that satisfies Zipf’s law: the
frequency of an item is inversely proportional to its rank in a
frequency table.

\begin{sphinxadmonition}{note}{Note:}
New code should use the \sphinxcode{\sphinxupquote{zipf}} method of a \sphinxcode{\sphinxupquote{default\_rng()}}
instance instead; see \sphinxtitleref{random\sphinxhyphen{}quick\sphinxhyphen{}start}.
\end{sphinxadmonition}
\begin{description}
\item[{a}] \leavevmode{[}float or array\_like of floats{]}
Distribution parameter. Must be greater than 1.

\item[{size}] \leavevmode{[}int or tuple of ints, optional{]}
Output shape.  If the given shape is, e.g., \sphinxcode{\sphinxupquote{(m, n, k)}}, then
\sphinxcode{\sphinxupquote{m * n * k}} samples are drawn.  If size is \sphinxcode{\sphinxupquote{None}} (default),
a single value is returned if \sphinxcode{\sphinxupquote{a}} is a scalar. Otherwise,
\sphinxcode{\sphinxupquote{np.array(a).size}} samples are drawn.

\end{description}
\begin{description}
\item[{out}] \leavevmode{[}ndarray or scalar{]}
Drawn samples from the parameterized Zipf distribution.

\end{description}
\begin{description}
\item[{scipy.stats.zipf}] \leavevmode{[}probability density function, distribution, or{]}
cumulative density function, etc.

\end{description}

Generator.zipf: which should be used for new code.

The probability density for the Zipf distribution is
\begin{equation*}
\begin{split}p(x) = \frac{x^{-a}}{\zeta(a)},\end{split}
\end{equation*}
where \(\zeta\) is the Riemann Zeta function.

It is named for the American linguist George Kingsley Zipf, who noted
that the frequency of any word in a sample of a language is inversely
proportional to its rank in the frequency table.

Draw samples from the distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{2.} \PYG{c+c1}{\PYGZsh{} parameter}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{zipf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\end{sphinxVerbatim}

Display the histogram of the samples, along with
the probability density function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{scipy} \PYG{k+kn}{import} \PYG{n}{special}  
\end{sphinxVerbatim}

Truncate s values at 50 so plot is interesting:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{count}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignored} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{s}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{50}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{50.}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y} \PYG{o}{=} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{)} \PYG{o}{/} \PYG{n}{special}\PYG{o}{.}\PYG{n}{zetac}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}  
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{o}{/}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsubsection{infrapy.utils.sac\_stats module}
\label{\detokenize{infrapy.utils:module-infrapy.utils.sac_stats}}\label{\detokenize{infrapy.utils:infrapy-utils-sac-stats-module}}\index{infrapy.utils.sac\_stats (module)@\spxentry{infrapy.utils.sac\_stats}\spxextra{module}}

\subsubsection{infrapy.utils.seed2sac module}
\label{\detokenize{infrapy.utils:module-infrapy.utils.seed2sac}}\label{\detokenize{infrapy.utils:infrapy-utils-seed2sac-module}}\index{infrapy.utils.seed2sac (module)@\spxentry{infrapy.utils.seed2sac}\spxextra{module}}

\subsubsection{infrapy.utils.short\_time module}
\label{\detokenize{infrapy.utils:module-infrapy.utils.short_time}}\label{\detokenize{infrapy.utils:infrapy-utils-short-time-module}}\index{infrapy.utils.short\_time (module)@\spxentry{infrapy.utils.short\_time}\spxextra{module}}\index{short\_time() (in module infrapy.utils.short\_time)@\spxentry{short\_time()}\spxextra{in module infrapy.utils.short\_time}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.short_time.short_time}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.short\_time.}}\sphinxbfcode{\sphinxupquote{short\_time}}}{\emph{timeSTR}}{}
\end{fulllineitems}



\subsubsection{infrapy.utils.skew\_norm module}
\label{\detokenize{infrapy.utils:module-infrapy.utils.skew_norm}}\label{\detokenize{infrapy.utils:infrapy-utils-skew-norm-module}}\index{infrapy.utils.skew\_norm (module)@\spxentry{infrapy.utils.skew\_norm}\spxextra{module}}\index{pdf() (in module infrapy.utils.skew\_norm)@\spxentry{pdf()}\spxextra{in module infrapy.utils.skew\_norm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.skew_norm.pdf}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.skew\_norm.}}\sphinxbfcode{\sphinxupquote{pdf}}}{\emph{x}, \emph{x0=0.0}, \emph{sigma=1.0}, \emph{alpha=0.0}}{}
\end{fulllineitems}

\index{pdf\_2comp() (in module infrapy.utils.skew\_norm)@\spxentry{pdf\_2comp()}\spxextra{in module infrapy.utils.skew\_norm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.skew_norm.pdf_2comp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.skew\_norm.}}\sphinxbfcode{\sphinxupquote{pdf\_2comp}}}{\emph{x}, \emph{x1}, \emph{s1}, \emph{a1}, \emph{x2}, \emph{s2}, \emph{a2}, \emph{w}}{}
\end{fulllineitems}

\index{pdf\_3comp() (in module infrapy.utils.skew\_norm)@\spxentry{pdf\_3comp()}\spxextra{in module infrapy.utils.skew\_norm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{infrapy.utils:infrapy.utils.skew_norm.pdf_3comp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{infrapy.utils.skew\_norm.}}\sphinxbfcode{\sphinxupquote{pdf\_3comp}}}{\emph{x}, \emph{x1}, \emph{s1}, \emph{a1}, \emph{w1}, \emph{x2}, \emph{s2}, \emph{a2}, \emph{w2}, \emph{x3}, \emph{s3}, \emph{a3}, \emph{w3}}{}
\end{fulllineitems}



\subsubsection{infrapy.utils.zip2ref module}
\label{\detokenize{infrapy.utils:infrapy-utils-zip2ref-module}}

\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{i}
\item\relax\sphinxstyleindexentry{infrapy}\sphinxstyleindexpageref{index:\detokenize{module-infrapy}}
\item\relax\sphinxstyleindexentry{infrapy.association}\sphinxstyleindexpageref{infrapy.association:\detokenize{module-infrapy.association}}
\item\relax\sphinxstyleindexentry{infrapy.association.hjl}\sphinxstyleindexpageref{infrapy.association:\detokenize{module-infrapy.association.hjl}}
\item\relax\sphinxstyleindexentry{infrapy.characterization.spye}\sphinxstyleindexpageref{infrapy.characterization:\detokenize{module-infrapy.characterization.spye}}
\item\relax\sphinxstyleindexentry{infrapy.database}\sphinxstyleindexpageref{infrapy.database:\detokenize{module-infrapy.database}}
\item\relax\sphinxstyleindexentry{infrapy.database.schema}\sphinxstyleindexpageref{infrapy.database:\detokenize{module-infrapy.database.schema}}
\item\relax\sphinxstyleindexentry{infrapy.database.taskbase.assoc}\sphinxstyleindexpageref{infrapy.database.taskbase:\detokenize{module-infrapy.database.taskbase.assoc}}
\item\relax\sphinxstyleindexentry{infrapy.database.taskbase.fdet}\sphinxstyleindexpageref{infrapy.database.taskbase:\detokenize{module-infrapy.database.taskbase.fdet}}
\item\relax\sphinxstyleindexentry{infrapy.database.taskbase.loc}\sphinxstyleindexpageref{infrapy.database.taskbase:\detokenize{module-infrapy.database.taskbase.loc}}
\item\relax\sphinxstyleindexentry{infrapy.detection.beamforming}\sphinxstyleindexpageref{infrapy.detection:\detokenize{module-infrapy.detection.beamforming}}
\item\relax\sphinxstyleindexentry{infrapy.detection.beamforming\_new}\sphinxstyleindexpageref{infrapy.detection:\detokenize{module-infrapy.detection.beamforming_new}}
\item\relax\sphinxstyleindexentry{infrapy.location.bisl}\sphinxstyleindexpageref{infrapy.location:\detokenize{module-infrapy.location.bisl}}
\item\relax\sphinxstyleindexentry{infrapy.propagation.infrasound}\sphinxstyleindexpageref{infrapy.propagation:\detokenize{module-infrapy.propagation.infrasound}}
\item\relax\sphinxstyleindexentry{infrapy.propagation.likelihoods}\sphinxstyleindexpageref{infrapy.propagation:\detokenize{module-infrapy.propagation.likelihoods}}
\item\relax\sphinxstyleindexentry{infrapy.propagation.seismic}\sphinxstyleindexpageref{infrapy.propagation:\detokenize{module-infrapy.propagation.seismic}}
\item\relax\sphinxstyleindexentry{infrapy.utils}\sphinxstyleindexpageref{infrapy.utils:\detokenize{module-infrapy.utils}}
\item\relax\sphinxstyleindexentry{infrapy.utils.cart2pol}\sphinxstyleindexpageref{infrapy.utils:\detokenize{module-infrapy.utils.cart2pol}}
\item\relax\sphinxstyleindexentry{infrapy.utils.confidence}\sphinxstyleindexpageref{infrapy.utils:\detokenize{module-infrapy.utils.confidence}}
\item\relax\sphinxstyleindexentry{infrapy.utils.db2db}\sphinxstyleindexpageref{infrapy.utils:\detokenize{module-infrapy.utils.db2db}}
\item\relax\sphinxstyleindexentry{infrapy.utils.db2sac}\sphinxstyleindexpageref{infrapy.utils:\detokenize{module-infrapy.utils.db2sac}}
\item\relax\sphinxstyleindexentry{infrapy.utils.files2db}\sphinxstyleindexpageref{infrapy.utils:\detokenize{module-infrapy.utils.files2db}}
\item\relax\sphinxstyleindexentry{infrapy.utils.get\_arraywaveforms}\sphinxstyleindexpageref{infrapy.utils:\detokenize{module-infrapy.utils.get_arraywaveforms}}
\item\relax\sphinxstyleindexentry{infrapy.utils.get\_header\_table}\sphinxstyleindexpageref{infrapy.utils:\detokenize{module-infrapy.utils.get_header_table}}
\item\relax\sphinxstyleindexentry{infrapy.utils.get\_mean\_locations}\sphinxstyleindexpageref{infrapy.utils:\detokenize{module-infrapy.utils.get_mean_locations}}
\item\relax\sphinxstyleindexentry{infrapy.utils.latlon}\sphinxstyleindexpageref{infrapy.utils:\detokenize{module-infrapy.utils.latlon}}
\item\relax\sphinxstyleindexentry{infrapy.utils.ms2db}\sphinxstyleindexpageref{infrapy.utils:\detokenize{module-infrapy.utils.ms2db}}
\item\relax\sphinxstyleindexentry{infrapy.utils.obspy\_conversion}\sphinxstyleindexpageref{infrapy.utils:\detokenize{module-infrapy.utils.obspy_conversion}}
\item\relax\sphinxstyleindexentry{infrapy.utils.prog\_bar}\sphinxstyleindexpageref{infrapy.utils:\detokenize{module-infrapy.utils.prog_bar}}
\item\relax\sphinxstyleindexentry{infrapy.utils.ref2sac}\sphinxstyleindexpageref{infrapy.utils:\detokenize{module-infrapy.utils.ref2sac}}
\item\relax\sphinxstyleindexentry{infrapy.utils.sac\_stats}\sphinxstyleindexpageref{infrapy.utils:\detokenize{module-infrapy.utils.sac_stats}}
\item\relax\sphinxstyleindexentry{infrapy.utils.seed2sac}\sphinxstyleindexpageref{infrapy.utils:\detokenize{module-infrapy.utils.seed2sac}}
\item\relax\sphinxstyleindexentry{infrapy.utils.short\_time}\sphinxstyleindexpageref{infrapy.utils:\detokenize{module-infrapy.utils.short_time}}
\item\relax\sphinxstyleindexentry{infrapy.utils.skew\_norm}\sphinxstyleindexpageref{infrapy.utils:\detokenize{module-infrapy.utils.skew_norm}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}