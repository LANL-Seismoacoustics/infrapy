<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quickstart &mdash; Infrapy 1.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="InfraView" href="infraview.html" />
    <link rel="prev" title="Installation" href="installation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Infrapy
            <img src="_static/lanl_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="userguide.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="authorship.html">Authorship</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="infraview.html">InfraView</a></li>
<li class="toctree-l1"><a class="reference internal" href="pisces.html">Database Interfacing</a></li>
<li class="toctree-l1"><a class="reference internal" href="utilities.html">Utility Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="algorithms.html">Algorithms</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Infrapy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Quickstart</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/quickstart.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="quickstart">
<span id="id1"></span><h1>Quickstart<a class="headerlink" href="#quickstart" title="Permalink to this headline"></a></h1>
<section id="command-line-interface-cli">
<h2>Command Line Interface (CLI)<a class="headerlink" href="#command-line-interface-cli" title="Permalink to this headline"></a></h2>
<p>Most of InfraPy’s analysis methods are accessible through a command line interface (CLI) with parameters specified either via command line flags or a configuration file.  Waveform data can be ingested from local files (eg., SAC or similar format that can be ingested via <code class="code docutils literal notranslate"><span class="pre">obspy.core.read</span></code>) or downloaded from FDSN clients via <code class="code docutils literal notranslate"><span class="pre">obspy.clients.fdsn</span></code>.  Array- and network-level analyses can be performed from the command line enabling a full pipeline of analysis from beamforming/detection to event identification and localization.  Visualization methods are also included to quickly interrogate analysis results.  The Quickstart summarized here steps through these various CLI methods and demonstrates the usage of InfraPy from the command line.</p>
<section id="array-level-analyses">
<h3>Array-Level Analyses<a class="headerlink" href="#array-level-analyses" title="Permalink to this headline"></a></h3>
<ul>
<li><p>The beamforming methods in InfraPy can be run via the <code class="code docutils literal notranslate"><span class="pre">run_fk</span></code> CLI option.  For a local data source such as the included SAC files in the data directory, this is simply,</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>infrapy run_fk --local-wvfrms <span class="s1">&#39;data/YJ.BRP*.SAC&#39;</span>
</pre></div>
</div>
<p>Note that the data path must be in quotes in order to properly parsed and that this Quickstart assumes you are in the infrapy/examples directory (if you are getting an error that the waveform data isn’t found, make sure you’re in the correct directory).  As the methods are run, data and algorithm parameters are summarized and a progress bar shows how much of the data has been analyzed:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#####################################
##                                 ##
##             InfraPy             ##
##    Beamforming (fk) Analysis    ##
##                                 ##
#####################################

Data parameters:
  local_wvfrms: data/YJ.BRP*.SAC
  local_latlon: None
  local_fk_label: None

Algorithm parameters:
  freq_min: 0.5
  freq_max: 5.0
  back_az_min: -180.0
  back_az_max: 180.0
  back_az_step: 2.0
  trace_vel_min: 300.0
  trace_vel_max: 600.0
  trace_vel_step: 2.5
  method: bartlett
  signal_start: None
  signal_end: None
  window_len: 10.0
  sub_window_len: None
  window_step: 5.0

Loading local data from data/YJ.BRP*.SAC

Data summary:
YJ.BRP1..EDF    2012-04-09T18:00:00.008300Z - 2012-04-09T18:19:59.998300Z
YJ.BRP2..EDF    2012-04-09T18:00:00.008300Z - 2012-04-09T18:19:59.998300Z
YJ.BRP3..EDF    2012-04-09T18:00:00.008300Z - 2012-04-09T18:19:59.998300Z
YJ.BRP4..EDF    2012-04-09T18:00:00.008300Z - 2012-04-09T18:19:59.998300Z

Running fk analysis...
        Progress: [&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;]

Writing results into data/YJ.BRP_2012.04.09_18.00.00-18.19.59.fk_results.dat
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>Once completed, this analysis produces an output file containing the beamforming results, <code class="code docutils literal notranslate"><span class="pre">data/YJ.BRP_2012.04.09_18.00.00-18.19.59.fk_results.dat</span></code>, that has header information summarizing the analysis parameter settings.</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span># InfraPy Beamforming (fk) Results
#
# Data summary:
#     YJ.BRP1..EDF      2012-04-09T18:00:00.008300Z - 2012-04-09T18:19:59.998300Z
#     YJ.BRP2..EDF      2012-04-09T18:00:00.008300Z - 2012-04-09T18:19:59.998300Z
#     YJ.BRP3..EDF      2012-04-09T18:00:00.008300Z - 2012-04-09T18:19:59.998300Z
#     YJ.BRP4..EDF      2012-04-09T18:00:00.008300Z - 2012-04-09T18:19:59.998300Z
#
#   channel_cnt: 4
#   t0: 2012-04-09T18:00:00.008300Z
#   latitude: 39.4727
#   longitude: -110.741
#
# Algorithm parameters:
#   freq_min: 0.5
#   freq_max: 5.0
#   back_az_min: -180.0
#   back_az_max: 180.0
#   back_az_step: 2.0
#   trace_vel_min: 300.0
#   trace_vel_max: 600.0
#   trace_vel_step: 2.5
#   method: bartlett
#   signal_start: None
#   signal_end: None
#   window_len: 10.0
#   sub_window_len: None
#   window_step: 5.0
#
# Time (rel t0) [s]      Back Az [deg]             Tr. Velocity [m/s]       F-stat
5.000000000000000000e+00 -1.387287391860265870e+02 2.993126218419760676e+02 1.787104441793843090e+00
1.000000000000000000e+01 -1.023142582570893637e+02 5.004422637641642382e+02 1.432896340216525566e+00
1.500000000000000000e+01 1.262012941070060066e+02 2.993477387779522587e+02 1.628381775483823013e+00
2.000000000000000000e+01 -6.640044354652907543e+01 3.443074961913744119e+02 2.057173196304753926e+00
2.500000000000000000e+01 -3.284497729652116504e+01 3.857456350755477388e+02 2.461603800702443223e+00
...
</pre></div>
</div>
<p>The naming convention of the output file uses the network, station, and time associated with the waveform data, but can be overwritten via the <code class="code docutils literal notranslate"><span class="pre">--local-fk-label</span></code> parameter.</p>
</div></blockquote>
</li>
<li><p>The beamforming results from the <code class="code docutils literal notranslate"><span class="pre">infrapy</span> <span class="pre">run_fk</span></code> analysis can be visualized using the <code class="code docutils literal notranslate"><span class="pre">fk</span></code> option in <code class="code docutils literal notranslate"><span class="pre">infrapy</span> <span class="pre">plot</span></code>:</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>infrapy plot fk --local-wvfrms <span class="s1">&#39;data/YJ.BRP*.SAC&#39;</span>
</pre></div>
</div>
<p>The resulting plot of the included example data set is shown below for comparison:</p>
<a class="reference internal image-reference" href="_images/plot_fk.png"><img alt="_images/plot_fk.png" class="align-center" src="_images/plot_fk.png" style="width: 1200px;" /></a>
<p>The default behavior of the plotting methods in InfraPy are to generate a <code class="code docutils literal notranslate"><span class="pre">matplotlib</span></code> window and print the image to screen.  This can be overwritten by specifying an output file and turning the print to screen off:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>infrapy plot fk --local-wvfrms <span class="s1">&#39;data/YJ.BRP*.SAC&#39;</span> --figure-out <span class="s2">&quot;fk_result.png&quot;</span> --show-figure <span class="nb">false</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>The default beamforming parameters in <code class="code docutils literal notranslate"><span class="pre">run_fk</span></code> are useful, but in many cases the frequency band for a signal of interest or the window length appropriate for a given frequency band needs to be modified.  From the command line, this can be done by specifying a number of options in the algorithm as summarized in the <code class="code docutils literal notranslate"><span class="pre">--help</span></code> information.  For example, the analysis of data from BRP can be completed using a modified frequency band via:</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>infrapy run_fk --local-wvfrms <span class="s1">&#39;data/YJ.BRP*.SAC&#39;</span> --freq-min <span class="m">1</span>.0 --freq-max <span class="m">8</span>.0
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>In the case that multiple analysis parameters are changed from their default values, a configuration file is useful to simplify running analysis and keep a record of what was used for future review of analysis.  Within the <code class="code docutils literal notranslate"><span class="pre">examples/config</span></code> directory are several example configuration files.  The <code class="code docutils literal notranslate"><span class="pre">detection_local.config</span></code> file has a configuration to run detection (fk and fd) analysis on local waveform data:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[WAVEFORM IO]
local_wvfrms = data/YJ.BRP*.SAC

[DETECTION IO]
local_fk_label = auto
local_detect_label = auto

[FK]
freq_min = 1.0
freq_max = 5.0
window_len = 10.0
window_step = 5.0

[FD]
p_value = 0.05
min_duration = 20.0
</pre></div>
</div>
<p>Note that the parameter specifications use underscores in the config file and hyphens in the command line flags (e.g., <code class="code docutils literal notranslate"><span class="pre">--local-fk-label`</span></code> vs. <code class="code docutils literal notranslate"><span class="pre">local_fk_label`</span></code>).  The analysis can now be completed by simply running:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>infrapy run_fk --config-file config/detection_local.config
</pre></div>
</div>
<p>The analysis steps are the same as the above; however, you’ll notice that when the fk results are being written there’s a warning message that existing results are present so that a new file name is used.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#####################################
##                                 ##
##             InfraPy             ##
##    Beamforming (fk) Analysis    ##
##                                 ##
#####################################

Data parameters:
  local_wvfrms: data/YJ.BRP*.SAC
  local_latlon: None
  local_fk_label: None

...

Running fk analysis...
        Progress: [&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;]

WARNING!  fk results file(s) already exist.
Writing a new version: data/YJ.BRP_2012.04.09_18.00.00-18.19.59-v0.fk_results.dat
</pre></div>
</div>
<p>This is to avoid overwriting existing results from previous runs and to make comparisons of varied frequeny bands, window lengths, and other parameters more efficient.  The visualization methods can be pointed to any fk results file as:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>infrapy plot fk --config-file config/detection_local.config --local-fk-label data/YJ.BRP_2012.04.09_18.00.00-18.19.59-v0
</pre></div>
</div>
<p>When using a config file for analysis, any additional parameters set on the command line will overwrite the values from the config file.  For example, to run the analysis with a maximum frequency of 10 Hz instead of 5 Hz, one can simply run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>infrapy run_fk --config-file BRP_analysis.config --freq-max <span class="m">10</span>
</pre></div>
</div>
<p>If a parameter is not included in a config file or via the command line, a default value is used and can be found in the output at the time of the analysis or in the output file header.</p>
<p>Lastly, large analysis runs can be accelerated by specifying a number of CPUs to utilize in analysis via <code class="code docutils literal notranslate"><span class="pre">--cpu-cnt</span></code>.  Multi-threading in InfraPy beamforming analysis is done by distributing individual analysis windows among available threads.   On a desktop OS X machine used for testing, a single-CPU analysis of the included BRP data requires approximately 32 seconds.  With 4 CPUs this is reduced to 14 seconds and with 10 CPUs it reduces further to approximately 10 seconds.  The limited gains for higher CPUs is due to a amount of time needed to perform background tasks such as reading and writing data that is not multi-threaded.  It should be noted that the BRP example data set includes only 20 minutes of waveform data and that longer data sets would likely benefit from higher numbers of CPUs before these background task times become notable.</p>
</div></blockquote>
</li>
<li><p>From the beamforming results, detection analysis can be conducted via the <code class="code docutils literal notranslate"><span class="pre">run_fd</span></code> method.  This analysis requires the fk output label and can use a custom detection label or automatically re-use the fk label if none is specified.</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>infrapy run_fd --config-file config/detection_local.config
</pre></div>
</div>
<p>Similarly to the <code class="code docutils literal notranslate"><span class="pre">run_fk</span></code> methods, parameter summaries are provided; however, because this analysis is relatively quick there is no progress bar:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#####################################
##                                 ##
##             InfraPy             ##
##     Detection (fd) Analysis     ##
##                                 ##
#####################################

Data parameters:
  local_fk_label: data/YJ.BRP_2012.04.09_18.00.00-18.19.59
  local_detect_label: data/YJ.BRP_2012.04.09_18.00.00-18.19.59

Algorithm parameters:
  window_len: 3600.0
  p_value: 0.05
  min_duration: 20.0
  back_az_width: 15.0
  fixed_thresh: None
  thresh_ceil: None
  return_thresh: False
  merge_dets: False

Running fd...
Writing detections to data/YJ.BRP_2012.04.09_18.00.00-18.19.59.dets.json
</pre></div>
</div>
<p>As noted in the output, a new file named <code class="code docutils literal notranslate"><span class="pre">YJ.BRP_2012.04.09_18.00.00-18.19.59.dets.json</span></code> is created containing all of the detections identified in the fk results.  This file contains the information summarizing each detection in a format that can be ingested for further CLI analysis and can also be loaded into the <a class="reference internal" href="infraview.html#infraview"><span class="std std-ref">InfraView</span></a> GUI.  The first detection from this analysis of the included BRP data is shown below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[
    {
        &quot;Name&quot;: &quot;&quot;,
        &quot;Time (UTC)&quot;: &quot;2012-04-09T18:07:05.008300&quot;,
        &quot;F Stat.&quot;: 31.9058,
        &quot;Trace Vel. (m/s)&quot;: 370.97,
        &quot;Back Azimuth&quot;: -41.84,
        &quot;Latitude&quot;: 39.4727,
        &quot;Longitude&quot;: -110.741,
        &quot;Elevation (m)&quot;: null,
        &quot;Start&quot;: 0.0,
        &quot;End&quot;: 5.0,
        &quot;Freq Range&quot;: [
            1.0,
            5.0
        ],
        &quot;Array Dim.&quot;: 4,
        &quot;Method&quot;: &quot;bartlett&quot;,
        &quot;Event&quot;: &quot;&quot;,
        &quot;Note&quot;: &quot;InfraPy CLI detection&quot;,
        &quot;Network&quot;: &quot;YJ&quot;,
        &quot;Station&quot;: &quot;BRP&quot;,
        &quot;Channel&quot;: &quot;EDF&quot;
    },...
]
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>Once detections are identified in the data record, they can be visualized similarly to the <code class="code docutils literal notranslate"><span class="pre">plot</span> <span class="pre">fk</span></code> option via <code class="code docutils literal notranslate"><span class="pre">plot</span> <span class="pre">fd</span></code>.</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>infrapy plot fd --config-file config/detection_local.config
</pre></div>
</div>
<p>This plot has the same format as the above <code class="code docutils literal notranslate"><span class="pre">plot</span> <span class="pre">fk</span></code> output, but now includes shaded boxes denoting where detections were identified in the analysis.  The frequency values specified here are applied as a bandpass filter on the waveform data in the visualization.</p>
<a class="reference internal image-reference" href="_images/plot_fd.png"><img alt="_images/plot_fd.png" class="align-center" src="_images/plot_fd.png" style="width: 1200px;" /></a>
</div></blockquote>
</li>
<li><p>One useful feature of the detections methods in InfraPy is the ability to merge detections.  By setting <code class="code docutils literal notranslate"><span class="pre">--merge-dets</span> <span class="pre">True</span></code> on the command line or <code class="code docutils literal notranslate"><span class="pre">merge_dets</span> <span class="pre">=</span> <span class="pre">True</span></code> in the configuration file, any pair of detections that are separated by less than the larger of their durations and have back azimuth differences less than the specified threshold will be combined.  Re-running the detection analysis with this option turn on and comparing the results:</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>infrapy run_fd --config-file config/detection_local.config --local-fk-label data/YJ.BRP_2012.04.09_18.00.00-18.19.59 --merge-dets True

infrapy plot fd --config-file config/detection_local.config
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/plot_fd2.png"><img alt="_images/plot_fd2.png" class="align-center" src="_images/plot_fd2.png" style="width: 1200px;" /></a>
</div></blockquote>
</li>
<li><p>In some cases, the parameters in the detection analysis are modified without changing the beamforming configuration and the <code class="code docutils literal notranslate"><span class="pre">run_fd</span></code> is useful in such scenarios to avoid repeatedly running the fk analysis.  However, most of the time, the beamforming and detection analysis are run together.  This can be accomplished in the InfraPy CLI via the <code class="code docutils literal notranslate"><span class="pre">run_fkd</span></code> option.</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>infrapy run_fkd --config-file config/detection_local.config
</pre></div>
</div>
<p>This option essentially combines the <code class="code docutils literal notranslate"><span class="pre">run_fk</span></code> and <code class="code docutils literal notranslate"><span class="pre">run_fd</span></code> options into a single analysis run.</p>
</div></blockquote>
</li>
<li><p>In addition to analysis of local data, InfraPy’s use of <code class="code docutils literal notranslate"><span class="pre">obspy.clients.fdsn</span></code> methods enables analysis of data available on IRIS and similar FDSNs.  Instead of specifying local waveform files, this requires defining the FDSN (e.g., IRIS, USGS) as well as the network, station, channel, and location information of the array.  Lastly, the start and end time are also needed to identify the segment of data to download for analysis.  This information can be entered on the command line, but it’s easier to simply write up a config file in most cases (recall that individual parameters can be overwritten on the command line, so the station or start/end times can be modified as needed).  An example analysis from the IMS I53US array is included in <code class="code docutils literal notranslate"><span class="pre">examples/config/detection_fdsn.config</span></code>:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[WAVEFORM IO]
fdsn = IRIS
network = IM
station = I53*
location = *
channel = *DF
starttime = 2018-12-19T01:00:00
endtime = 2018-12-19T03:00:00

[DETECTION IO]
local_fk_label = auto
local_detect_label = auto
</pre></div>
</div>
<p>Running this analysis will pull 2 hours of data from the International Monitoring System (IMS) I53US infrasound station from December 19th, 2018 that includes a signal produced by a bolide.  Visualization can be slightly slower as the data is re-downloaded from IRIS with each use of the command line calls.  This can be avoided using the <code class="code docutils literal notranslate"><span class="pre">write-wvfrms</span></code> <a class="reference internal" href="utilities.html#utilities"><span class="std std-ref">Utility Functions</span></a> function.  Due to the emergent nature of the signal, <code class="code docutils literal notranslate"><span class="pre">--merge-dets</span></code> needs to be activated to obtain a useful result as seen below.</p>
<a class="reference internal image-reference" href="_images/plot_fd-fdsn.png"><img alt="_images/plot_fd-fdsn.png" class="align-center" src="_images/plot_fd-fdsn.png" style="width: 1200px;" /></a>
<p>Although not currently accessible in the CLI methods, an FDSN station browser is available in the <a class="reference internal" href="infraview.html#infraview"><span class="std std-ref">InfraView</span></a> GUI to search for available data given a reference location, radius, and time bounds.</p>
</div></blockquote>
</li>
<li><p>Analysis of data from a local database is also available through the InfraPy CLI using the Python pisces library, and is covered in a separate tutorial on <a class="reference internal" href="pisces.html#pisces"><span class="std std-ref">Database Interfacing</span></a>.</p></li>
</ul>
</section>
<section id="network-level-analyses">
<h3>Network-Level Analyses<a class="headerlink" href="#network-level-analyses" title="Permalink to this headline"></a></h3>
<ul>
<li><p>Once fk and fd analysis are run and detections are identified across a network of infrasound arrays, event identification and localization can be completed.  The detection set used in the Blom et al. (2020) evaluation of a pair-based, joint-likelihood association algorithm are included as an example to demonstrate these analysis steps.  Detection files are in the examples/data/Blom_etal_2020/ directory and contain detections on each of 4 regional array in the western US (see the manuscript for a full discussion of the generation of this synthetic data set).  Analysis of these detections and identification of events can be completed by running:</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>infrapy run_assoc --local-detect-label <span class="s1">&#39;data/Blom_etal2020_GJI/*&#39;</span> --local-event-label GJI_example --cpu-cnt <span class="m">4</span>
</pre></div>
</div>
<p>Note that once again quotes are needed to define multiple files for ingestion.  This analysis can be on the slow side, so it’s recommended to add on a <code class="code docutils literal notranslate"><span class="pre">--cpu-cnt</span></code> option and multithread the computation of the joint-likelihood values.  For this analysis, multi-threading distributes the individual joint-likelihood calculations between pairs of detections to available threads.  The analysis results will be summarized to the screen,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#####################################
##                                 ##
##             InfraPy             ##
##       Association Analysis      ##
##                                 ##
#####################################

Data summary:
  local_detect_label: data/Blom_etal2020_GJI/*
  local_event_label: example
  starttime: None
  endtime: None

Parameter summary:
  back_az_width: 10.0
  range_max: 2000.0
  resolution: 180
  distance_matrix_max: 8.0
  cluster_linkage: weighted
  cluster_threshold: 5.0
  trimming_threshold: 3.8

Loading detections from files:
        data/Blom_etal2020_GJI/NVIAR.dets.json
        data/Blom_etal2020_GJI/I57US.dets.json
        data/Blom_etal2020_GJI/DLIAR.dets.json
        data/Blom_etal2020_GJI/PDIAR.dets.json

Running event identification for: 2010-01-01T09:35:59.773Z - 2010-01-01T13:23:14.773Z
        Computing joint-likelihoods...
                Progress:       [&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;]
        Clustering detections into events...
        Trimming poor linkages and repeating clustering analysis...

Running event identification for: 2010-01-01T10:51:44.773Z - 2010-01-01T14:38:59.773Z
        Computing joint-likelihoods...
                Progress:       [&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;]
        Clustering detections into events...
        Trimming poor linkages and repeating clustering analysis...

Running event identification for: 2010-01-01T12:07:29.773Z - 2010-01-01T15:54:44.773Z
        Computing joint-likelihoods...
                Progress:       [&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;]
        Clustering detections into events...
        Trimming poor linkages and repeating clustering analysis...

Running event identification for: 2010-01-01T13:23:14.773Z - 2010-01-01T17:10:29.773Z
        Computing joint-likelihoods...
                Progress:       [&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;]
        Clustering detections into events...
        Trimming poor linkages and repeating clustering analysis...

Cleaning up and merging clusters...
identified 3 events.
</pre></div>
</div>
<p>The analysis breaks the detection list into segments defined by the maximum propagation distance allows in order to avoid including detections in one analysis that will not be associated with others due to differences in detection times and typical infrasonic propagation velocities.  For each event identified in the analysis, a new .dets.json file is written that includes the subset of the original detections that have been identified as originating from a common event.  The naming convention of these files is <code class="code docutils literal notranslate"><span class="pre">local_event_label_ev-#.dets.json</span></code> and the example analysis here should have identified 3 events.</p>
</div></blockquote>
</li>
<li><p>Detection sets can be visualized on a map using the <code class="code docutils literal notranslate"><span class="pre">plot</span> <span class="pre">dets</span></code> option.  This is useful in determining a useful maximum range for event identification and localization analysis.  For the above analysis of the Blom et al. (2020) synthetic data set, the full data set can be visualized with,</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>infrapy plot dets --local-detect-label <span class="s1">&#39;data/Blom_etal2020_GJI/*&#39;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/plot_dets1.png"><img alt="_images/plot_dets1.png" class="align-center" src="_images/plot_dets1.png" style="width: 1200px;" /></a>
<p>This result is rather busy, but plotting each individual event’s detections shows that the association algorithm correctly identified the events,</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>infrapy plot dets --local-detect-label <span class="s1">&#39;GJI_example-ev0.dets.json&#39;</span>  --range-max <span class="m">1000</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/plot_dets2.png"><img alt="_images/plot_dets2.png" class="align-center" src="_images/plot_dets2.png" style="width: 1200px;" /></a>
</div></blockquote>
</li>
<li><p>Once an event has been identified, the detections can be analyzed using the Bayesian Infrasonic Source Localization (BISL) methods as discussed in Blom et al. (2015).  This requires specifying the detection list file as well as an output location file label,</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>infrapy run_loc --local-detect-label GJI_example-ev0  --local-loc-label GJI_example-ev0
</pre></div>
</div>
<p>The analysis steps are updated as localization is performed and the resulting location and origin time information is printed to screen as well as written into an output file (the output file for InfraPy’s localization is also a .json format file, but it’s naming convention uses “.loc.json” to distinguish it from a “.dets.json” detection file)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#####################################
##                                 ##
##             InfraPy             ##
##      Localization Analysis      ##
##                                 ##
#####################################

Data summary:
  local_event_label: example1-ev0
  local_loc_label: example1-ev0

Parameter summary:
  back_az_width: 10.0
  range_max: 2000.0
  resolution: 180
  src_est: None
  pgm_file: None

Loading detections from file: example1-ev0.dets.json

Running Bayesian Infrasonic Source Localization (BISL) Analysis...
        Identifying integration region...
        Computing marginalized spatial PDF...
        Computing confidence ellipse parameters...
        Computing marginalized origin time PDF...

BISL Summary:
Maximum a posteriori analysis:
        Source location: 37.212, -115.283
        Source time: 2010-01-01T12:11:16.645000
Source location analysis:
        Latitude (mean and standard deviation): 37.212 +/- 27.882 km.
        Longitude (mean and standard deviation): -115.283 +/- 34.18 km.
        Covariance: -0.41.
        Area of 95 confidence ellipse: 17938.387 square kilometers
Source time analysis:
        Mean and standard deviation: 2010-01-01T12:11:55.838 +/- 100.512 second
        Exact 90% confidence bounds: [2010-01-01T12:09:12.885, 2010-01-01T12:14:46.185]

Writing localization result into GJI_example-ev0.loc.json
</pre></div>
</div>
<p>The localization result can be visualized in a number of ways.  Firstly, the detecting arrays and location estimate can be plotted on map using,</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>infrapy plot loc --local-detect-label GJI_example-ev0 --local-loc-label GJI_example-ev0 --range-max <span class="m">1200</span>.0
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/plot_loc1.png"><img alt="_images/plot_loc1.png" class="align-center" src="_images/plot_loc1.png" style="width: 1200px;" /></a>
<p>For visualization of the source region in more detail, the <code class="code docutils literal notranslate"><span class="pre">--zoom</span></code> option can be set to true and the map zooms in to show only the estimated source region.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>infrapy plot loc --local-detect-label GJI_example-ev0 --local-loc-label GJI_example-ev0 --zoom <span class="nb">true</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/plot_loc2.png"><img alt="_images/plot_loc2.png" class="align-center" src="_images/plot_loc2.png" style="width: 900px;" /></a>
<p>Lastly, the origin time is estimated as part of the BISL analysis and can be visualized as,</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>infrapy plot origin-time --local-loc-label GJI_example-ev0
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/plot_origin_time.png"><img alt="_images/plot_origin_time.png" class="align-center" src="_images/plot_origin_time.png" style="width: 1200px;" /></a>
</div></blockquote>
</li>
<li><p>For above-ground explosive sources for which source models such as the Kinney &amp; Graham blastwave scaling laws can be used to relate acoustic power to yield, InfraPy’s Spectral Yield Estimate (SpYE) methods can be applied.  Usage of these methods requires a detection file, waveform data for detecting stations, and transmission loss models relating downrange observations to a near-source reference point.  Analysis of the Humming Roadrunner 5 event is included (requires downloading the separate infrapy-data repository):</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>infrapy run_yield --local-wvfrms <span class="s1">&#39;../infrapy-data/hrr-5/*/*.sac&#39;</span> --local-detect-label data/HRR-5.dets.json --src-lat <span class="m">33</span>.5377 --src-lon -106.333961 --tlm-label <span class="s2">&quot;../infrapy/propagation/priors/tloss/2007_08-&quot;</span> --local-yld-label <span class="s2">&quot;HRR-5&quot;</span>
</pre></div>
</div>
<p>As with other analysis methods, parameter information will be summarized and high level results:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#####################################
##                                 ##
##             InfraPy             ##
##    Yield Estimation Analysis    ##
##                                 ##
#####################################


Data parameters:
local_detect_label: data/HRR-5.dets.json
tlm_label: ../infrapy/propagation/priors/tloss/2007_08-
local_loc_label: None
  src_lat: 33.5377
  src_lon: -106.333961
local_wvfrms: ../infrapy-data/hrr-5/*/*.sac

Algorithm parameters:
  freq_min: 0.25
  freq_max: 1.0
  yld_min: 1.0
  yld_max: 1000.0
  ref_rng: 1.0
  resolution: 200
  noise_option: post
  window_buffer: 0.2
  amb_press: 101.325
  amb_temp: 288.15
  grnd_burst: True
  exp_type: chemical

Loading local data from ../infrapy-data/hrr-5/*/*.sac
Collecting waveform data for each detection...

Detection network.station: NCPA.W220
4 Trace(s) in Stream:
.W220CW..HDF | 2012-08-27T23:10:00.000000Z - 2012-08-27T23:24:59.998055Z | 500.0 Hz, 450000 samples
.W220NE..HDF | 2012-08-27T23:10:00.000000Z - 2012-08-27T23:24:59.998055Z | 500.0 Hz, 450000 samples
.W220NW..HDF | 2012-08-27T23:10:00.000000Z - 2012-08-27T23:24:59.998055Z | 500.0 Hz, 450000 samples
.W220SW..HDF | 2012-08-27T23:10:00.000000Z - 2012-08-27T23:24:59.998055Z | 500.0 Hz, 450000 samples

Detection network.station: NCPA.W240
3 Trace(s) in Stream:
.W240NE..HDF | 2012-08-27T23:10:00.000000Z - 2012-08-27T23:24:59.998055Z | 500.0 Hz, 450000 samples
.W240NW..HDF | 2012-08-27T23:10:00.000000Z - 2012-08-27T23:24:59.998055Z | 500.0 Hz, 450000 samples
.W240SW..HDF | 2012-08-27T23:10:00.000000Z - 2012-08-27T23:24:59.998055Z | 500.0 Hz, 450000 samples

Detection network.station: .W340
4 Trace(s) in Stream:
.W340CW..HDF | 2012-08-27T23:15:00.000000Z - 2012-08-27T23:34:59.998073Z | 500.0 Hz, 600000 samples
.W340NW..HDF | 2012-08-27T23:15:00.000000Z - 2012-08-27T23:34:59.998073Z | 500.0 Hz, 600000 samples
.W340SE..HDF | 2012-08-27T23:14:44.000000Z - 2012-08-27T23:34:43.998073Z | 500.0 Hz, 600000 samples
.W340SW..HDF | 2012-08-27T23:15:00.000000Z - 2012-08-27T23:34:59.998073Z | 500.0 Hz, 600000 samples

Detection network.station: .W420
6 Trace(s) in Stream:
.W420CE..HDF | 2012-08-27T23:20:01.000000Z - 2012-08-27T23:40:00.998073Z | 500.0 Hz, 600000 samples
.W420CW..HDF | 2012-08-27T23:20:00.000000Z - 2012-08-27T23:39:59.998073Z | 500.0 Hz, 600000 samples
.W420NE..HDF | 2012-08-27T23:20:00.000000Z - 2012-08-27T23:39:59.998073Z | 500.0 Hz, 600000 samples
.W420NW..HDF | 2012-08-27T23:20:00.000000Z - 2012-08-27T23:39:59.998073Z | 500.0 Hz, 600000 samples
.W420SE..HDF | 2012-08-27T23:20:00.000000Z - 2012-08-27T23:39:59.998073Z | 500.0 Hz, 600000 samples
.W420SW..HDF | 2012-08-27T23:19:44.000000Z - 2012-08-27T23:39:43.998073Z | 500.0 Hz, 600000 samples

Detection network.station: .W460
6 Trace(s) in Stream:
.W460CE..HDF | 2012-08-27T23:20:00.000000Z - 2012-08-27T23:39:59.998073Z | 500.0 Hz, 600000 samples
.W460CW..HDF | 2012-08-27T23:20:00.000000Z - 2012-08-27T23:39:59.998073Z | 500.0 Hz, 600000 samples
.W460NE..HDF | 2012-08-27T23:20:00.000000Z - 2012-08-27T23:39:59.998073Z | 500.0 Hz, 600000 samples
.W460NW..HDF | 2012-08-27T23:20:00.000000Z - 2012-08-27T23:39:59.998073Z | 500.0 Hz, 600000 samples
.W460SE..HDF | 2012-08-27T23:20:00.000000Z - 2012-08-27T23:39:59.998073Z | 500.0 Hz, 600000 samples
.W460SW..HDF | 2012-08-27T23:20:00.000000Z - 2012-08-27T23:39:59.998073Z | 500.0 Hz, 600000 samples

Computing detection spectra...
Loading transmission loss statistics...
Estimating yield using spectral amplitudes...
Writing yield estimate result into HRR-5.yld.json

Results Summary (tons eq. TNT):
    Maximum a Posteriori Yield: 45.5293507487
        68% Confidence Bounds: [  21.  115.]
        95% Confidence Bounds: [   3.  358.]
</pre></div>
</div>
<p>The example here utilizes a ground truth location for the source; though, the method can also accept a location result file from BISL (<code class="code docutils literal notranslate"><span class="pre">[...].loc.json</span></code>) and extract the location from that source.  The current implementation can only utilize locally saved waveform data ingested as a single large stream and sub-divided using the network and station info in the detection file.  Eventually, it is planned to allow the methods to pull from an FDSN or database, but for now analysis requires pulling waveform files (this can be done using <code class="code docutils literal notranslate"><span class="pre">infrapy</span> <span class="pre">utils</span> <span class="pre">write-wvfrms</span></code>).</p>
<p>Visualization of the SpYE analysis result can be done by referencing the output file,</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>infrapy plot yield --local-yld-label <span class="s2">&quot;HRR-5&quot;</span>
</pre></div>
</div>
<p>This once again prints the MaP yield and confidence bounds and produces a figure such as that shown below where the left panel shows the PDF for yield and the right panel shows the predicted spectral amplitude near the source (specifically at a stand off distance of <code class="code docutils literal notranslate"><span class="pre">--ref-rng</span></code>).</p>
<a class="reference internal image-reference" href="_images/spye_result.png"><img alt="_images/spye_result.png" class="align-center" src="_images/spye_result.png" style="width: 1200px;" /></a>
</div></blockquote>
</li>
</ul>
</section>
</section>
<section id="scripting-and-notebook-based-analysis">
<h2>Scripting and Notebook-Based Analysis<a class="headerlink" href="#scripting-and-notebook-based-analysis" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>In addition to the command line interface methods for infrapy, the analysis algorithms can be imported directly into user Python scripts or notebooks for custom applications.  Example import and usage scripts are included in the examples/ directory and will be detailed below for this somewhat more advanced usage.  The example scripts are summarized in the below table.</p></li>
</ul>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>example_fkd.py</p></td>
<td><p>Run beamforming and detection analysis on an Obspy stream</p></td>
</tr>
<tr class="row-even"><td><p>example_assoc.py</p></td>
<td><p>Run event identification methods on a list of detections</p></td>
</tr>
<tr class="row-odd"><td><p>example_bisl.py</p></td>
<td><p>Run localization methods on a list of detections</p></td>
</tr>
<tr class="row-even"><td><p>example_yield.py</p></td>
<td><p>Run spectral yield estimation methods</p></td>
</tr>
</tbody>
</table>
<ul>
<li><p>The beamforming and detection analysis can be imported from the <code class="code docutils literal notranslate"><span class="pre">infrapy.detection.beamforming_new</span></code> library.  Beamforming analysis includes setting up an ObsPy stream, converting it to an array data instance, and then scanning through with a defined analysis window.</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">obspy.core</span> <span class="kn">import</span> <span class="n">read</span>
<span class="kn">from</span> <span class="nn">infrapy.detection</span> <span class="kn">import</span> <span class="n">beamforming_new</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="c1"># ######################### #</span>
    <span class="c1">#     Define Parameters     #</span>
    <span class="c1"># ######################### #</span>
    <span class="n">sac_glob</span> <span class="o">=</span> <span class="s2">&quot;data/YJ.BRP*.SAC&quot;</span>

    <span class="n">freq_min</span><span class="p">,</span> <span class="n">freq_max</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.5</span>
    <span class="n">fk_win_len</span><span class="p">,</span> <span class="n">window_step</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">2.5</span>
    <span class="n">sig_start</span><span class="p">,</span> <span class="n">sig_end</span> <span class="o">=</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">800</span>

    <span class="n">back_az_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mf">180.0</span><span class="p">,</span> <span class="mf">180.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">trc_vel_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">300.0</span><span class="p">,</span> <span class="mf">600.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>

    <span class="c1"># ######################### #</span>
    <span class="c1">#        Run Methods        #</span>
    <span class="c1"># ######################### #</span>

    <span class="c1"># Read data and convert to array format</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">geom</span> <span class="o">=</span> <span class="n">beamforming_new</span><span class="o">.</span><span class="n">stream_to_array_data</span><span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">sac_glob</span><span class="p">))</span>
    <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Define slowness and delays</span>
    <span class="n">slowness</span> <span class="o">=</span> <span class="n">beamforming_new</span><span class="o">.</span><span class="n">build_slowness</span><span class="p">(</span><span class="n">back_az_vals</span><span class="p">,</span> <span class="n">trc_vel_vals</span><span class="p">)</span>
    <span class="n">delays</span> <span class="o">=</span> <span class="n">beamforming_new</span><span class="o">.</span><span class="n">compute_delays</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">slowness</span><span class="p">)</span>

    <span class="c1"># Run beamforming in each window and find best beam info</span>
    <span class="n">times</span><span class="p">,</span> <span class="n">beam_results</span> <span class="o">=</span> <span class="p">[],[]</span>
    <span class="k">for</span> <span class="n">window_start</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sig_start</span><span class="p">,</span> <span class="n">sig_end</span><span class="p">,</span> <span class="n">window_step</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">window_start</span> <span class="o">+</span> <span class="n">fk_win_len</span> <span class="o">&gt;</span> <span class="n">sig_end</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">X</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">beamforming_new</span><span class="o">.</span><span class="n">fft_array_data</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="p">[</span><span class="n">window_start</span><span class="p">,</span> <span class="n">window_start</span> <span class="o">+</span> <span class="n">fk_win_len</span><span class="p">])</span>
        <span class="n">beam_power</span> <span class="o">=</span> <span class="n">beamforming_new</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">geom</span><span class="p">,</span> <span class="n">delays</span><span class="p">,</span> <span class="p">[</span><span class="n">freq_min</span><span class="p">,</span> <span class="n">freq_max</span><span class="p">])</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">beamforming_new</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">beam_power</span><span class="p">,</span> <span class="n">back_az_vals</span><span class="p">,</span> <span class="n">trc_vel_vals</span><span class="p">)</span>

        <span class="n">times</span> <span class="o">=</span> <span class="n">times</span> <span class="o">+</span> <span class="p">[[</span><span class="n">t0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">window_start</span><span class="p">),</span> <span class="s1">&#39;s&#39;</span><span class="p">)]]</span>
        <span class="n">beam_results</span> <span class="o">=</span> <span class="n">beam_results</span> <span class="o">+</span> <span class="p">[[</span><span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]]</span>

    <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">times</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">beam_results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">beam_results</span><span class="p">)</span>
</pre></div>
</div>
<p>Detection analysis is then completed by scanning back through the beamforming results and can be appended to the end of the above beamforming analysis as it requires the times and beam_results information computed there.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fd_win_len</span> <span class="o">=</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">5</span>
<span class="n">det_thresh</span> <span class="o">=</span> <span class="mf">0.99</span>

<span class="n">min_seq</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">back_az_lim</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">TB_prod</span> <span class="o">=</span> <span class="p">(</span><span class="n">freq_max</span> <span class="o">-</span> <span class="n">freq_min</span><span class="p">)</span> <span class="o">*</span> <span class="n">fk_window_len</span>
<span class="n">dets</span> <span class="o">=</span> <span class="n">beamforming_new</span><span class="o">.</span><span class="n">detect_signals</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">beam_results</span><span class="p">,</span> <span class="n">fd_win_len</span><span class="p">,</span> <span class="n">TB_prod</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">min_seq</span><span class="o">=</span><span class="n">min_seq</span><span class="p">,</span> <span class="n">back_az_lim</span><span class="o">=</span><span class="n">back_az_lim</span><span class="p">)</span>

<span class="k">for</span> <span class="n">det</span> <span class="ow">in</span> <span class="n">dets</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Detection time:&quot;</span><span class="p">,</span> <span class="n">det</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s2">&quot;Rel. detection onset:&quot;</span><span class="p">,</span> <span class="n">det</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span><span class="s2">&quot;Rel. detection end:&quot;</span><span class="p">,</span> <span class="n">det</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Back azimuth:&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">det</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s2">&quot;Trace velocity:&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">det</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s2">&quot;F-stat:&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">det</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s2">&quot;Array dim:&quot;</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>The association methods require ingesting a detection list and defining a clustering threshold for the hierarchical linkage cut off.  The likelihood methods include a function to read in a .json format file as output in the CLI detection analysis.</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">infrapy.association</span> <span class="kn">import</span> <span class="n">hjl</span>
<span class="kn">from</span> <span class="nn">infrapy.utils</span> <span class="kn">import</span> <span class="n">data_io</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">det_list</span> <span class="o">=</span> <span class="n">data_io</span><span class="o">.</span><span class="n">json_to_detection_list</span><span class="p">(</span><span class="s1">&#39;data/example1.dets.json&#39;</span><span class="p">)</span>
    <span class="n">clustering_threshold</span> <span class="o">=</span> <span class="mf">5.0</span>

    <span class="n">labels</span><span class="p">,</span> <span class="n">dists</span> <span class="o">=</span> <span class="n">hjl</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">det_list</span><span class="p">,</span> <span class="n">clustering_threshold</span><span class="p">)</span>

    <span class="n">clusters</span><span class="p">,</span> <span class="n">qualities</span> <span class="o">=</span> <span class="n">hjl</span><span class="o">.</span><span class="n">summarize_clusters</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">dists</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cluster:&quot;</span><span class="p">,</span> <span class="n">clusters</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s2">&quot;Cluster Quality:&quot;</span><span class="p">,</span> <span class="mf">10.0</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">qualities</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>Similar to the association methods, localization requires just a detection set from an event:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">infrapy.location</span> <span class="kn">import</span> <span class="n">bisl</span>
<span class="kn">from</span> <span class="nn">infrapy.utils</span> <span class="kn">import</span> <span class="n">data_io</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">det_list</span> <span class="o">=</span> <span class="n">data_io</span><span class="o">.</span><span class="n">json_to_detection_list</span><span class="p">(</span><span class="s1">&#39;data/example2.dets.json&#39;</span><span class="p">)</span>

    <span class="n">result</span><span class="p">,</span><span class="n">pdf</span> <span class="o">=</span> <span class="n">bisl</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">det_list</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">bisl</span><span class="o">.</span><span class="n">summarize</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>Yield estimation analysis is a bit challenging to perform interactively or even in an automated way because analysis parameters include the detection file for the event, waveform data from the various detecting stations, transmission loss models, and a source model.  An initial version of this is implemented as part of InfraPy’s command line interface as discussed above; however, it is likely a user may prefer to interact directly with the data ingestion and analysis.</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">obspy.core</span> <span class="kn">import</span> <span class="n">read</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">infrapy.utils</span> <span class="kn">import</span> <span class="n">data_io</span>
<span class="kn">from</span> <span class="nn">infrapy.propagation</span> <span class="kn">import</span> <span class="n">infrasound</span>

<span class="kn">from</span> <span class="nn">infrapy.characterization</span> <span class="kn">import</span> <span class="n">spye</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># ######################### #</span>
    <span class="c1">#     Define Parameters     #</span>
    <span class="c1"># ######################### #</span>

    <span class="n">det_file</span> <span class="o">=</span> <span class="s2">&quot;data/HRR-5.dets.json&quot;</span>
    <span class="n">wvfrm_path</span> <span class="o">=</span> <span class="s2">&quot;../infrapy-data/hrr-5/*/*.sac&quot;</span>
    <span class="n">tloss_path</span> <span class="o">=</span> <span class="s2">&quot;../infrapy/propagation/priors/tloss/2007_08-&quot;</span>
</pre></div>
</div>
<p>The analysis parameters include a noise option (“pre” or “post” detection window), a window buffer factor that extends the sample window beyond the detection window by some factor (0.2 meaning a 20% increase in the window length here), a source location, frequency band, yield range, and reference distance from the source at which to compute the source spectral estimate.  If a ground truth yield is known it can be specified and the frequency-yield resolution of the grid can be specified.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ns_opt</span> <span class="o">=</span> <span class="s2">&quot;post&quot;</span>
<span class="n">win_buffer</span> <span class="o">=</span> <span class="mf">0.2</span>

<span class="n">src_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">33.5377</span><span class="p">,</span> <span class="o">-</span><span class="mf">106.333961</span><span class="p">])</span>
<span class="n">freq_band</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>
<span class="n">yld_rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0e3</span><span class="p">,</span> <span class="mf">1000.0e3</span><span class="p">])</span>
<span class="n">ref_rng</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="n">grnd_truth</span><span class="o">=</span><span class="kc">None</span>
<span class="n">resol</span> <span class="o">=</span> <span class="mi">200</span>
</pre></div>
</div>
<p>The detection list and waveform files are ingested and spectral amplitudes are computed,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># ############################# #</span>
<span class="c1">#     Define the detections     #</span>
<span class="c1">#          and spectra          #</span>
<span class="c1"># ############################# #</span>
<span class="n">det_list</span> <span class="o">=</span> <span class="n">data_io</span><span class="o">.</span><span class="n">json_to_detection_list</span><span class="p">(</span><span class="n">det_file</span><span class="p">)</span>
<span class="n">st_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">Stream</span><span class="p">([</span><span class="n">tr</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">read</span><span class="p">(</span><span class="n">wvfrm_path</span><span class="p">)</span> <span class="k">if</span> <span class="n">det</span><span class="o">.</span><span class="n">station</span> <span class="ow">in</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span><span class="p">])</span> <span class="k">for</span> <span class="n">det</span> <span class="ow">in</span> <span class="n">det_list</span><span class="p">]</span>
<span class="n">smn_specs</span> <span class="o">=</span> <span class="n">spye</span><span class="o">.</span><span class="n">extract_spectra</span><span class="p">(</span><span class="n">det_list</span><span class="p">,</span> <span class="n">st_list</span><span class="p">,</span> <span class="n">win_buffer</span><span class="o">=</span><span class="n">win_buffer</span><span class="p">,</span> <span class="n">ns_opt</span><span class="o">=</span><span class="n">ns_opt</span><span class="p">)</span>
</pre></div>
</div>
<p>The transmission loss model models are defined and loaded,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># ######################### #</span>
<span class="c1">#     Load TLoss Models     #</span>
<span class="c1"># ######################### #</span>
<span class="n">tloss_f_min</span><span class="p">,</span> <span class="n">tloss_f_max</span><span class="p">,</span> <span class="n">tloss_f_cnt</span> <span class="o">=</span> <span class="mf">0.025</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">25</span>

<span class="n">models</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
<span class="n">models</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">tloss_f_min</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">tloss_f_max</span><span class="p">),</span> <span class="n">tloss_f_cnt</span><span class="p">))</span>
<span class="n">models</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">tloss_f_cnt</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tloss_f_cnt</span><span class="p">):</span>
    <span class="n">models</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">infrasound</span><span class="o">.</span><span class="n">TLossModel</span><span class="p">()</span>
    <span class="n">models</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">tloss_path</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">%.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">models</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;Hz.pri&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, analysis can be performed, and results printed and visualized,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># ######################## #</span>
<span class="c1">#         Run Yield        #</span>
<span class="c1">#    Estimation Methods    #</span>
<span class="c1"># ######################## #</span>
<span class="n">yld_results</span> <span class="o">=</span> <span class="n">spye</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">det_list</span><span class="p">,</span> <span class="n">smn_specs</span><span class="p">,</span> <span class="n">src_loc</span><span class="p">,</span> <span class="n">freq_band</span><span class="p">,</span> <span class="n">models</span><span class="p">,</span> <span class="n">yld_rng</span><span class="o">=</span><span class="n">yld_rng</span><span class="p">,</span> <span class="n">ref_src_rng</span><span class="o">=</span><span class="n">ref_rng</span><span class="p">,</span> <span class="n">resol</span><span class="o">=</span><span class="n">resol</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Results:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s2">&quot;Maximum a Posteriori Yield:&quot;</span><span class="p">,</span> <span class="n">yld_results</span><span class="p">[</span><span class="s1">&#39;yld_vals&#39;</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">yld_results</span><span class="p">[</span><span class="s1">&#39;yld_pdf&#39;</span><span class="p">])])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s2">&quot;68% Confidence Bounds:&quot;</span><span class="p">,</span> <span class="n">yld_results</span><span class="p">[</span><span class="s1">&#39;conf_bnds&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s2">&quot;95% Confidence Bounds:&quot;</span><span class="p">,</span> <span class="n">yld_results</span><span class="p">[</span><span class="s1">&#39;conf_bnds&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="n">yld_results</span><span class="p">[</span><span class="s1">&#39;yld_vals&#39;</span><span class="p">],</span> <span class="n">yld_results</span><span class="p">[</span><span class="s1">&#39;yld_pdf&#39;</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">yld_results</span><span class="p">[</span><span class="s1">&#39;yld_vals&#39;</span><span class="p">],</span> <span class="n">yld_results</span><span class="p">[</span><span class="s1">&#39;yld_pdf&#39;</span><span class="p">],</span> <span class="n">where</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">yld_results</span><span class="p">[</span><span class="s1">&#39;conf_bnds&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">yld_results</span><span class="p">[</span><span class="s1">&#39;yld_vals&#39;</span><span class="p">],</span> <span class="n">yld_results</span><span class="p">[</span><span class="s1">&#39;yld_vals&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">yld_results</span><span class="p">[</span><span class="s1">&#39;conf_bnds&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">yld_results</span><span class="p">[</span><span class="s1">&#39;yld_vals&#39;</span><span class="p">],</span> <span class="n">yld_results</span><span class="p">[</span><span class="s1">&#39;yld_pdf&#39;</span><span class="p">],</span> <span class="n">where</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">yld_results</span><span class="p">[</span><span class="s1">&#39;conf_bnds&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">yld_results</span><span class="p">[</span><span class="s1">&#39;yld_vals&#39;</span><span class="p">],</span> <span class="n">yld_results</span><span class="p">[</span><span class="s1">&#39;yld_vals&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">yld_results</span><span class="p">[</span><span class="s1">&#39;conf_bnds&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="installation.html" class="btn btn-neutral float-left" title="Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="infraview.html" class="btn btn-neutral float-right" title="InfraView" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, F.Dannemann Dugick, P.Blom, J.Webster.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>