<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Array Processing &mdash; Infrapy 1.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Detection" href="detection.html" />
    <link rel="prev" title="Algorithms" href="algorithms.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Infrapy
            <img src="_static/lanl_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="userguide.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="authorship.html">Authorship</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="infraview.html">InfraView</a></li>
<li class="toctree-l1"><a class="reference internal" href="pisces.html">Interfacing with Pisces</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="algorithms.html">Algorithms</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Array Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="detection.html">Detection</a></li>
<li class="toctree-l2"><a class="reference internal" href="association.html">Association</a></li>
<li class="toctree-l2"><a class="reference internal" href="localization.html">Localization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="processing_model.html">Data Processing Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="schema.html">Schema</a></li>
<li class="toctree-l1"><a class="reference internal" href="infrapy.html">API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Infrapy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="algorithms.html">Algorithms</a> &raquo;</li>
      <li>Array Processing</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/beamforming.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="array-processing">
<span id="beamforming"></span><h1>Array Processing<a class="headerlink" href="#array-processing" title="Permalink to this headline"></a></h1>
<p>The use of infrasonic arrays, specifically for CTBT applications, is preferable due to the inherent reduction in signal-to-noise ratios (SNR) originating from the summation of four or more recordings at each array. The nature of a decision-rule based detector requires data that has been pre-processed using beamforming methods. Beamforming, a form of array processing, is the first step in the analysis of data from infrasonic arrays.    Conventional beamforming methods (Bartlett, Capon) separate coherent and incoherent parts of a signal through the assumption of planar waves arriving at the array.  A signal backazimuth and slowness can be estimated as signals are shifted to account for travel time differentials across array elements, bringing the signal into phase across as the noise deconstructively cancels out.  In the classical, or Bartlett methodology , data records on each array element are time-shifted versions of the other with local noise,</p>
<section id="mathematical-details">
<h2>Mathematical Details<a class="headerlink" href="#mathematical-details" title="Permalink to this headline"></a></h2>
<ul>
<li><p>Beamforming in InfraPy is completed in the frequency domain using a model in which the data on the <span class="math notranslate nohighlight">\(m^\text{th}\)</span> sensor of an array is a combation of a time-shifted coherent signal and local noise,</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[x_m \left( t \right) = g \left( t - \tau_m \right) + \eta_m \left( t \right)\]</div>
<p>In vector form, this is,</p>
<div class="math notranslate nohighlight">
\[\vec{x} \left( t \right) = g \left( t - \vec{\tau} \right) + \vec{\eta} \left( t \right)\]</div>
<p>Taking a Fourier transform of this relation gives the signal model form in the frequency domain,</p>
<div class="math notranslate nohighlight">
\[\vec{\mathcal{X}} \left( f \right) = \mathcal{G} \left( f \right) \vec{\Phi} + \vec{\mathcal{N}} \left( f \right), \quad \vec{\Phi} \left(f, \vec{\tau} \right) = e^{- 2 i \pi f \vec{\tau}}\]</div>
<p>where <span class="math notranslate nohighlight">\(\vec{\Phi}\)</span> is a vector of phasors often termed the “steering vector”.</p>
</div></blockquote>
</li>
<li><p>The time delays in the steering vector can be defined for a plane wave assumption by characterizing the planewave by a direction-of-arrival azimuth, <span class="math notranslate nohighlight">\(\varphi\)</span>, and a trace velocity at which the sound propagates across the ground surface, <span class="math notranslate nohighlight">\(v_\text{tr} = \frac{c_0}{\cos \vartheta}\)</span>, that varies with the ambient sound speed, <span class="math notranslate nohighlight">\(c_0\)</span>, and planewave inclination angle, <span class="math notranslate nohighlight">\(\vartheta\)</span>.  These parameter define the slowness, <span class="math notranslate nohighlight">\(\vec{s}\)</span> of the planewave, which can be combined with the locations of the array elements, <span class="math notranslate nohighlight">\(\vec{z}_j\)</span>, to define the arrival time delays,</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\tau_j = \vec{s} \cdot \vec{z}_j, \quad \vec{s} = \left( \frac{\sin \varphi}{v_\text{tr}}, \frac{\cos \varphi}{v_\text{tr}} \right)\]</div>
</div></blockquote>
</li>
<li><p>The ordinary least squares estimate for the coherent signal is more commonly termed the Bartlett beam and can be defined as,</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\hat{\mathcal{G}}_\text{Bartlett} \left( f, \vec{s} \right) = \frac{\vec{\mathcal{X}}^\dagger \vec{\Phi}}{\vec{\Phi}^\dagger \vec{\Phi}}\]</div>
<p>In the case that the background covariance is known, the generalized least squares (GLS) method can be applied,</p>
<div class="math notranslate nohighlight">
\[\hat{\mathcal{G}}_\text{GLS} \left( f, \vec{s}, \mathbf{S}_\mathcal{N} \right) = \frac{\vec{\mathcal{X}}^\dagger \mathbf{S}_\mathcal{N}^{-1} \vec{\Phi}}{\vec{\Phi}^\dagger \mathbf{S}_\mathcal{N}^{-1} \vec{\Phi}}\]</div>
<p>The noise covariance can be estimated in the <a class="reference internal" href="infraview.html#infraview"><span class="std std-ref">InfraView</span></a> interface via the red noise window and in the CLI <code class="code docutils literal notranslate"><span class="pre">run_fk</span></code> methods via the <code class="code docutils literal notranslate"><span class="pre">noise_start</span></code> and <code class="code docutils literal notranslate"><span class="pre">noise_end</span></code> parameters.  Applying the GLS method in an automated way requires adaptively estimating the noise covariance while analyzing data, which is an area of ongoing research.</p>
<p>In both of these cases, the estimated beam power is often expressed as the square of the estimated signal amplitude (e.g., <span class="math notranslate nohighlight">\(\mathcal{P}_\text{Bartlett} \left( f, \vec{s} \right) = \hat{\mathcal{G}}_\text{Bartlett}^2 \left( f, \vec{s} \right)\)</span>).</p>
</div></blockquote>
</li>
<li><p>Several covariance-based relations discussed in detail in Krim &amp; Viberg (1996) are also implemented in the InfraPy beamforming methods.  For each method, a signal covariance matrix is computed from the outer product of the signal vector, <span class="math notranslate nohighlight">\(\mathbf{S}_\mathcal{X} = \frac{1}{J} \sum_j{ \vec{\mathcal{X}}_j \vec{\mathcal{X}}_j ^\dagger}\)</span> and that matrix is used in analysis.  In order to utilize these methods, multiple sub-windows are needed to ensure that the estimated covariance matrix is full rank for inversion or eigen-decomposition; however, a whitening step is included to ensure these options are possible.  From the above definition, it’s clear that the Bartlett beam can be defined from the signal covariance as,</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\hat{\mathcal{P}}_\text{Bartlett} \left( f, \vec{s} \right) = \left| \frac{\vec{\Phi}^\dagger \mathbf{S}_\mathcal{X} \vec{\Phi}}{\vec{\Phi}^\dagger \vec{\Phi}} \right|^\frac{1}{2}\]</div>
<p>The Minimum Variance Distortionless Response (MVDR, also teremd the Capon beam) has the form,</p>
<div class="math notranslate nohighlight">
\[\hat{\mathcal{P}}_\text{MVDR} \left( f, \vec{s} \right) = \frac{1}{\vec{\Phi}^\dagger \mathbf{S}_\mathcal{X}^{-1} \vec{\Phi}}\]</div>
<p>The MUltiple SIgnal Classification (MUSIC) algorithm takes an eigen-decomposition of the signal covariance and defines the noise sub-space from the <span class="math notranslate nohighlight">\(M - q\)</span> eigenvectors associated with the lowest eigenvalues.  Denoting this subpace as <span class="math notranslate nohighlight">\(\mathbf{\Pi}_q\)</span> where <span class="math notranslate nohighlight">\(q\)</span> denotes the assumed number of signal eigenvectors, the MUSIC beam has a form similar to the MVDR,</p>
<div class="math notranslate nohighlight">
\[\hat{\mathcal{P}}_\text{MUSIC} \left( f, \vec{s}, q \right) = \frac{1}{\vec{\Phi}^\dagger \mathbf{\Pi}_q \vec{\Phi}}\]</div>
</div></blockquote>
</li>
</ul>
<dl class="simple">
<dt>See the following for more references on beamforming:</dt><dd><ul class="simple">
<li><p><a class="reference external" href="https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2000RG000100">Rost and Thomas, 2002</a></p></li>
<li><p><a class="reference external" href="https://link.springer.com/chapter/10.1007/978-0-387-30441-0_81">Olson and Szuberla, 2010</a></p></li>
<li><p><a class="reference external" href="https://asa.scitation.org/doi/full/10.1121/1.4818940">Costley, 2013</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1109/79.526899">Krim and Viberg, 1996</a></p></li>
</ul>
</dd>
</dl>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="algorithms.html" class="btn btn-neutral float-left" title="Algorithms" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="detection.html" class="btn btn-neutral float-right" title="Detection" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, F.Dannemann Dugick, P.Blom, J.Webster.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>